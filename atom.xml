<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>道简顿悟，法深渐修</title>
  
  <subtitle>It&#39;s not hard to give up, but it must be cool to stick to it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shatang.github.io/"/>
  <updated>2020-09-06T02:03:46.584Z</updated>
  <id>http://shatang.github.io/</id>
  
  <author>
    <name>Shatang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux思维导图_微观</title>
    <link href="http://shatang.github.io/2020/09/06/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%E5%BE%AE%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/09/06/Linux思维导图-微观/</id>
    <published>2020-09-06T01:57:19.000Z</published>
    <updated>2020-09-06T02:03:46.584Z</updated>
    
    <content type="html"><![CDATA[<p>这篇内容也是转载网上的，但是被人转载(抄)太多次，不太清楚来源；然后采摘总结下来。</p><a id="more"></a><h1 id="一、命令细致讲解"><a href="#一、命令细致讲解" class="headerlink" title="一、命令细致讲解"></a>一、命令细致讲解</h1><h2 id="1-1-帮助命令"><a href="#1-1-帮助命令" class="headerlink" title="1.1 帮助命令"></a>1.1 帮助命令</h2><img src="/2020/09/06/Linux思维导图-微观/1.png"><h2 id="1-2-关机重启"><a href="#1-2-关机重启" class="headerlink" title="1.2 关机重启"></a>1.2 关机重启</h2><img src="/2020/09/06/Linux思维导图-微观/2.png" title="图中的hast应改为halt"><h2 id="1-3-权限管理"><a href="#1-3-权限管理" class="headerlink" title="1.3 权限管理"></a>1.3 权限管理</h2><img src="/2020/09/06/Linux思维导图-微观/3.png"><h2 id="1-4-用户管理"><a href="#1-4-用户管理" class="headerlink" title="1.4 用户管理"></a>1.4 用户管理</h2><img src="/2020/09/06/Linux思维导图-微观/4.png"><h2 id="1-5-文件管理"><a href="#1-5-文件管理" class="headerlink" title="1.5 文件管理"></a>1.5 文件管理</h2><img src="/2020/09/06/Linux思维导图-微观/5.png"><h2 id="1-6-网络配置"><a href="#1-6-网络配置" class="headerlink" title="1.6 网络配置"></a>1.6 网络配置</h2><img src="/2020/09/06/Linux思维导图-微观/6.png"><h2 id="1-7-文件搜索"><a href="#1-7-文件搜索" class="headerlink" title="1.7 文件搜索"></a>1.7 文件搜索</h2><img src="/2020/09/06/Linux思维导图-微观/7.png"><h2 id="1-8-压缩解压"><a href="#1-8-压缩解压" class="headerlink" title="1.8 压缩解压"></a>1.8 压缩解压</h2><img src="/2020/09/06/Linux思维导图-微观/8.png"><h1 id="二、思维导图2"><a href="#二、思维导图2" class="headerlink" title="二、思维导图2"></a>二、思维导图2</h1><p>下面这张导图从以下四个方面讲解linux：</p><ul><li>Linux介绍</li><li>Linux目录结构</li><li>Linux常用命令</li><li>vim详解</li></ul><img src="/2020/09/06/Linux思维导图-微观/9.png"><h1 id="三、思维导图3"><a href="#三、思维导图3" class="headerlink" title="三、思维导图3"></a>三、思维导图3</h1><img src="/2020/09/06/Linux思维导图-微观/10.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇内容也是转载网上的，但是被人转载(抄)太多次，不太清楚来源；然后采摘总结下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Linux思维导图_宏观</title>
    <link href="http://shatang.github.io/2020/09/06/Linux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%E5%AE%8F%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/09/06/Linux思维导图-宏观/</id>
    <published>2020-09-06T01:54:38.000Z</published>
    <updated>2020-09-06T01:57:04.091Z</updated>
    
    <content type="html"><![CDATA[<p>这篇内容是转载网上的，但是被人转载(抄)太多次，不太清楚来源了= =。</p><a id="more"></a><h1 id="一、Linux学习路径"><a href="#一、Linux学习路径" class="headerlink" title="一、Linux学习路径"></a>一、Linux学习路径</h1><img src="/2020/09/06/Linux思维导图-宏观/1.png"><h1 id="二、Linux桌面介绍"><a href="#二、Linux桌面介绍" class="headerlink" title="二、Linux桌面介绍"></a>二、Linux桌面介绍</h1><img src="/2020/09/06/Linux思维导图-宏观/2.png"><h1 id="三、FHS-文件系统目录标准"><a href="#三、FHS-文件系统目录标准" class="headerlink" title="三、FHS(文件系统目录标准)"></a>三、FHS(文件系统目录标准)</h1><h2 id="3-1-详细版"><a href="#3-1-详细版" class="headerlink" title="3.1 详细版"></a>3.1 详细版</h2><img src="/2020/09/06/Linux思维导图-宏观/3.png"><h2 id="3-2-简易版"><a href="#3-2-简易版" class="headerlink" title="3.2 简易版"></a>3.2 简易版</h2><img src="/2020/09/06/Linux思维导图-宏观/4.png"><h1 id="四、Linux内核学习路线"><a href="#四、Linux内核学习路线" class="headerlink" title="四、Linux内核学习路线"></a>四、Linux内核学习路线</h1><img src="/2020/09/06/Linux思维导图-宏观/5.png"><h1 id="五、Linux-Security-Coaching"><a href="#五、Linux-Security-Coaching" class="headerlink" title="五、Linux Security Coaching"></a>五、Linux Security Coaching</h1><img src="/2020/09/06/Linux思维导图-宏观/6.png"><h1 id="六、Linux命令参考"><a href="#六、Linux命令参考" class="headerlink" title="六、Linux命令参考"></a>六、Linux命令参考</h1><h2 id="6-1-Linux命令速查表1"><a href="#6-1-Linux命令速查表1" class="headerlink" title="6.1 Linux命令速查表1"></a>6.1 Linux命令速查表1</h2><img src="/2020/09/06/Linux思维导图-宏观/7.png"><h2 id="6-2-Linux命令速查表2"><a href="#6-2-Linux命令速查表2" class="headerlink" title="6.2 Linux命令速查表2"></a>6.2 Linux命令速查表2</h2><img src="/2020/09/06/Linux思维导图-宏观/8.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇内容是转载网上的，但是被人转载(抄)太多次，不太清楚来源了= =。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>零基础力扣学习</title>
    <link href="http://shatang.github.io/2020/09/06/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%9B%E6%89%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shatang.github.io/2020/09/06/零基础力扣学习/</id>
    <published>2020-09-06T01:51:17.000Z</published>
    <updated>2020-09-06T02:06:20.938Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇内容基本来源于力扣官方在知乎给萌新学习力扣的建议。<br>&emsp;&emsp;在开始刷题前，只需要你至少掌握一门编程语言，即使你从未刷过算法题，从现在开始好好利用这两个月的时间制定合适的学习计划，也可以给自己的算法水平带来质的提升。</p><p>首先，为什么搞嵌入式底层开发还是要学算法和数据结构？</p><p>&emsp;&emsp;虽然在搞嵌入式底层开发大多数数据结构用到的不多，学点常用的基本都能解决问题。例如，递归往往可以用于求解，其本质是从结果倒回输入的求解，常用于算法题，数据检索等；但不常见于嵌入式开发流程的场景应用，因为嵌入式往往是要从输入得到结果。但是我觉得还是有必要深入学习一下，这个不仅仅能够提升你代码的技术水平，还能提高你码代码的视界。</p><a id="more"></a><h1 id="一、算法和数据结构的知识考点"><a href="#一、算法和数据结构的知识考点" class="headerlink" title="一、算法和数据结构的知识考点"></a>一、算法和数据结构的知识考点</h1><blockquote><p>算法和数据结构的关系</p></blockquote><p>&emsp;&emsp;如果把算法比作建筑工程的图纸，数据结构就像是建造大楼的工具。数据结构设计的初衷就是方便程序员使用，虽然看似种类较多，但实际上每一种都不难，可以结合算法一起学习。</p><img src="/2020/09/06/零基础力扣学习/1.jpg"><h1 id="二、探索卡片"><a href="#二、探索卡片" class="headerlink" title="二、探索卡片"></a>二、探索卡片</h1><p>&emsp;&emsp;对于零基础的同学来说，不建议一开始就从题库页开始按顺序刷题。在力扣的<strong>探索页面</strong>有十分丰富的算法和数据结构主题卡片，从探索卡片开始学习能帮助你快速入门。每个卡片都覆盖了详细的知识点介绍，概念讲解，结构特点，代码实现，例题及答题套路。</p><p>&emsp;&emsp;按照正确的顺序来刷探索卡片，由浅入深，逐层打好算法根基。</p><p>!<img src="/2020/09/06/零基础力扣学习/2.jpg"></p><h1 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h1><p>&emsp;&emsp;按着上面的探索卡片学习；有了一定的算法和数据结构基础以后，这时你就可以选择刷面试题、或者题库了。</p><p>&emsp;&emsp;要准备面试的话，多写写面试题；面试题可以选最近时期的「名企高频面试题」、「剑指 Offer」等。如果已经在准备面试冲刺的阶段，这时候不妨多刷两遍「剑指 Offer」题库。</p><hr><p>&emsp;&emsp;当然也可以养生刷刷题库；根据题库页的标签分类进行专项刷题也是一个非常不错的选择。</p><img src="/2020/09/06/零基础力扣学习/3.jpg"><h1 id="四、刷题技巧"><a href="#四、刷题技巧" class="headerlink" title="四、刷题技巧"></a>四、刷题技巧</h1><p>&emsp;&emsp;当我们开始刷一类算法题前，如果对此算法的概念还不太熟悉，花费 5 分钟左右的时间了解其概念是很有必要的。在力扣题库页的 <strong>标签分类</strong> 中，点击对应的标签即可查看算法概念。</p><p>&emsp;&emsp;在足够多的准备工作后，我们就可以开始找一道简单～中等的题目小试牛刀了。有的同学会想：直接从困难题目开始练习，练会了困难题目，再去看简单题和中等题岂不是轻而易举？事实上我们不建议初学者直接练习困难题目。<strong>因为困难题目往往不够典型，困难题总是糅合了多种算法，难点在于对多种算法的综合应用，不适合在学习阶段用来专攻某一类算法。</strong></p><hr><p>&emsp;&emsp;下面举一个具体的例子，比如我们计划本周刷深度优先搜索的题目。先点击题库页「深度优先搜索」标签，查看其概念：</p><img src="/2020/09/06/零基础力扣学习/4.jpg"><p>&emsp;&emsp;从概念中我们知道，深度优先搜索，简称 DFS，主要用于遍历或搜索树或图。核心是沿着树的深度遍历树的节点，以深度优先的方式来遍历一棵树，直到找到需要搜索的节点或是遍历结束。</p><p>这不难理解，了解完概念，我们的脑中就对此算法有了一个粗略地认识：</p><ul><li>想象我们正站在一棵大树前，我们想要浏览这棵树的整个结构。</li><li>于是我们选择从大树的根出发，往树枝处浏览；</li><li>遇到树木分叉的地方，就随机选择一个树枝开始浏览；</li><li>浏览完后，回到上一个分叉的地方，选择另一个树枝继续浏览，直到所有的树枝都浏览完成。</li></ul><p>&emsp;&emsp;事实上，深度优先搜索和树形结构经常成双成对出现，二者总是密不可分。有了一个粗略的认识后，我们应该立即选择一道简单的题目开始练习：</p><img src="/2020/09/06/零基础力扣学习/5.jpg"><p>看到题目，我们的第一想法可能是以根节点为中心，左边的最长路径加上右边的最长路径应该就是答案。如题目示例中的树：</p><img src="/2020/09/06/零基础力扣学习/6.jpg"><p>根节点左边的最长路径为 2，右边的最长路径为 1，所以和为 3。</p><p>看起来没有错，我们再考虑一些特殊情况，有没有可能最长路径不经过根节点呢？不妨画个草图看一下：</p><img src="/2020/09/06/零基础力扣学习/7.jpg"><p>对于这样一棵树，根节点没有右子树，所以根节点右边的最长路径为 0，而左边的最长路径是 3，所以这样算起来直径为 3。但我们发现以2做为根节点的子树直径为 4，大于我们当前算法算出的直径！显然我们之前的思路是错误的，根节点其实不一定经过根节点，子节点可能存在更长的直径。我们不得不选择另一种思路。</p><p>如果此时冥思苦想，仍然没有思路的话，我们可以点开题解区抄一下别人的解题思路。先依着葫芦画瓢，等学会了再自己创造。</p><p>我们看到本题题解区有力扣官方发布的题解：</p><img src="/2020/09/06/零基础力扣学习/8.jpg"><p>&emsp;&emsp;看完题解我们已经有了具体的解题思路。此时切记不要眼高手低，不要觉得看懂了就是会了，一定要亲自将代码敲一遍，有过刷题经验的人都知道，看别人解题和自己亲自上手是完全不一样的感觉。经常是脑子和眼睛在说：我会了。而手在说：不，你不会！</p><p>仿照着官方题解，我们写出本题的 kotlin 解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">var ans = 0</span><br><span class="line">fun diameterOfBinaryTree(root: TreeNode?): Int &#123;</span><br><span class="line">        ans = 1</span><br><span class="line">        depth(root)</span><br><span class="line">return ans - 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fun depth(node: TreeNode?): Int &#123;</span><br><span class="line">if (node == null) return 0 // 访问到空节点了，返回0</span><br><span class="line">val L = depth(node.left) // 左儿子为根的子树的深度</span><br><span class="line">val R = depth(node.right) // 右儿子为根的子树的深度</span><br><span class="line">        ans = Math.max(ans, L + R + 1) // 计算d_node即L+R+1 并更新ans</span><br><span class="line">return Math.max(L, R) + 1 // 返回该节点为根的子树的深度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一道非常典型的 DFS 算法题，刷完之后我们应该反复思索，做出总结：DFS 的核心是依次尝试，运用的主要手段是递归函数。</p><p>然后我们马上再找一道近似的题，继续练习本类算法，比如：</p><img src="/2020/09/06/零基础力扣学习/9.jpg"><p>&emsp;&emsp;这道题与上道题非常类似，它也是非常典型的 DFS 题，因为它没有掺杂多类算法，实际难度算不上困难。这一次我们争取不查看题解，先将上题的模板拷贝过来，加以修改写出解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">var max = Int.MIN_VALUE</span><br><span class="line"></span><br><span class="line">fun maxPathSum(root: TreeNode?): Int &#123;</span><br><span class="line">        maxDeep(root)</span><br><span class="line">return max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fun maxDeep(node: TreeNode?): Int &#123;</span><br><span class="line">if (node == null) return 0</span><br><span class="line">val L = Math.max(maxDeep(node.left), 0)</span><br><span class="line">val R = Math.max(maxDeep(node.right), 0)</span><br><span class="line">        max = Math.max(max, node.`val` + L + R)</span><br><span class="line">return node.`val` + Math.max(L, R)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时仍然不能手打出一道完整的典型 DFS 题目，就继续反复练习，坚持这个过程，直至自己完全掌握此类题目。</p><p>总而言之，算法学习技巧可总结为四个步骤：一看二抄三改四写。</p><ul><li>一看：先查看基本概念，知道这类算法是什么。</li><li>二抄：照着别人的解题思路，将代码完整敲一遍，理解其思路。学习算法切忌自己造轮子，绝大多数问题都早已经有了完善的解决方案。</li><li>三改：拷贝自己以前敲的模板代码，加以修改，反复巩固。</li><li>四写：看答案与改答案 AC 的题不能算是真的会了，必须自己能手打出完整的代码才是真正会了。</li></ul><h1 id="五、时间规划"><a href="#五、时间规划" class="headerlink" title="五、时间规划"></a>五、时间规划</h1><p>&emsp;&emsp;梳理完算法学习的先后顺序和刷题技巧，一份可执行的时间计划是非常重要的，大家可以根据自己的学习进度安排，下面列出一些计划的要点。</p><h2 id="5-1-确定学习方式"><a href="#5-1-确定学习方式" class="headerlink" title="5.1 确定学习方式"></a>5.1 确定学习方式</h2><p>&emsp;&emsp;有的同学基础还比较薄弱，就需要花一定的时间梳理知识点，可以通过探索卡片或者看书学习，在刷题前至少保证一周左右的时间充分梳理知识点，而基础比较扎实的同学可以适当缩短梳理知识点的时间，或者直接从题目开始刷。</p><h2 id="5-2-计划刷题总数量"><a href="#5-2-计划刷题总数量" class="headerlink" title="5.2 计划刷题总数量"></a>5.2 计划刷题总数量</h2><p>&emsp;&emsp;一般来说，刷 150 - 200 题就能比较充分地应对技术面试了。同学们可以根据时间按照实际情况调整。在这个基础上可以预估每天要花多少时间刷题，刷多少题。</p><h2 id="5-3-预留面试前复习时间"><a href="#5-3-预留面试前复习时间" class="headerlink" title="5.3 预留面试前复习时间"></a>5.3 预留面试前复习时间</h2><p>&emsp;&emsp;复习是刷题过程中非常重要的一个环节，刷了一定数量的题目后，可以准备一周的时间系统回顾错题和难题，避免出现面试时遇到做过的题仍然回答不上来的情况。</p><h2 id="5-4-安排实战演练和冲刺时间"><a href="#5-4-安排实战演练和冲刺时间" class="headerlink" title="5.4 安排实战演练和冲刺时间"></a>5.4 安排实战演练和冲刺时间</h2><p>&emsp;&emsp;在正式开始面试前的一到两周，你就需要进行大量实战演练和冲刺刷题了，在这个阶段反复练习 70+ 道2020 年互联网名企高频面试题探索卡片，保持刷题的手感。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇内容基本来源于力扣官方在知乎给萌新学习力扣的建议。&lt;br&gt;&amp;emsp;&amp;emsp;在开始刷题前，只需要你至少掌握一门编程语言，即使你从未刷过算法题，从现在开始好好利用这两个月的时间制定合适的学习计划，也可以给自己的算法水平带来质的提升。&lt;/p&gt;
&lt;p&gt;首先，为什么搞嵌入式底层开发还是要学算法和数据结构？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;虽然在搞嵌入式底层开发大多数数据结构用到的不多，学点常用的基本都能解决问题。例如，递归往往可以用于求解，其本质是从结果倒回输入的求解，常用于算法题，数据检索等；但不常见于嵌入式开发流程的场景应用，因为嵌入式往往是要从输入得到结果。但是我觉得还是有必要深入学习一下，这个不仅仅能够提升你代码的技术水平，还能提高你码代码的视界。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>最小二乘法</title>
    <link href="http://shatang.github.io/2020/09/05/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"/>
    <id>http://shatang.github.io/2020/09/05/最小二乘法/</id>
    <published>2020-09-05T10:59:43.000Z</published>
    <updated>2020-09-05T11:12:03.362Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 平常写嵌入式程序时常见的一种算法：最小二乘法。</p><a id="more"></a><h1 id="一、最小二乘法求回归直线方程的推导过程"><a href="#一、最小二乘法求回归直线方程的推导过程" class="headerlink" title="一、最小二乘法求回归直线方程的推导过程"></a>一、最小二乘法求回归直线方程的推导过程</h1><p>&emsp;&emsp;第一章节内容主要来自这位博主：<a href="http://blog.csdn.net/marsjohn/article/details/54911788" target="_blank" rel="noopener">Neo_T</a>。</p><img src="/2020/09/05/最小二乘法/1.png"><p>&emsp;&emsp;实际上我们希望这n个离差构成的总离差越小越好，只有如此才能使直线最贴近已知点。换句话说，我们求回归直线方程的过程其实就是求离差最小值的过程。</p><p>&emsp;&emsp;一个很自然的想法是把各个离差加起来作为总离差。可是，由于离差有正有负，直接相加会互相抵消，如此就无法反映这些数据的贴近程度，即这个总离差不能用n个离差之和来表示，见下图：</p><img src="/2020/09/05/最小二乘法/2.jpg"><p>一般做法是我们用离差的平方和，即：</p><img src="/2020/09/05/最小二乘法/3.jpg"><p>&emsp;&emsp;作为总离差，并使之达到最小。这样回归直线就是所有直线中Q取最小值的那一条。由于平方又叫二乘方，所以这种使“离差平方和为最小”的方法，叫做<strong>最小二乘法</strong>。<br>用最小二乘法求回归直线方程中的a、b的公式如下：</p><img src="/2020/09/05/最小二乘法/4.jpg"><img src="/2020/09/05/最小二乘法/5.png"><p>&emsp;&emsp;当然，我们肯定不能满足于直接得到公式，我们只有理解这个公式怎么来的才能记住它，用好它，因此给出上面两个公式的推导过程更加重要。在给出上述公式的推导过程之前，我们先给出推导过程中用到的两个关键变形公式的推导过程。首先是第一个公式：</p><img src="/2020/09/05/最小二乘法/6.jpg"><p>接着是第二个公式：</p><img src="/2020/09/05/最小二乘法/7.jpg"><p>&emsp;&emsp;基本变形公式准备完毕，我们可以开始最小二乘法求回归直线方程公式的推导了：</p><img src="/2020/09/05/最小二乘法/8.jpg"><img src="/2020/09/05/最小二乘法/9.jpg"><p>至此，公式变形部分结束，从最终式子我们可以看到后两项</p><img src="/2020/09/05/最小二乘法/10.jpg"><p>与a、b无关，属于常数项，我们只需</p><img src="/2020/09/05/最小二乘法/11.jpg"><p>即可得到最小的Q值，因此：</p><img src="/2020/09/05/最小二乘法/12.jpg"><p>&emsp;&emsp;至此，公式推导完毕。</p><h1 id="二、最小二乘法——C实现"><a href="#二、最小二乘法——C实现" class="headerlink" title="二、最小二乘法——C实现"></a>二、最小二乘法——C实现</h1><img src="/2020/09/05/最小二乘法/13.png" title="没想到这个hexo博客的Markdown语法还不支持数学公式= ="><h2 id="2-1-算法代码"><a href="#2-1-算法代码" class="headerlink" title="2.1 算法代码"></a>2.1 算法代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//功能 : 最小二乘法直线拟合 y = a + b*x， 计算系数a 和 b</span></span><br><span class="line"><span class="comment">//参数 : x -- 辐照度的数组</span></span><br><span class="line"><span class="comment">//       y -- 功率的数组</span></span><br><span class="line"><span class="comment">//       num 是数组包含的元素个数，x[]和y[]的元素个数必须相等</span></span><br><span class="line"><span class="comment">//       a,b 都是返回值</span></span><br><span class="line"><span class="comment">//返回 : 拟合计算成功返回true, 拟合计算失败返回false</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="function">voud <span class="title">LeastSquareLinearFit</span><span class="params">(<span class="keyword">float</span> x[], <span class="keyword">float</span> y[], <span class="keyword">const</span> <span class="keyword">int</span> num, <span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> sum_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> sum_y  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> sum_x  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> sum_xy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_x2 += x[i]*x[i];</span><br><span class="line">        sum_y += y[i];</span><br><span class="line">        sum_x += x[i];</span><br><span class="line">        sum_xy += x[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a = (<span class="keyword">double</span>)(sum_x2*sum_y - sum_x*sum_xy)/(<span class="keyword">double</span>)(num*sum_x2-sum_x*sum_x);</span><br><span class="line">    b = (<span class="keyword">double</span>)(num*sum_xy - sum_x*sum_y)/(<span class="keyword">double</span>)(num*sum_x2 - sum_x*sum_x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-常见用法"><a href="#2-2-常见用法" class="headerlink" title="2.2 常见用法"></a>2.2 常见用法</h2><p>&emsp;&emsp;最小二乘法的常见用法，就有 直线拟合 &amp; 曲线拟合。由于这里是讲解 直线拟合，因此只讲 直线拟合 的应用场合。</p><p>&emsp;&emsp;直线拟合 最常见、最基础的用法，实际就是求 K ，在实际的应用场合就是对应的变化率，利用 K 值大小来进行一些状态判断。例如重量的斜率K，就是重量的变化量，实际上就是流量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 平常写嵌入式程序时常见的一种算法：最小二乘法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式(Stm32)程序跑飞</title>
    <link href="http://shatang.github.io/2020/08/22/%E5%B5%8C%E5%85%A5%E5%BC%8F-Stm32-%E7%A8%8B%E5%BA%8F%E8%B7%91%E9%A3%9E/"/>
    <id>http://shatang.github.io/2020/08/22/嵌入式-Stm32-程序跑飞/</id>
    <published>2020-08-22T02:44:33.000Z</published>
    <updated>2020-08-22T03:05:04.688Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;搞嵌入式开发，有时候总会因为自己的粗心，或者是硬件本身的缺陷导致的程序跑飞；要找到程序跑飞的原因，排查方法尤为重要，这里介绍一些经验。</p><a id="more"></a><h1 id="一、常见的-程序跑飞"><a href="#一、常见的-程序跑飞" class="headerlink" title="一、常见的 程序跑飞"></a>一、常见的 程序跑飞</h1><p>&emsp;&emsp;分享常见的三种死机情况：</p><ol><li>无操作系统程序死机<ol><li>常见的就是内存溢出(数组下标、申请内存的长度)</li><li><strong>语法问题，导致死循环、或者条件异常直接跳转出去</strong>(常见低级错误)</li></ol></li><li>带操作系统程序死机<ol><li>临界区代码没有进行保护，导致堆栈溢出；常见于底层驱动中断</li><li>任务的堆栈(内存)设置太小；出现程序死机时，<strong>可以尝试扩大任务的堆栈大小，若无死机情况了再从大往小了减。</strong></li></ol></li><li>emwin的不当操作导致死机<ol><li>emwin由于是不开源的，所以有时候不当的操作，比如没有创建窗口时就删除该窗口，就会导致死机。</li><li>所以在运用emwin的时候一定要严格遵循他要求的顺序，如果可以的话多加一下判断再删除界面。</li></ol></li></ol><h1 id="二、进入HardFault-Handler"><a href="#二、进入HardFault-Handler" class="headerlink" title="二、进入HardFault_Handler"></a>二、进入HardFault_Handler</h1><p>&emsp;&emsp;STM32出现HardFault_Handler故障的根本原因有两个方面：</p><ol><li>内存溢出或者访问越界。</li><li>堆栈溢出。(增加堆栈的大小，大多数是因为中断嵌套)</li></ol><p>&emsp;&emsp;但是能造成故障的方法有很多种：例如，数组越界操作、中断处理错误、中断嵌套过多等等。</p><p>这里只介绍两种简单排查的方法。</p><h2 id="2-1-方法1"><a href="#2-1-方法1" class="headerlink" title="2.1 方法1"></a>2.1 方法1</h2><p>&emsp;&emsp;默认的HardFault_Handler处理方法不是 <code>B .</code>(汇编) or <code>while(1)</code>(C语言) 这样的死循环么？楼主将它改成 <code>BX LR</code>直接返回的形式。</p><p>&emsp;&emsp;然后在这条语句打个断点，一旦在断点中停下来，说明出错了，然后再<code>Step</code>两下，就可以返回到出错的位置的下一条语句那儿。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function"><span class="keyword">asm</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    BX lr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HardFault_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">/* Go to infinite loop when Hard Fault exception occurs */</span>   </span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/08/22/嵌入式-Stm32-程序跑飞/1.jpg"><h2 id="2-2-方法2"><a href="#2-2-方法2" class="headerlink" title="2.2 方法2"></a>2.2 方法2</h2><p>&emsp;&emsp;在硬件中断函数HardFault_Handler里的while(1)处打调试断点，<strong><font color="red">程序执行到断点处时点击“STOP”停止仿真</font></strong>。</p><img src="/2020/08/22/嵌入式-Stm32-程序跑飞/2.jpg"><p>&emsp;&emsp;在Keil菜单栏点击“View”——“Call Stack Window”弹出“Call Stack + Locals”对话框。然后在对话框中右键选择“Show Caller Code”，就会跳转到出错之前的函数处；仔细查看这部分函数被调用或者数组内存使用情况。</p><img src="/2020/08/22/嵌入式-Stm32-程序跑飞/3.jpg"><h1 id="三、上操作系统-ucOS-程序跑飞"><a href="#三、上操作系统-ucOS-程序跑飞" class="headerlink" title="三、上操作系统(ucOS)程序跑飞"></a>三、上操作系统(ucOS)程序跑飞</h1><p>&emsp;&emsp;频繁操作文件，容易出现死机，操作文件时，最好关闭任务；操作完成后，再打开任务； <strong>uC/OS-II的OSSchedLock()和OSSchedUnlock()函数应成对出现</strong>，允许应用程序锁定当前任务不被其它任务抢占。使用时应当注意的是：当你调用了OSSchedLock()之后，而在调用OSSchedUnlock()之前，千万不要再调用诸如OSFlagPend()、OSMboxPend()、OSMutexPend()、OSQPend()、OSSemPend()之类的事件等待函数！而且应当确保OSSchedLock()和OSSchedUnlock()函数成对出现，特别是在有些分支条件语句中，要考虑各种分支情况，不要有遗漏！</p><hr><p>&emsp;&emsp;<strong>任务优先级</strong>。每个任务都必须符合事件驱动的编程模型，即uC/OS-II的应用程序都必须是“事件驱动的编程模型”。一个任务首先等待一个事件的发生，事件可以是系统中断发出的，也可以是其它任务发出的，又可以是任务自身等待的时间片。当一个事件发生了，任务再作相应处理，处理结束后又开始等待下一个事件的发生。如此周而复始的任务处理模型就是“事件驱动的编程模型”。事件驱动模型也涵盖了中断驱动模型，uC/OS-II事件归根结底来自三个方面：</p><ul><li>中断服务函数发送的事件</li><li>系统延时时间到所引起的</li><li>其它任务发送的事件。<ul><li>其中“中断服务函数发送的事件”就是指每当有硬件中断发生，那么中断服务程序就会以事件的形式告诉任务，而等待该事件的最高优先级任务就会马上得以运行；“系统延时时间到所引起的”事件其实也是硬件中断导致的，那就是系统定时器中断。而“其它任务发送的事件”则是由任务代码自身决定的，这是完全的“软事件”。不管“软事件”还是“硬事件”，反正引起uC/OS-II任务切换的原因就是“事件”，所以用户编写应用代码的时候一定要体现出“事件驱动的编程模型”。任务的优先级也一定要分配得当；</li></ul></li><li>查看堆栈是否满；</li></ul><hr><p>&emsp;&emsp;<strong>不可重入函数</strong>。一些C语言函数，用到uCOS-II操作系统中，有时也可能出现问题，例如：gotoxy（）；printf（）。</p><hr><p>&emsp;&emsp;OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()也可以用来保护应用程序中的临界代码；然而要特别小心，如果再调用一些如 OSTimeDel() 之类的功能函数之前关中断，应用程序将会死机；原因是任务被挂起一段时间，直到挂起时间到，但由于中断关掉了，时钟节拍中断一直得不到服务，显然所有的挂起类调用都有这样的问题，所以要特别小心。</p><p>&emsp;&emsp;需要一并提醒的是：当调用开关中断函数 OS_ENTER_CRITICAL() 和 OS_EXIT_CRITICAL() 时也要确保成对出现，否则系统将可能崩溃！不过，在 OS_ENTER_CRITICAL() 和 OS_EXIT_CRITICAL() 函数之间调用 OSFlagPend()、 OSMboxPend()、 OSMutexPend()、 OSQPend()、 OSSemPend()之类的事件等待函数是允许的。</p><hr><p>&emsp;&emsp;官方ucOS-III 不支持stm32f4x系列的FPU功能(ucOS-III代码没考虑到该功能)；一旦使能FPU，程序会进入到HardFault_Handler，或者出现打印浮点数异常(打印就死机)的现象。修改进行对源码的一些修改才能使用！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;搞嵌入式开发，有时候总会因为自己的粗心，或者是硬件本身的缺陷导致的程序跑飞；要找到程序跑飞的原因，排查方法尤为重要，这里介绍一些经验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Stm32" scheme="http://shatang.github.io/tags/Stm32/"/>
    
      <category term="程序跑飞" scheme="http://shatang.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%B7%91%E9%A3%9E/"/>
    
      <category term="内存溢出" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
      <category term="HardFault" scheme="http://shatang.github.io/tags/HardFault/"/>
    
  </entry>
  
  <entry>
    <title>Stm32的内存管理(Code,RO-data,RW-data,ZI-data)</title>
    <link href="http://shatang.github.io/2020/08/22/Stm32%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Code-RO-data-RW-data-ZI-data/"/>
    <id>http://shatang.github.io/2020/08/22/Stm32的内存管理-Code-RO-data-RW-data-ZI-data/</id>
    <published>2020-08-22T01:35:33.000Z</published>
    <updated>2020-09-05T03:48:14.469Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;单纯从C语言角度来讲内存管理，有点宏观；这里介绍具体嵌入式的内存分配管理。</p><a id="more"></a><h1 id="一、内存分配"><a href="#一、内存分配" class="headerlink" title="一、内存分配"></a>一、内存分配</h1><p>&emsp;&emsp;对于一个C语言程序而言，内存空间主要由五个部分组成：代码段(.text)、数据段(.data)、静态区(.BSS)、堆和栈组成。</p><ul><li>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量和静态变量（这里注意一个问题：一般的书上都会说全局变量和静态变量是会自动初始化的，那么哪来的未初始化的变量呢？变量的初始化可以分为显示初始化和隐式初始化，全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化，那就是不管什么类型都初始化为0，这种没有显示初始化的就是我们这里所说的未初始化。既然都是0那么就没必要把每个0都存储起来，从而节省磁盘空间，这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据，只是简单的维护开始和结束的地址，即总大小，以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在，即不占用磁盘空间而只在运行的时候占用内存空间，所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。</li><li>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配，可以分为只读数据段和读写数据段。字符串常量等，但一般都是放在只读数据段中。</li><li>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等，但一般都是放在只读数据段中。</li><li>栈区：由系统自动分配，栈区的分配运算内置于处理器的指令集，当函数执行结束时由系统自动释放。存放局部变量。栈的缺点是：容量有限，当相应的区间被释放时，局部变量不可再使用。查询栈容量的命令：ulimits -s。栈是一块连续的区域，向高地址扩展，栈顶和容量是事先约定好的。</li><li>堆区：在程序的执行过程中才能分配，由程序员决定，编译器在编译时无法为他们分配空间，只有在程序运行时分配，所以被称为动态分配。堆是不连续的区域，向高地址扩展。由于系统用链表来描述空闲的地址空间，链表的遍历是由地地址向高地址的，故堆区是不连续的动态的存储空间。</li></ul><hr><p>&emsp;&emsp;更多具体的C语言基础内存分配知识，可以看这篇博文：<a href="https://shatang.github.io/2020/03/15/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/">内存分配方式</a> 。</p><h1 id="二、Stm32的内存管理"><a href="#二、Stm32的内存管理" class="headerlink" title="二、Stm32的内存管理"></a>二、Stm32的内存管理</h1><p>编写一个空工程，BUILD后，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code=<span class="number">340</span> RO-data=<span class="number">252</span> RW-data=<span class="number">0</span> ZI-data=<span class="number">1632</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序已用了1600多的RAM，要是在51单片机上，会心疼死了，这1600多的RAM跑哪儿去了？？？</p><p>分析完map，你会发现是堆和栈占用的。在<code>startup_stm32f10x_md.s</code>文件中，它的前面几行就有以下定义，这下该明白了吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size  EQU     <span class="number">0x00000400</span></span><br><span class="line">Heap_Size   EQU     <span class="number">0x00000200</span></span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;一般 MCU 包含的存储空间有：片内 Flash 与片内 RAM，RAM 相当于内存，Flash 相当于硬盘。</p><p>编译器会将一个程序分为好几个部分，分别存储在 MCU 不同的存储区。Keil 工程在编译完之后，会有相应的程序所占用的空间提示信息，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code=<span class="number">12266</span> RO-data=<span class="number">790</span> RW-data=<span class="number">232</span> ZI-data=<span class="number">8096</span></span><br></pre></td></tr></table></figure><p>上面提到的 Program Size 包含以下几个部分：</p><ul><li>Code：代码段，存放程序的代码部分；</li><li>RO-data：只读数据段，存放程序中定义的常量；</li><li>RW-data：读写数据段，存放初始化为非 0 值的全局变量；</li><li>ZI-data：0 数据段，存放未初始化的全局变量及初始化为 0 的全局变量；</li></ul><p>编译完工程会生成一个. map 的文件，该文件说明了各个函数占用的尺寸和地址，在文件的最后几行也说明了上面几个字段的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Total RO <span class="title">Size</span> <span class="params">(Code + RO Data)</span> 13056 <span class="params">( <span class="number">12.75</span>kB)</span></span></span><br><span class="line"><span class="function">Total RW <span class="title">Size</span> <span class="params">(RW Data + ZI Data)</span> 8328 <span class="params">( <span class="number">8.13</span>kB)</span></span></span><br><span class="line"><span class="function">Total ROM <span class="title">Size</span> <span class="params">(Code + RO Data + RW Data)</span> 13288 <span class="params">( <span class="number">12.98</span>kB)</span></span></span><br></pre></td></tr></table></figure><ul><li>RO Size = (Code + RO-data)：表示程序占用 Flash 空间的大小；</li><li>RW Size = (RW-data + ZI-data)：表示运行时占用的 RAM 的大小；</li><li>ROM Size = (Code + RO Data + RW Data)：表示烧写程序所占用的 Flash 空间的大小。</li></ul><hr><p>&emsp;&emsp;这个是MDK编译之后能够得到的每个段的大小，也就能得到占用相应的FLASH和RAM的大小。</p><ul><li>Flash = Code + RO Data + RW Data;</li><li>RAM = RW-data+ZI-data;</li></ul><p><strong><font color="red">Ps：</font></strong>堆和栈都存在RAM里，他两各分多少看函数需求，但是他两的总值不能超过单片机硬件的实际RAM尺寸！(可以外扩RAM)</p><h1 id="三、分散文件加载"><a href="#三、分散文件加载" class="headerlink" title="三、分散文件加载"></a>三、分散文件加载</h1><p>&emsp;&emsp;<strong><font color="red">内存分配在嵌入式开发，有另外一个名字：分散文件加载。</font></strong></p><p>该章节内容主要来自这位博主：<a href="https://blog.csdn.net/weixin_39118482/article/details/79849133" target="_blank" rel="noopener">Solaris_超</a>，想更了解分散文件加载的可以看这位博主链接文章。</p><h2 id="3-1-什么是分散加载"><a href="#3-1-什么是分散加载" class="headerlink" title="3.1 什么是分散加载"></a>3.1 什么是分散加载</h2><p>&emsp;&emsp;简单来说就是让编译器高速MCU内核哪里存的是代码、哪里存的是数据，去哪个特定的地址找到下一步需要运行的函数，就是高速编译器把每一个编译好的函数、数据放到具体的哪一个物理地址。</p><h2 id="3-2-分散加载常见应用场景"><a href="#3-2-分散加载常见应用场景" class="headerlink" title="3.2 分散加载常见应用场景"></a>3.2 分散加载常见应用场景</h2><ul><li>Bootloader &amp; 程序升级<ul><li>Bootloader的原理就简单来说在MCU的Flash里面同时摆放2个（或多个）不同工程的程序，一个Bootloader程序和一个用户程序，那么这就需要调整分散加载文件，以达成在一个Flash里面同时摆放两个不同程序的目的。</li><li>程序升级都是为了增加一个小功能或修复一个小BUG，不需要全部升级而是只升级一点点。当然要实现这个功能同样需要分散加载的配合，把可能会后续升级的部分函数或数据事先分配好空间，留好空间上的余量，这些都需要分散加载来完成。</li></ul></li><li>加速程序运行速度（如：对速度有较高要求的算法等、RTOS kernel）<ul><li>在SRAM中运行的程序要比在XIP Flash中执行要快，性能提升明显。</li></ul></li><li>访问扩展存储&amp;对存储区的划分<ul><li>如果要把外扩的存储用于运行代码/扩展RW数据段等用途，简单来说就是把片内地址映射到片外，需要按照寻址空间的方式来访问扩展存储的话，比如扩展Nor-Flash、扩展SDRAM、扩展SRAM等，那就需要分散加载配合。（只作存储数据的话，分散加载不是必要的！！！）</li></ul></li></ul><h2 id="3-3-分散加载的基本结构定义以及分散加载的目的"><a href="#3-3-分散加载的基本结构定义以及分散加载的目的" class="headerlink" title="3.3 分散加载的基本结构定义以及分散加载的目的"></a>3.3 分散加载的基本结构定义以及分散加载的目的</h2><ul><li>Code段：表示程序代码部分</li><li>RO-data段：程序定义的所有常量以及const类型数据</li><li>RW-data段：已经初始化的所有静态变量</li><li>ZI-data段：未初始化的静态变量</li></ul><hr><p>所以分散加载的根本目的就是：</p><ul><li>指引把RO-data数据段、RW数据段从片内程序存储区里面（一般是片内Flash），搬到片内程序运行区（一般是片内SRAM）;</li><li>在片内程序运行区（一般是片内SRAM）内分配ZI数据段运行需要的空间并把这段数据初始化为0；</li><li>初始化堆栈；</li><li>对于有些指定加载到程序运行区（一般是片内SRAM）的RO数据段，把他们加载到程序运行区（一般是片内SRAM）里面。</li></ul><p><strong><font color="red">Ps：</font></strong> 这个和使用的电脑运行操作系统或者软件原理类似，电脑就是把硬盘里面的操作系统加载到内存里面，然后CPU从内存里面取数据以及程序指令来运行的。</p><p><strong><font color="red">Ps：</font></strong> RW以及ZI数据段的初始化是在分散加载过程中完成的，也就是在__main中完成的，比如你定义一个全局变量，并给它赋值，只有在__main结束后你才能看到这个全局变量被赋值成功的，也就是说在__main之前，使用全局变量是行不通的。</p><hr><p>&emsp;&emsp;我们可以在编译链接完层的代码后，链接器的输出打印上看到这部分信息，如下图，就是一个Hello World工程的输出打印，其中链接器打印出了这几个段的大小（蓝色底纹部分）：</p><img src="/2020/08/22/Stm32的内存管理-Code-RO-data-RW-data-ZI-data/1.png" title="链接器打印信息"><p>如果大家想看更详细编译结果，可以双击工程名查看.map文件</p><img src="/2020/08/22/Stm32的内存管理-Code-RO-data-RW-data-ZI-data/2.png" title="map文件"><p>&emsp;&emsp;.map文件最后有关于编译结果的详细介绍，我是用的这个hello world工程中的所有被编译&amp;链接的文件都会在.map（链接器的工作报表）文件里面详细记述，每一个文件编译后产生的Code、RO-Data、RW、ZI的大小，以及加在一起的总大小，如下图：</p><img src="/2020/08/22/Stm32的内存管理-Code-RO-data-RW-data-ZI-data/3.png" title="内存分配大小"><p><strong><font color="red">Ps：</font></strong> 我们可以通过查看 .map 文件来规划Bootloader程序的存储空间的大小。</p><h1 id="四、嵌入式的内存分配"><a href="#四、嵌入式的内存分配" class="headerlink" title="四、嵌入式的内存分配"></a>四、嵌入式的内存分配</h1><ul><li><strong>内存管理</strong>：是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。内存管理的实现方法有很多种，他们其实最终都是要实现 2 个函数： malloc 和 free（<strong><font color="red">不可重入函数</font>，上操作系统注意调用，很危险</strong>）； malloc 函数用于内存申请， free 函数用于内存释放。</li><li><strong>内存碎片</strong>：通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。</li></ul><p>&emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用。</p><p>&emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做！一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的<code>malloc</code> 与<code>free</code>的使用容易造成内存碎片。没有MMU的管理，当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。</p><hr><p>嵌入式内存的分配方式，常见如STM32可以先在启动文件中设置heap的大小，再使用动态内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size     EQU    <span class="number">0x00000200</span>     <span class="comment">//也就是 512字节</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;嵌入式系统的堆栈，不管是用什么方法来得到内存，感觉他的方式都和编程中的堆差不多。目前我知道两种获得内存情况：</p><ol><li>用庞大的全局变量数组来圈住一块内存，然后将这个内存拿来进行内存管理和分配。这种情况下，堆栈占用的内存就是上面说的：如果没有初始化数组，或者数组的初始化值为0，堆栈就是占用的RAM的ZI-data部分；如果数组初始化值不为0，堆栈就占用的RAM的RW-data部分。这种方式的好处是容易从逻辑上知道数据的来由和去向。</li><li>就是把编译器没有用掉的RAM部分拿来做内存分配，也就是除掉RW-data+ZI-data+编译器堆+编译器栈后剩下的RAM内存中的一部分或者全部进行内存管理和分配。这样的情况下就只需要知道内存剩下部分的首地址和内存的尾地址，然后要用多少内存，就用首地址开始挖，做一个链表，把内存获取和释放相关信息链接起来，就能及时的对内存进行管理了。</li></ol><p>正点原子的方法即是上面的方法一，详情介绍可以看这篇文章：<a href></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;单纯从C语言角度来讲内存管理，有点宏观；这里介绍具体嵌入式的内存分配管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Stm32" scheme="http://shatang.github.io/tags/Stm32/"/>
    
      <category term="内存管理" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="分散文件加载" scheme="http://shatang.github.io/tags/%E5%88%86%E6%95%A3%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>M0的中断向量表重映射</title>
    <link href="http://shatang.github.io/2020/08/12/M0%E7%9A%84%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E9%87%8D%E6%98%A0%E5%B0%84/"/>
    <id>http://shatang.github.io/2020/08/12/M0的中断向量表重映射/</id>
    <published>2020-08-12T14:37:58.000Z</published>
    <updated>2020-08-22T01:25:57.689Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Stm32F030的Bootloader制作与其他ST芯片一致；但是Stm32F030的APP程序就有特殊变动：因为M0是不能设置重量向量表偏移量；本篇就讲M0的APP程序的中断向量表重映射，和还有一些会用到的冷知识，如编译工具链等。</p><a id="more"></a><h1 id="一、M0的中断向量表重映射"><a href="#一、M0的中断向量表重映射" class="headerlink" title="一、M0的中断向量表重映射"></a>一、M0的中断向量表重映射</h1><p>&emsp;&emsp;在STM32F103等cortex-m3/m4内核的单片机上可以通过设置中断向量表的偏移量，完成重映射中断向量表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Stm32f0系列MCU中断矢量表的定位跟STM32其它系列相比有点差异，即M0系列没有像其它M3/M4/M0+系列所具备的中断矢量表重定位寄存器，其中断矢量表不能借助矢量重定位寄存器简单修改实现。所以Stm32f0x IAP的过程会跟其它系列的STM32芯片的IAP动作有所不同。</p><hr><p>M0的中断向量表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp                   ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler                  ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                    ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler              ; Hard Fault Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     SVC_Handler                    ; SVCall Handler</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     PendSV_Handler                 ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler                ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler                 ; PVD through EXTI Line detect</span><br><span class="line">                DCD     RTC_IRQHandler                 ; RTC through EXTI Line</span><br><span class="line">                DCD     FLASH_IRQHandler               ; FLASH</span><br><span class="line">                DCD     RCC_IRQHandler                 ; RCC</span><br><span class="line">                DCD     EXTI0_1_IRQHandler             ; EXTI Line 0 and 1</span><br><span class="line">                DCD     EXTI2_3_IRQHandler             ; EXTI Line 2 and 3</span><br><span class="line">                DCD     EXTI4_15_IRQHandler            ; EXTI Line 4 to 15</span><br><span class="line">                DCD     TS_IRQHandler                  ; TS</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler       ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_3_IRQHandler     ; DMA1 Channel 2 and Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_5_IRQHandler     ; DMA1 Channel 4 and Channel 5</span><br><span class="line">                DCD     ADC1_COMP_IRQHandler           ; ADC1, COMP1 and COMP2 </span><br><span class="line">                DCD     TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler             ; TIM1 Capture Compare</span><br><span class="line">                DCD     TIM2_IRQHandler                ; TIM2</span><br><span class="line">                DCD     TIM3_IRQHandler                ; TIM3</span><br><span class="line">                DCD     TIM6_DAC_IRQHandler            ; TIM6 and DAC</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     TIM14_IRQHandler               ; TIM14</span><br><span class="line">                DCD     TIM15_IRQHandler               ; TIM15</span><br><span class="line">                DCD     TIM16_IRQHandler               ; TIM16</span><br><span class="line">                DCD     TIM17_IRQHandler               ; TIM17</span><br><span class="line">                DCD     I2C1_IRQHandler                ; I2C1</span><br><span class="line">                DCD     I2C2_IRQHandler                ; I2C2</span><br><span class="line">                DCD     SPI1_IRQHandler                ; SPI1</span><br><span class="line">                DCD     SPI2_IRQHandler                ; SPI2</span><br><span class="line">                DCD     USART1_IRQHandler              ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler              ; USART2</span><br><span class="line">                DCD     0                              ; Reserved</span><br><span class="line">                DCD     CEC_IRQHandler                 ; CEC</span><br><span class="line">                DCD     0                              ; Reserved</span><br></pre></td></tr></table></figure><p>M0的中断向量表重映射方法如下：</p><ol><li>将APP的中断向量表拷贝到SRAM里面去。M0的中断向量表由48个有序字(32bit)组成，把它们从flash区0x08004000开始的中断向量表拷贝到0x2000 0000的SRAM区。</li><li>做存储地址的映射，即把SRAM映射到代码执行区的地址0X00处。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASH_BOOTLOADER_SIZE       (uint32_t)(0x4000)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APPLICATION_ADDRESS         (uint32_t)(0x08000000+FLASH_BOOTLOADER_SIZE)  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>   (defined ( __CC_ARM ))</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> VectorTable[<span class="number">48</span>] __attribute__((at(<span class="number">0x20000000</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (defined (__ICCARM__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> location = 0x20000000</span></span><br><span class="line">    __no_init __IO <span class="keyword">uint32_t</span> VectorTable[<span class="number">48</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined   (  __GNUC__  )</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> VectorTable[<span class="number">48</span>] __attribute__((section(<span class="string">".RAMVectorTable"</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined ( __TASKING__ )</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> VectorTable[<span class="number">48</span>] __at(<span class="number">0x20000000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">VectorRemap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拷贝中断向量表</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       VectorTable[i] = *(__IO <span class="keyword">uint32_t</span>*)(APPLICATION_ADDRESS + (i&lt;&lt;<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Enable the SYSCFG peripheral clock*/</span></span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);</span><br><span class="line">    <span class="comment">/* Remap SRAM at 0x00000000 */</span></span><br><span class="line">    SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SRAM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VectorRemap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按照平常程序运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上述操作步骤后，当APP里发生中断时，内核就从地址0x00处的向量表取相应中断的入口地址，即相当于从0x2000 0000处的向量表取中断入口地址，当然也相当于从0x08003000处的向量表取中断入口地址，然后去执行相应中断程序。</p><h1 id="二、编译工具链"><a href="#二、编译工具链" class="headerlink" title="二、编译工具链"></a>二、编译工具链</h1><p>&emsp;&emsp;STM32中ARM系列编译工具链的编译宏选择（__CC_ARM、__ICCARM__、__GNUC__、__TASKING__）。这里简单介绍一下。</p><ol><li><p>在 core_cm3.h 文件中，有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( __CC_ARM   )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for ARM Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         __inline     <span class="comment">/*!&lt; inline keyword for ARM Compiler     */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined ( __ICCARM__ )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM           __asm         <span class="comment">/*!&lt; asm keyword for IAR Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE        inline        <span class="comment">/*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined   (  __GNUC__  )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for GNU Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         inline       <span class="comment">/*!&lt; inline keyword for GNU Compiler     */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined   (  __TASKING__  )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for TASKING Compiler    */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         inline       <span class="comment">/*!&lt; inline keyword for TASKING Compiler */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>这几个宏都是什么含义呢？分别对应什么平台呢？</p></li></ol><ul><li>__CC_ARM对应的平台是：<strong><code><font color="red">ARM RealView</font></code></strong><ul><li>RealView，是一套包含编译、调试和模拟的开发工具，需结合开发环境如uvision、eclipse或者CodeWarrior，形成集成开发环境来使用。</li></ul></li><li>__ICCARM__对应的平台是：<strong><code><font color="red">IAR EWARM</font></code></strong><ul><li>Embedded Workbench for ARM 是IARSystems 公司为ARM 微处理器开发的一个集成开发环境(下面简称IAR EWARM)。比较其他的ARM 开发环境，IAR EWARM 具有入门容易、使用方便和代码紧凑等特点</li></ul></li><li>__GNUC__对应的平台是：<strong><code><font color="red">GNU Compiler Collection</font></code></strong><ul><li>GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。</li></ul></li><li>__TASKING__对应的平台是：<strong><code><font color="red">Altinum Designer</font></code></strong><ul><li>Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。  </li></ul></li></ul><h1 id="三、-attribute-at-绝对定位"><a href="#三、-attribute-at-绝对定位" class="headerlink" title="三、__attribute__ ((at()) 绝对定位"></a>三、<code>__attribute__ ((at())</code> 绝对定位</h1><ul><li><code>__attribute__</code> ，这个是用来指定变量或结构位域的特殊属性,该关键字后的双括弧中的内容是属性说明。 </li><li><code>at</code> ，该关键字可以用来设置变量的绝对地址,也就是你可以通过这个关键字,指定某个变量处于内存里面的某个给定的地址. </li></ul><hr><p>&emsp;&emsp;<code>__attribute__( at(绝对地址) )</code>  的用法分两种，一个是绝对定位到Flash，另一种是绝对定位到RAM。</p><ol><li><p>定位到flash中，一般用于固化的信息，如出厂设置的参数，上位机配置的参数，ID卡的ID号，flash标记等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u16 gFlashDefValue[<span class="number">512</span>] __attribute__((at(<span class="number">0x0800F000</span>))) = &#123;<span class="number">0x1111</span>,<span class="number">0x1111</span>,<span class="number">0x1111</span>,<span class="number">0x0111</span>,<span class="number">0x0111</span>,<span class="number">0x0111</span>&#125;;<span class="comment">//定位在flash中,其他flash补充为00</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> u16 <span class="title">gflashdata__attribute__</span><span class="params">((at(<span class="number">0x0800F000</span>)))</span> </span>= <span class="number">0xFFFF</span>;</span><br></pre></td></tr></table></figure></li><li><p>定位到RAM中，一般用于数据量比较大的缓存，如串口的接收缓存，再就是某个位置的特定变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8 USART2_RX_BUF[USART2_REC_LEN] __attribute__ ((at(<span class="number">0X20001000</span>)));<span class="comment">//接收缓冲,最大USART_REC_LEN个字节,起始地址为0X20001000.</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>绝对定位不能在函数中定义</strong>；局部变量是定义在栈区的，栈区由MDK自动分配、释放，不能定义为绝对地址，只能放在函数外定义。</li><li>定义的长度不能超过栈或Flash的大小，否则，造成栈、Flash溢出。</li></ul><h1 id="四、重映射-amp-系统启动"><a href="#四、重映射-amp-系统启动" class="headerlink" title="四、重映射 &amp; 系统启动"></a>四、重映射 &amp; 系统启动</h1><h2 id="4-1-重映射"><a href="#4-1-重映射" class="headerlink" title="4.1 重映射"></a>4.1 重映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SRAM);</span><br></pre></td></tr></table></figure><p>例如F072的参考文档张SYSCFG寄存器的介绍，如下图： </p><img src="/2020/08/12/M0的中断向量表重映射/1.png" title="SYSCFG寄存器"><p>MEM_MODE的介绍如下：</p><img src="/2020/08/12/M0的中断向量表重映射/2.png" title="MEM_MODE"><p>从以上内容我们可以得到以下信息： </p><ol><li>MEM_MODE的值在上电后由BOOT0，BOOT1的状态值决定。 </li><li>MEM_MODE的值决定了哪个内存映射到地址0x0000 0000 ，也就是说: <ol><li>当MEM_MODE =00/10时， Main Flash映射到地址0x0000 0000，即地址0x0800 0000映射到0x0000 0000。</li><li>当MEM_MODE =01时， System Flash映射到地址0x0000 0000，也就是芯片自带的Bootloader代码部分会映射到地址0x0000 0000；例如，0x1FFF C800映射到地址0x0000 0000。</li><li>当MEM_MODE =11时， Embeded SRAM映射到地址0x0000 0000，也就是内存地址0x2000 0000映射到地址0x0000 0000。 </li></ol></li><li>经过映射后，系统访问地址0x0000 0000地址，就相当于直接访问映射的地址，如0x0800 0000。</li><li>由BOOT0，BOOT1的状态决定MEM_MODE的值，进而决定哪个地址映射到地址0x0000 0000，这一过程我们称之为映射。默认映射是系统自动完成的，并由BOOT0，BOOT1的状态决定。 </li><li>MEM_MODE位是RW的，也就是说可以修改的，如果修改其中，也就会相应的修改映射到0x0000 0000的地址，这一修改的过程，我们就叫其为重映射。重映射是通过用户代码通过修改MEM_MODE的值来完成的。</li></ol><h2 id="4-2-系统启动"><a href="#4-2-系统启动" class="headerlink" title="4.2 系统启动"></a>4.2 系统启动</h2><p>从STM32F072的参考手册的2.5章，我们可以看到如下内容： </p><img src="/2020/08/12/M0的中断向量表重映射/2.png" title="STM32F072参考手册"><p>从以上内容我们可以得到以下有用信息: </p><ol><li>在复位启动后，系统在系统时钟的第4个上升沿根据BOOT0,BOOT1的配置获取其值，也就是存储到寄存器SYSCFG_CFGR1的MEM_MODE位上，根据前面3.1的信息可知，这里进一步确定了0x0000 0000的映射地址。这一过程是系统自动完成的。 </li><li>在系统启动后，CPU从地址0x0000 0000获取栈顶地址，然后从0x0000 0004开始执行代码。换句话说，由于0x0000 0000被映射了其他地址，获取栈顶与执行实际上都是从映射的地址上实施的。也就是从映射的地址开始执行代码，比如从地址0x08000 0004开始执行代码(如Mian Flash映射)，比如0x1FFF C804(如System Flash映射，即BootLoader启动)。<br>于是，我们简单整理下系统的整个启动流程: </li></ol><ul><li>-&gt; 系统复位 </li><li>-&gt; CPU在系统时钟的第4个上升沿根据BOOT0，BOOT1的配置确定寄存器SYSCFG_CFGR1的MEM_MODE的值 </li><li>-&gt; MEM_MODE进一步决定哪个地址(Main Flash,System Flash,SRAM)映射到地址0x0000 0000. </li><li>-&gt; CPU从地址0x0000 0000获取栈顶，从0x0000 0004开始执行代码，也就是从映射地址获取栈顶，从映射地址+4的地方开始执行代码。 </li><li><blockquote><p>映射地址+4对于着复位中断例程(如0x08000 0004)，也就是系统一开始就执行Reset_Handler，进而运行SystemInit然后进入到main函数，就这样，整个代码启动完成。</p></blockquote></li></ul><p>接下来就是中断产生于中断响应了。</p><p>&emsp;&emsp;在Coretext-M3与Coretext-M4核中，在 <code>System Control Block</code> 中存在一个向量表偏移量寄存器 VTOR(0xE000ED08)，系统产生中断后，内核通过这个寄存器的值来找到中断向量表的地址，进而执行中断例程代码，当然，此寄存器的值是可以修改的，它的默认值为0。</p><p>&emsp;&emsp;由于STM32F0XX采用的是M0核，它是没有这个VTOR寄存器的；将M0理解成M3/M4的特殊情况，M0假设也存在VTOR这么一个虚拟寄存器，只不过它的值不能修改,固定为0罢了，而M3/M4的这个VTOR寄存器一开始时它的值也是为默认值0，只不过在程序运行到SystemInit()函数后，在代码中明确对其进行了修改。</p><p>重新整理下，STM32F0XX中断的调用过程: </p><ul><li>-&gt; 产生中断 </li><li>-&gt; CPU固定到地址0x0000 0000上找中断入口函数；由于映射关系，实际上是在从映射地址上寻找。 </li><li>-&gt; 找到并执行中断例程</li></ul><h1 id="五、Stm32F030的App工程配置"><a href="#五、Stm32F030的App工程配置" class="headerlink" title="五、Stm32F030的App工程配置"></a>五、Stm32F030的App工程配置</h1><p>&emsp;&emsp;关于Stm32F0的APP，只需要更改工程配置的 IROM 和 IRAM 就行了。</p><img src="/2020/08/12/M0的中断向量表重映射/4.png" title="IROM&IRAM"><p>&emsp;&emsp;IRAM存放着重映射中断向量表。1个地址存储1个byte(Falsh 和 Ram 都一样)，中断向量都是uint32_t；所以 48 * (32/8) = 0xC0 。</p><h1 id="六、友情连接"><a href="#六、友情连接" class="headerlink" title="六、友情连接"></a>六、友情连接</h1><p>&emsp;&emsp;关于Stm32F0的IAP，ST官方有套参考代码；<a href="https://pan.baidu.com/s/1-jREbLowNT3TbI_50aAgBg" target="_blank" rel="noopener">ST官方的IAP + Ymodem代码</a>；提取码为：aan9</p><p>&emsp;&emsp;本篇文章部分内容来自于这位博主：<a href="https://blog.csdn.net/flydream0/article/details/52808191" target="_blank" rel="noopener">flydream0</a>，有些更细致的内容可以了解他写的链接文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Stm32F030的Bootloader制作与其他ST芯片一致；但是Stm32F030的APP程序就有特殊变动：因为M0是不能设置重量向量表偏移量；本篇就讲M0的APP程序的中断向量表重映射，和还有一些会用到的冷知识，如编译工具链等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="bootloader" scheme="http://shatang.github.io/tags/bootloader/"/>
    
      <category term="编译工具链" scheme="http://shatang.github.io/tags/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    
      <category term="Stm32" scheme="http://shatang.github.io/tags/Stm32/"/>
    
  </entry>
  
  <entry>
    <title>IAP升级 &amp; Bootloader制作</title>
    <link href="http://shatang.github.io/2020/08/12/IAP%E5%8D%87%E7%BA%A7-Bootloader%E5%88%B6%E4%BD%9C/"/>
    <id>http://shatang.github.io/2020/08/12/IAP升级-Bootloader制作/</id>
    <published>2020-08-12T14:31:32.000Z</published>
    <updated>2020-08-22T06:46:07.884Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇主要讲基于Stm32的IAP升级(即Bootloader升级)。主要是讲解Bootloader制作思路(该思路不只是用于该系列的芯片)。此篇文章内容较多，需要慢慢消化，部分内容可以先跳着看。</p><a id="more"></a><h1 id="一、IAP-amp-Bootloader"><a href="#一、IAP-amp-Bootloader" class="headerlink" title="一、IAP &amp; Bootloader"></a>一、IAP &amp; Bootloader</h1><h2 id="1-1-IAP-amp-ISP"><a href="#1-1-IAP-amp-ISP" class="headerlink" title="1.1 IAP &amp; ISP"></a>1.1 IAP &amp; ISP</h2><ul><li>ISP：In System Programing，在系统编程</li><li>IAP：In applicating Programing，在应用编程</li></ul><p>&emsp;&emsp;ISP是指可以在板级上进行编程，也就是不用拆芯片下来，写的是整个程序，一般是通过ISP接口线来写。</p><p>&emsp;&emsp;IAP虽然同样也是在板级上进行编程，但是是自已对自已进行编程，在应用中进行编程，也即可以只是更改某一部分而不影响系统的其它部分，另外接口程序是自已写的，这样可以进行远程升级而不影响应用。</p><p>&emsp;&emsp;ISP即是我们平常编程下载的方法，每次烧录程序都要把MCU的Flash全部都擦除一遍；IAP下载，则是擦除部分Flash(APP)，另外部分未擦除部分(Bootloader)可以根据自己祖传留下的代码搞一些骚操作，例如把自己的活(擦写存储APP代码的Flash)搞完就跑去执行被擦除(刷新)过Flash程序(APP)。常见的方法就是在Bootloader擦除APP程序，擦除完再跳转到新的APP程序继续运行，实现不需要烧录线进行ISP下载就能升级。</p><h2 id="1-2-Bootloader"><a href="#1-2-Bootloader" class="headerlink" title="1.2 Bootloader"></a>1.2 Bootloader</h2><p>&emsp;&emsp;源自linux上的BootLoader的概念，在linux上，BootLoader是首先执行的程序，BootLoader启动之后初始化CPU、RAM、Flash等设备，然后从Flash中读取Linux程序数据到RAM中去，最后跳转到RAM中Linux的起始地址中去启动Linux系统。除了从Flash中读取系统启动之外，BootLoader还能通过网络NFS协议从服务器上读取Linux并启动。BootLoader还能够更新Linux内核、配置Linux启动信息、测试系统等等。</p><p>&emsp;&emsp;在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像Window自带BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。</p><hr><p>&emsp;&emsp;简单理解的话，Bootloader就是我们常见的计算机开机操作，而我们则是想要打开自己想用的软件Keil(APP)。我们没办法秒开机直接运行Keil(APP)，需要等待一段时间；计算机需要做底层软、硬件的配置(Bootloader)。</p><p>&emsp;&emsp;我们要做的STM32的BootLoader也是类似的工作原理，但是没有Linux系统的BootLoader功能那么强大。我们要做的STM32的BootLoader只有两个主要目的：</p><ol><li>跳转到应用程序并执行；</li><li>更新应用程序(App)；</li></ol><p><strong><font color="red">Ps：</font></strong> 因此，下载新(App)程序后并不擦除bootLoader程序，下次启动依然先运行BootLoader程序，可以选择性更新或者不更新程序，所以STM32的BootLoader作用往往就是用来管理单片机程序的更新。</p><h2 id="1-3-Bootloader-amp-App"><a href="#1-3-Bootloader-amp-App" class="headerlink" title="1.3 Bootloader &amp; App"></a>1.3 Bootloader &amp; App</h2><p>&emsp;&emsp;其实IAP升级，就需要将原有APP，分割成Bootloader和新APP。Bootloader负责检查更新APP，新APP则是继续执行原有APP功能；但是在MCU的Flash上，会产生地址分块(Bootloader+App)，新APP则是需要重映射中断向量表</p><p>Bootloader里面主要是</p><ol><li>设置规划bootloader和app的空间</li><li>接收编译好的app的bin文件，写入flash</li><li>实现跳转至APP</li></ol><p>App里面主要修改的地方是</p><ol><li>ROM起始地址和分配的空间大小</li><li>中断向量表 重定向</li><li>生成bin文件</li></ol><hr><p><strong><font color="red">Ps：</font></strong> 由于Bootloader可以对接收bin文件方法有多种多样，因此常见的升级方式为: </p><ul><li>串口升级(私有协议或者X-Modem、Y-Modem) </li><li>USB升级(DFU)</li><li>U盘升级(OTG) </li><li>网络升级 </li><li>无线升级(OTA,例如蓝牙)</li></ul><h1 id="二、IAP升级的预备知识"><a href="#二、IAP升级的预备知识" class="headerlink" title="二、IAP升级的预备知识"></a>二、IAP升级的预备知识</h1><h2 id="2-1-复位序列"><a href="#2-1-复位序列" class="headerlink" title="2.1 复位序列"></a>2.1 复位序列</h2><p>&emsp;&emsp;M3单片机复位后，从0x00000000取栈指针（SP）， 从0x00000004取复位向量（PC），<strong>有了栈指针和复位向量后，单片机就按照正常流程运行了</strong>；在BootLoader里面，我们更新完程序后需要做的步骤之一就是设置栈指针，跳转复位向量。</p><h3 id="2-1-1-栈指针"><a href="#2-1-1-栈指针" class="headerlink" title="2.1.1 栈指针"></a>2.1.1 栈指针</h3><p>&emsp;&emsp;CPU 按照 MSP 指针，到ROM存取地址或数据。</p><h3 id="2-1-2-pc指针"><a href="#2-1-2-pc指针" class="headerlink" title="2.1.2 pc指针"></a>2.1.2 pc指针</h3><p>&emsp;&emsp;CPU 按照 PC 指针，到ROM去取指令代码。PC，是 program calculate 的缩写,即程序计数器；</p><p><strong><font color="red">Ps：</font></strong> 当前PC在ROM的位置就是程序执行到的位置；在涉及到操作系统(ucOS)原理的时候，PC指针就扮演着十分重要的角色。</p><p>&emsp;&emsp;<strong><font color="red">有了栈指针和复位向量后，单片机就能够运行了！</font></strong></p><h2 id="2-2-重定位中断向量表"><a href="#2-2-重定位中断向量表" class="headerlink" title="2.2 重定位中断向量表"></a>2.2 重定位中断向量表</h2><h3 id="2-2-1-中断向量表里面到底是什么，它放在哪里？到底有什么用？"><a href="#2-2-1-中断向量表里面到底是什么，它放在哪里？到底有什么用？" class="headerlink" title="2.2.1 中断向量表里面到底是什么，它放在哪里？到底有什么用？"></a>2.2.1 中断向量表里面到底是什么，它放在哪里？到底有什么用？</h3><ol><li>中断向量表实际上就是存放在 code区 0地址开始的一个数组，数组的成员为4个字节，而且这些数组在启动文件的时候已经初始化好，既然初始化好，那里面存放的是什么？</li><li>STM32根据内核和外设中断优先级，统一标号，标号越小，优先级越大。然后把内核和外设的中断服务函数的地址放到这个数组里面，数组的下标跟中断的优先级对应，我们也把这个中断的编号叫做中断向量。</li><li>在启动文件执行的时候，内核和每个外设的中断服务函数的地址都是已经确定好的，地址就存放在中断向量表中，而且在启动文件里面已经写好了中断服务函数，只是这些中断服务函数为空，而且带[weak]弱定义，那么我们就需要在C文件里面重新实现这个中断服务函数，用户写这个中断服务函数的时候，函数名必须跟启动文件里面写的中断函数名对应，因为函数名对应的就是中断服务函数的地址，如果名字搞错了，那么在响应中断的时候，就默认响应启动文件里面预先写好[weak]、空的中断服务函数，而且是一个死循环。</li></ol><h3 id="2-2-2-内核是如何响应中断的呢？"><a href="#2-2-2-内核是如何响应中断的呢？" class="headerlink" title="2.2.2 内核是如何响应中断的呢？"></a>2.2.2 内核是如何响应中断的呢？</h3><p>&emsp;&emsp;当中断来临的时候，首先取向量，每个中断的中断向量不一样，然后根据向量查询中断向量表，根据表里面的地址找到中断服务函数，从而实现整个中断的响应过程。</p><h3 id="2-2-3-理解了中断向量表后"><a href="#2-2-3-理解了中断向量表后" class="headerlink" title="2.2.3 理解了中断向量表后"></a>2.2.3 理解了中断向量表后</h3><ol><li>那么你在C文件里面写中断服务函数的时候就知道为什么要这样写中断服务函数的名字，而且你也可以修改启动文件里面的中断向量表里面的地址（即修改函数名字即可）。</li><li>在后面移植ucosiii等os的时候，也知道PendSV要怎么移植和修改</li></ol><hr><p>&emsp;&emsp;BootLoader是一个完整的程序，更新用的App也是一个完整的程序。一个完整嵌入式程序都包含中断向量表，用于响应中断；两者当然无法共用一套中断处理(用法可能不同)，因此需要两个中断向量表，第一个中断向量表可以使用默认，而另外一个中断向量表则需要重定位(映射)。</p><h2 id="2-3-ROM的起始地址"><a href="#2-3-ROM的起始地址" class="headerlink" title="2.3 ROM的起始地址"></a>2.3 ROM的起始地址</h2><p>&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址 0x08000000 ，也就是说如果上面的中断向量表要重定义向到Flash上，是以基地址 0x08000000 计算偏移的(也可以重定向到RAM)；程序所有函数的地址默认都在以0x08000000为基地址的一段ROM里面了。</p><h3 id="2-3-1-程序起始地址0x08000000"><a href="#2-3-1-程序起始地址0x08000000" class="headerlink" title="2.3.1 程序起始地址0x08000000"></a>2.3.1 程序起始地址0x08000000</h3><p>&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址0x0800 0000，而CM3手册规定芯片复位时要从0x0000 0000地址开始取出中断向量，那STM32怎么样执行代码呢？是地址重映射？或者在0x0000 0000里有对应有实际存储器？</p><p>&emsp;&emsp;仔细阅读手册，STM32设计的Flash起始地址是在0x0800 0000位置开始的；全部代码都只能从这里开始存储，故要重映射。详见STM32 referenc manual手册第54页。</p><p>&emsp;&emsp;那既然从这里才能存储代码，就必须在MDK里设置Flash地址为0x0800 0000，下面是MDK设置页面，这个应该都看到过。</p><img src="/2020/08/12/IAP升级-Bootloader制作/1.jpg"><p>这样就产生一个问题，CM3中规定上电后CPU是从0地址开始执行，STM32设计的Flash起始地址是在0x0800 0000位置开始的，因此中断向量表烧写在0x0800 0000地址里，那启动时不就找不到中断向量表了？</p><p>&emsp;&emsp;既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了。</p><ul><li>当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取</li><li>所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。</li><li>这就是最难理解的地方，其实，这是基本上所有ARM芯片采用的启动映射方法。ARM7，ARM9没有内部Flash的通常都是这样做的。这个过程出自STM32 referenc manual手册，里面是有说明的。</li></ul><h2 id="2-4-hex文件和bin文件"><a href="#2-4-hex文件和bin文件" class="headerlink" title="2.4 hex文件和bin文件"></a>2.4 hex文件和bin文件</h2><p>&emsp;&emsp;Bootloader程序升级，往往是采用写入bin文件；那hex文件和bin文件有什么关系呢？</p><ul><li><p><strong>hex文件</strong></p><ul><li>hex文件是以ASCII文本形式保存编译后的二进制文件信息。Hex文件使用ASCII文本的形式保存Bin文件的内容和Bin文件的一些配置信息。hex文件可以由下载器（比如jlink）烧写到MCU的ROM中。</li><li>平时用J-LINK或者串口ISP下载程序，都是下载hex文件的;因为hex文件包含地址信息，下载程序的时候知道程序下载到ROM的哪个区域。反过来讲，hex文件是不能直接写进ROM的，一边写需要一边转换(解码出地址信息，将对应内容写入ROM)。</li></ul></li><li><p><strong>bin文件</strong></p><ul><li>Bin文件是MCU固件烧写的最终形式，也就是说MCU的ROM中烧写的内容完全就是Bin文件的内容。</li></ul></li><li><p>hex &amp; bin 区别</p><ul><li>Hex文件有更好的可读性，最重要的是hex文件能够保证固件在保存与传输时的完整性。因此hex文件更适用于保存与传输。</li><li>Bin文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过Bin文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。</li></ul></li></ul><hr><blockquote><p><strong>bin文件生成</strong></p></blockquote><p>&emsp;&emsp;默认情况下编译后生成的是hex文件，没有生成bin文件。keil的Bin文件生成方式有很多种，可以另外下载一个hex2bin工具，然后用Keil脚本执行；这里，介绍使用Keil自带的工具fromelf.exe。在Keil的安装目录下，例如：<code>E:\Keil\ARM\ARMCC\bin\fromelf.exe</code></p><ul><li><p>第一种方式：设置绝对路径(不建议这样做，别人用你工程需要再次修改路径)</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">MDK516</span>\<span class="title">ARM</span>\<span class="title">ARMCC</span>\<span class="title">bin</span>\<span class="title">fromelf.exe</span>" --<span class="title">bin</span> -<span class="title">o</span> ./<span class="title">obj</span>/<span class="title">test_app.bin</span> ./<span class="title">obj</span>/<span class="title">test_app.axf</span></span></span><br></pre></td></tr></table></figure></li><li><p>第二种方式：相对路径，直接复制下面的路径就能直接使用</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;bin文件生成在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下你可看到一个test1.bin（名字是根据你的hex文件名字一样）。</p><p>希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L</span><br></pre></td></tr></table></figure><p>生成的文件也是在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin。</p><h1 id="三、IAP升级的具体实现"><a href="#三、IAP升级的具体实现" class="headerlink" title="三、IAP升级的具体实现"></a>三、IAP升级的具体实现</h1><p>&emsp;&emsp;这次的例子采用的是串口Y-modem协议进行IAP升级。</p><h2 id="3-1-Bootloader程序的编写"><a href="#3-1-Bootloader程序的编写" class="headerlink" title="3.1 Bootloader程序的编写"></a>3.1 Bootloader程序的编写</h2><p>程序编写主要几件事：</p><ol><li>编写串口Y-modem（或者X-modem）协议，接收bin文件</li><li>把串口接收的bin文件缓存块，写入Stm32的flash指定地址</li><li>通过工程的 .map文件，大致规划好Bootloader和APP的Flash储存块地址(这肯定不能重叠了)</li><li>Bootloader执行程序能跳转到APP去</li><li>编译完成后，注意查看 .map文件，在编译器配置限制一下Bootloader程序的大小。</li></ol><p>&emsp;&emsp;对X-modem协议进一步了解的，可以看这篇博文： <a href="https://shatang.github.io/2020/08/12/Xmodem%E5%8D%8F%E8%AE%AE/#more">Xmodem协议</a><br>&emsp;&emsp;对Stm32的flash如何写数据，可以看这篇博文： <a href="https://shatang.github.io/2020/08/12/stm32%E5%86%85%E9%83%A8Flash%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more">stm32内部flash基础知识</a><br>&emsp;&emsp;放出官方源码：<a href="https://pan.baidu.com/s/1-jREbLowNT3TbI_50aAgBg" target="_blank" rel="noopener">ST官方的IAP + Ymodem代码</a>；提取码为：aan9</p><h2 id="3-2-Bootloader-跳转代码的理解"><a href="#3-2-Bootloader-跳转代码的理解" class="headerlink" title="3.2 Bootloader 跳转代码的理解"></a>3.2 Bootloader 跳转代码的理解</h2><p>跳转代码如下，后面逐条分析:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunction)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">pFunction JumpApp;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 : IAP_LoadApp</span></span><br><span class="line"><span class="comment">* 功  能 : Bootloader跳转至APP</span></span><br><span class="line"><span class="comment">* 说  明 : none</span></span><br><span class="line"><span class="comment">* 入  参 : none</span></span><br><span class="line"><span class="comment">* 返  回 : none</span></span><br><span class="line"><span class="comment">* 设  计 : Shatang                    时  间 : 2020.06.23</span></span><br><span class="line"><span class="comment">* 修  改 : none                       时  间 : none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IAP_LoadApp</span><span class="params">(<span class="keyword">uint32_t</span> Appxaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(((*(__IO <span class="keyword">uint32_t</span>*)Appxaddr) &amp; <span class="number">0x2FFE0000</span>) == <span class="number">0x20000000</span>)<span class="comment">//检查栈顶地址是否合法.</span></span><br><span class="line">&#123; </span><br><span class="line">JumpApp = (pFunction)*(__IO <span class="keyword">uint32_t</span>*)(Appxaddr + <span class="number">4</span>);<span class="comment">//用户代码区第二个字为程序开始地址(复位地址)</span></span><br><span class="line">__set_MSP(*(__IO <span class="keyword">uint32_t</span>*)Appxaddr);    <span class="comment">//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)</span></span><br><span class="line">JumpApp();                <span class="comment">//跳转到APP.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((((__IO <span class="keyword">uint32_t</span>*)Appxaddr) &amp; <span class="number">0x2FFE0000</span> ) == <span class="number">0x20000000</span>)</span><br><span class="line"><span class="comment">//判断栈定地址值是否在0x2000 0000 - 0x 2000 2000之间</span></span><br></pre></td></tr></table></figure><ol><li>在程序里 <code>#define Appxaddr    0x8003000 </code></li><li><code>*(__IO uint32_t*)Appxaddr) </code> ，即取0x8003000开始到0x8003003 的4个字节的值</li><li>因为我们的应用程序APP中设置把 中断向量表 放置在0x08003000 开始的位置；而中断向量表里第一个放的就是栈顶地址的值</li></ol><p>&emsp;&emsp;也就是说，这句话即通过判断栈顶地址值是否正确（是否在0x2000 0000 - 0x 2000 2000之内）来判断是否应用程序已经下载了，因为应用程序的启动文件刚开始就去初始化化栈空间，如果栈顶值对了，说应用程已经下载了，启动文件的初始化也执行了。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JumpApp = (pFunction)*(__IO <span class="keyword">uint32_t</span>*)(Appxaddr + <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>ApplicationAddress + 4</code>  即为0x0800 3004 ,里面放的是运行必不可少的第二项“复位地址”。此处强制转换，将地址值转换成指向地址。</p><p>&emsp;&emsp;<code>void (*pFunction)(void);</code>    是声明一个函数指针。将复位地址作为函数指针，当其执行对应函数时，就是执行复位函数。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_MSP(*(__IO <span class="keyword">uint32_t</span>*) ApplicationAddress);  <span class="comment">//设置主函数栈指针</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顾名思义，从上面可知内容，就是取 ApplicationAddress 开始到 ApplicationAddress+3 的4个字节的值，设置为栈顶地址(1个字，大小：4字节)。</p><hr><p><strong><font color="red">总结：</font></strong> 因此Bootloader跳转到App，最核心的点就只有两个(保证程序运行)：</p><ul><li>1)设置新复位向量(地址)，并跳转执行；</li><li>2)设置新栈顶地址，并将主函数栈指针指向该地址。</li></ul><h2 id="3-3-APP-重映射中断向量表"><a href="#3-3-APP-重映射中断向量表" class="headerlink" title="3.3 APP 重映射中断向量表"></a>3.3 APP 重映射中断向量表</h2><p>&emsp;&emsp;<strong>中断向量表是可以在程序中多次被映射的</strong>(可能你有多个APP程序)。在Cortex-M3系列芯片中，控制它的就是CM3已经规定的 NVIC寄存器 <code>SCB->VTOR</code> 。在STM32库中给出的启动代码里，startup_stm32f10x_hd.s文件里，第146行，是上电后读取中断向量表中的复位中断位置，并执行复位中断处理代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0               </span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意复位后第一个被执行的是SystemInit代码，这个代码在库目录下的 system_stm32f10x.c 文件里，它初始化了时钟，NVIC等一系列操作；这里摘要与中断向量有关的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出中断向量重映射是一个选择性编译，通常宏定义 <code>VECT_TAB_SRAM</code> 都没有被定义，所以这里执行结束后， <code>SCB->VTOR</code> 就是 FLASH_BASE 了，值为 0x08000000 。以后CM3再取中断向量里，就会根据 <code>SCB->VTOR</code> 的设置，从这里取向量执行了。中断向量自此开始偏移。</p><p><strong><font color="red">Ps：</font></strong> 这时连<code>__main</code>函数都还没进，中断向量的重映射位置还是够早的。</p><p>&emsp;&emsp;当然，也有些其他系列，甚至都没有<code>SCB->VTOR</code>，例如M0系列；这里有专门一篇文章讲解M0如何编写App的中断向量表重映射：<a href="https://shatang.github.io/2020/08/12/M0%E7%9A%84%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E9%87%8D%E6%98%A0%E5%B0%84/#more">M0的中断向量表重映射</a>。</p><h1 id="四、多种升级方式的源码"><a href="#四、多种升级方式的源码" class="headerlink" title="四、多种升级方式的源码"></a>四、多种升级方式的源码</h1><p>&emsp;&emsp;待更新</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇主要讲基于Stm32的IAP升级(即Bootloader升级)。主要是讲解Bootloader制作思路(该思路不只是用于该系列的芯片)。此篇文章内容较多，需要慢慢消化，部分内容可以先跳着看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="IAP" scheme="http://shatang.github.io/tags/IAP/"/>
    
      <category term="Xmodem" scheme="http://shatang.github.io/tags/Xmodem/"/>
    
      <category term="bootloader" scheme="http://shatang.github.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>Xmodem协议</title>
    <link href="http://shatang.github.io/2020/08/12/Xmodem%E5%8D%8F%E8%AE%AE/"/>
    <id>http://shatang.github.io/2020/08/12/Xmodem协议/</id>
    <published>2020-08-12T14:22:43.000Z</published>
    <updated>2020-09-05T05:26:24.150Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;常用于嵌入式IAP串口升级。</p><a id="more"></a><h1 id="一、什么是Xmodem协议？"><a href="#一、什么是Xmodem协议？" class="headerlink" title="一、什么是Xmodem协议？"></a>一、什么是Xmodem协议？</h1><p>&emsp;&emsp;XMODEM协议是一种串口通信中广泛用到的异步文件传输协议。分为标准Xmodem和1k-Xmodem两种，前者以128字节块的形式传输数据，后者字节块为1k即1024字节，并且每个块都使用一个校验和过程来进行错误检测。在校验过程中如果接收方关于一个块的校验和与它在发送方的校验和相同时，接收方就向发送方发送一个确认字节(ACK)。由于Xmodem需要对每个块都进行认可，这将导致性能有所下降，特别是延时比较长的场合，这种协议显得效率更低。</p><p>&emsp;&emsp;除了Xmodem，还有Ymodem，Zmodem协议。他们的协议内容和Xmodem类似，但是进行了拓展。</p><ul><li>Ymodem允许批处理文件传输，效率更高；</li><li>Zmodem则是改进的了Xmodem，它只需要对损坏的块进行重发，其它正确的块不需要发送确认字节。减少了通信量。</li></ul><h1 id="二、Xmodem协议相关控制字符"><a href="#二、Xmodem协议相关控制字符" class="headerlink" title="二、Xmodem协议相关控制字符"></a>二、Xmodem协议相关控制字符</h1><table><thead><tr><th>命令字符</th><th>命令码</th></tr></thead><tbody><tr><td>SOH</td><td>0x01 (Modem数据头)</td></tr><tr><td>STX</td><td>0x02</td></tr><tr><td>EOT</td><td>0x04 (发送结束)</td></tr><tr><td>ACK</td><td>0x06 (应答)</td></tr><tr><td>NAK</td><td>0x15 (非应答)</td></tr><tr><td>CAN</td><td>0x18 (取消发送)</td></tr><tr><td>CTRLZ</td><td>0x1A</td></tr></tbody></table><h1 id="三、Xmodem数据包格式"><a href="#三、Xmodem数据包格式" class="headerlink" title="三、Xmodem数据包格式"></a>三、Xmodem数据包格式</h1><blockquote><p>标准Xmodem协议（每个数据包含有128字节数据）帧格式</p></blockquote><p>| SOH | 信息包序号 | 信息包序号的补码 | 数据区段(128个字节) | 校验和 |</p><img src="/2020/08/12/Xmodem协议/1.png"><blockquote><p>标准XModem传输流程</p></blockquote><img src="/2020/08/12/Xmodem协议/2.png"><p>&emsp;&emsp;1k-Xmodem 只是在Xmodem协议基础上，进行了数据包长度的改进，从原有的128字节更改为1k字节。同时每个信息报的第一个字节的SOH变成了STX，STX定义为 <code><stx> 0x02</stx></code> ，能有效的加快数据传输速率。</p><h1 id="四、校验方式和传输流程"><a href="#四、校验方式和传输流程" class="headerlink" title="四、校验方式和传输流程"></a>四、校验方式和传输流程</h1><h2 id="4-1-校验方式说明"><a href="#4-1-校验方式说明" class="headerlink" title="4.1 校验方式说明"></a>4.1 校验方式说明</h2><p>&emsp;&emsp;Xmodem协议支持2种校验和，它们是累加和与CRC校验。</p><ul><li>当接收方一开始启动传输时发送的是NAK，表示它希望以累加和方式校验；</li><li>当接收方一开始启动传输时发送的是字符“C”，表示它希望以CRC方式校验。</li></ul><p>&emsp;&emsp;可能有人会问，接收方想怎么校验发送方都得配合吗，难道发送方必须都支持累加和校验和CRC校验？事实上Xmodem要求支持CRC的就必须同时支持累加和。如果发送方只支持累加和，而接收方用字符“C”来启动，那么发送方只要不管它，当接收方继续发送“C”，三次后都没收到应答，就自动会改为发送 NAK；因为它已经明白发送方可能不支持CRC校验，现在接收方改为累加和校验和发送方通讯。发送方收到NAK就赶紧发送数据包响应。 </p><h2 id="4-2-启动传输"><a href="#4-2-启动传输" class="headerlink" title="4.2 启动传输"></a>4.2 启动传输</h2><p>&emsp;&emsp;传输由接收方启动，方法是向发送方发送”C”或者NAK （注意哦，这里提到的NAK是用来启动传输的；以后我们会看到NAK还可以用来对数据产生重传的机制）。</p><ul><li>接收方发送NAK信号表示接收方打算用累加和校验；</li><li>发送字符”C”则表示接收方想打算使用CRC校验</li></ul><p>举例，接收方要求发送方以校验和方式发送时以NAK来请求，发送方将对此做出应答。如下图：</p><img src="/2020/08/12/Xmodem协议/3.png"><h2 id="4-3-传输过程"><a href="#4-3-传输过程" class="headerlink" title="4.3 传输过程"></a>4.3 传输过程</h2><p>&emsp;&emsp;当接收方发送的第一个”C”或者NAK到达发送方，发送方认为可以发送第一个数据包，传输已经启动。发送方接着应该将数据以每次128字节的数据加上包头，包号，包号补码，末尾加上校验和，打包成帧格式传送。</p><p>&emsp;&emsp;发送方发了第一包后就等待接收方的确认字节ACK，收到接收方传来的ACK确认，就认为数据包被接收方正确接收，并且接收方要求发送方继续发送下一个包；如果发送方收到接收方传来的NAK （这里，NAK用来告诉发送方重传，不是用来启动传输） 字节，则表示接收方请求重发刚才的数据包；</p><p>&emsp;&emsp;如果发送方收到接收方传来的CAN字节，则表示接收方请求无条件停止传输。</p><h2 id="4-4-结束传输"><a href="#4-4-结束传输" class="headerlink" title="4.4 结束传输"></a>4.4 结束传输</h2><p>&emsp;&emsp;如果发送方正常传输完全部数据，需要结束传输，正常结束需要发送方发送EOT 字节通知接收方。接收方回以ACK进行确认。当然接收方也可强制停止传输，当接收方发送CAN 字节给发送方，表示接收方想无条件停止传输，发送方收到CAN后，不需要再发送 EOT确认（因为接收方已经不想理它了，呵呵）。</p><h2 id="4-5-特殊处理"><a href="#4-5-特殊处理" class="headerlink" title="4.5 特殊处理"></a>4.5 特殊处理</h2><p>&emsp;&emsp;虽然数据包是以 SOH 来标志一个信息包的起始的，但在 SOH 位置上如果出现EOT则表示数据传输结束，再也没有数据传过来。</p><ul><li>接收方首先应确认数据包序号的完整性，通过对数据包序号取补，然后和数据包序号的补码异或，结果为0表示正确，结果不为0则发送NAK请求重传。</li><li>接收方确认数据包序号正确后，然后检查是否期望的序号。如果不是期望得到的数据包序号，说明发生严重错误，应该发送一个 CAN 来中止传输。</li><li>如果接收到的数据包的包序号和前一包相同，那么接收方会忽略这个重复包，向发送方发出 ACK ，准备接收下一个包。</li><li>接收方确认了信息包序号的完整性和是正确期望的后，只对 128 字节的数据区段进行算术和校验，结果与帧中最后一个字节（算术校验和）比较，相同发送 ACK，不同发送 NAK。</li></ul><h2 id="4-6-数据包特殊说明"><a href="#4-6-数据包特殊说明" class="headerlink" title="4.6 数据包特殊说明"></a>4.6 数据包特殊说明</h2><p>&emsp;&emsp;对于标准Xmodem协议来说，如果传送的文件不是128的整数倍，那么最后一个数据包的有效内容肯定小于帧长，不足的部分需要用CTRL- Z(0x1A)来填充。这里可能有人会问，我数据末尾是0x1A呢？</p><ul><li>如果传送的是文本文件，那么接收方对于接收的内容是很容易识别的，因为Xmodem协议定义的<strong>CTRL-Z(0x1A)</strong> 不是前128个ascii码中的通用可见字母等字符( 0x1A 对应 SUB[替补] )。</li><li>如果传送的是二进制文件，例如 bootloader 工程生成的.bin文件。假如我的.bin文件最末尾是0x1A，那如何区分填充的0x1A？<ul><li>例如像excel文件等，由于其数据内部会有些结构表示各个字段长度等，所以不会读取多余的填充字符。</li><li>而.bin文件，一般是不做区分的，它直接把填充码直接同样写入flash<ul><li>Flash写入是要擦除的，如果想利用填充码位置的Flash，只能用一次性，不然会损坏到IAP升级的APP文件</li><li>Mcu其实不会把填充码当作代码来执行(没有跳转到该位置的代码块)。</li><li>如果使用 1k-Xmodem ，最极端的情况下，也就浪费Mcu不到1K flash；(对于芯片Flash容量小，即扇区也小，干脆直接用Xmodem升级)</li></ul></li></ul></li></ul><h1 id="五、补充知识：128个字符的ASCII码表"><a href="#五、补充知识：128个字符的ASCII码表" class="headerlink" title="五、补充知识：128个字符的ASCII码表"></a>五、补充知识：128个字符的ASCII码表</h1><p>&emsp;&emsp;由于上面的文本文件，对编码格式有疑惑的，建议重新看一下128字符的ASCII码表。<strong>基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。</strong><br>&emsp;&emsp;文章的链接为：<a href="https://shatang.github.io/2020/06/28/128%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84ASCII%E7%A0%81%E8%A1%A8/#more">128个字符的ASIIC码表</a></p><h1 id="六、补充知识：CRC16校验的实现"><a href="#六、补充知识：CRC16校验的实现" class="headerlink" title="六、补充知识：CRC16校验的实现"></a>六、补充知识：CRC16校验的实现</h1><p>&emsp;&emsp;对CRC校验有疑惑、不了解的，可以看这篇博文：<a href="https://shatang.github.io/2020/08/10/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#more">CRC校验算法原理分析</a></p><h1 id="七、代码实例"><a href="#七、代码实例" class="headerlink" title="七、代码实例"></a>七、代码实例</h1><p>&emsp;&emsp;这里先放一个官方例程：<a href="https://pan.baidu.com/s/1-jREbLowNT3TbI_50aAgBg" target="_blank" rel="noopener">ST官方的IAP + Ymodem代码</a>；提取码为：aan9<br>&emsp;&emsp;再放一个超级终端方便调试升级：<a href="https://pan.baidu.com/s/1OgDHkVzkezVbZZcGGQCMZw" target="_blank" rel="noopener">超级终端(支持win10)</a>；提取码为：3ejn</p><h2 id="7-1-Ymodem协议"><a href="#7-1-Ymodem协议" class="headerlink" title="7.1 Ymodem协议"></a>7.1 Ymodem协议</h2><p>&emsp;&emsp;从上述Xmodem知识讲解后，如果你去查询 Ymodem协议概念 ，你会发现及其相似。这里我放我的实例；根据官方IAP升级例程进行简化(阉割)，方便理解；芯片是Stm32F407vgt6，支持多串口任选升级 的代码：<a href="https://github.com/shatang/Bootloader_Uart_Ymodem" target="_blank" rel="noopener">非标准Ymodem协议的IAP升级</a>。</p><p>&emsp;&emsp;<strong>标准</strong>Ymodem的特点，就是相对Xmodem能进行批文件传输。Ymodem支持文件传输，体现在YModem的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输会先发。</p><p>且数据传输结束方法要进行确认：</p><ol><li>数据传输完毕后，发送方发EOT，第一次接收方以NAK应答，准备二次确认。</li><li>发送方收到NAK后，重发EOT，接收方第二次收到结束符，就以ACK应答。</li><li>最后接收方再发送一个’C’，发送方在没有第二个文件要传输的情况下，发送数据<br><code>SOH 00 FF 00~00(共128个) CRCH CRCL</code></li><li>接收方应答ACK后，正式结束数据传输。</li></ol><p>&emsp;&emsp;这样的话，每次建立连接，标准Ymodem一次能传输多文件，即批文件传输。</p><p><strong>Ps：</strong> 如果应用在嵌入式Bootloader的话，基本都只传一个文件，且要压缩Bootloader程序大小；即接收方嵌入式固件为非标准的Ymodem协议。</p><h2 id="7-2-Xmodem-amp-Ymodem"><a href="#7-2-Xmodem-amp-Ymodem" class="headerlink" title="7.2 Xmodem &amp; Ymodem"></a>7.2 Xmodem &amp; Ymodem</h2><p>&emsp;&emsp;根据 7.1 的实例，能够通过Ymodem协议进行IAP升级；Xmodem 和 Ymodem 极其相似，直接切换成 Xmodem协议 进行升级能不能成呢？</p><p>当然是理所当然地报错了！那么极其相似，但到底差别在哪里？</p><ul><li>文件传输的第一个数据包<ul><li>Ymodem支持文件传输，体现在了传输文件第一个包；YModem的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输会先发；</li><li>而Xmodem是直接传输数据的</li></ul></li><li>数据包报文中的 Byte2 和 Byte3，一个是数据包数，一个是数据包数补码<ul><li>Ymodem协议，他的数据包数是0x00开始(因为要多接一个文件信息)</li><li>Xmodem协议，它的数据包数是0x01开始的(= =|||)</li></ul></li></ul><p>&emsp;&emsp;通过上述的总结，因为Ymodem与Xmodem很相似，可以根据上面的不同点稍微改一下，就能得到 基于Xmodem协议的IAP升级 代码： <a href="https://github.com/shatang/Bootloader_Uart_Xmodem" target="_blank" rel="noopener">基于Xmodem协议的IAP升级</a>。(残留一些Ymodem的代码，想精简可去掉)</p><ul><li>两者带来的差别：Flash的擦除<ul><li>Ymodem协议，第一包数据可以知道文件名、文件大小，所以不必要直接连接上就擦除Flash；<ul><li>可以第一包(文件)数据不符合要求就不擦除旧APP的Flash</li><li>因此连上超级终端，不升级，设备是不会变成砖的(未擦除)</li></ul></li><li>Xmodem协议，不清楚文件，因此一般会连接上后直接擦除旧APP存储的Flash；<ul><li>因为擦除程序在连接成功后就做，那么如果连上后放弃升级，该设备自然就会变成砖(就我现在写的那个)；</li><li>当然也可以改进成在确实收到(识别)第一包数据包后，再擦除Flash；就能实现类似Ymodem的效果</li></ul></li></ul></li></ul><h2 id="7-3-文件加密-小技巧"><a href="#7-3-文件加密-小技巧" class="headerlink" title="7.3 文件加密(小技巧)"></a>7.3 文件加密(小技巧)</h2><p>&emsp;&emsp;通过上述的Xmodem、Ymodem进行文件传输时，有时候需要文件加密安全一点。我举一个自己在用的例子：</p><ol><li>做一个简易的上位机，把bin文件拖进去；由于bin文件就是二进制文件，可以将其 异或 某条字符串，不断循环直至 整个文件异或成 新的文件</li><li>通过协议传输后，把获取到的数据，又重新异或一遍，这样的话，数据就会解密(数据异或两次就会变回原来的数据)，再写入Flash</li><li>上位机的字符串加密要可改写非固定，这样就能实现简单文件加密传输拉！！</li></ol><p><strong>Ps：</strong> 上面我的代码例程就有夹杂解密的，可以去掉；不过我代码的Ymodem没加CRC校验；Xmodem例程就加了CRC校验。实测加了校验，对实际传输的时间影响不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;常用于嵌入式IAP串口升级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="IAP" scheme="http://shatang.github.io/tags/IAP/"/>
    
      <category term="串口协议" scheme="http://shatang.github.io/tags/%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="文件传输" scheme="http://shatang.github.io/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>stm32内部Flash基础知识</title>
    <link href="http://shatang.github.io/2020/08/12/stm32%E5%86%85%E9%83%A8Flash%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://shatang.github.io/2020/08/12/stm32内部Flash基础知识/</id>
    <published>2020-08-12T14:14:08.000Z</published>
    <updated>2020-08-12T14:44:01.332Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;由于嵌入式IAP升级时，制作的Bootloader往往会涉及到Stm32的Flash的一些操作(用于写入App程序)，因此这里讲解一下Stm32的Flash相关操作</p><a id="more"></a><h1 id="一、Stm32的Flash"><a href="#一、Stm32的Flash" class="headerlink" title="一、Stm32的Flash"></a>一、Stm32的Flash</h1><h2 id="1-1-Flash的基础原理"><a href="#1-1-Flash的基础原理" class="headerlink" title="1.1 Flash的基础原理"></a>1.1 Flash的基础原理</h2><p>&emsp;&emsp;此处内容可以看该篇博文：<a href="https://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8/">嵌入式存储器</a></p><h2 id="1-2-Stm32的Flash特性、操作"><a href="#1-2-Stm32的Flash特性、操作" class="headerlink" title="1.2 Stm32的Flash特性、操作"></a>1.2 Stm32的Flash特性、操作</h2><ul><li>已知Flash写入前需要擦除的特性</li><li>Nor Flash接口与RAM接口相同，因此往往MCU内部采用Nor Flash；即Stm32的Flash为 Nor Flash<ul><li>因此如果是擦除大块区域时，会相对较慢</li></ul></li><li>Stm32的Flash使用前后，需要 解锁 、 锁定<ul><li>在实际发布的产品中，在STM32芯片的内部FLASH存储了控制程序，如果不作任何保护措施的话，可以使用下载器直接把内部FLASH的内容读取回来，得到bin或hex文件格式的代码拷贝，别有用心的厂商即可利用该代码文件山寨产品。 </li></ul></li></ul><hr><p>&emsp;&emsp;对STM32 内部FLASH进行编程操作，一般需要遵循以下流程：</p><ol><li>Flash解锁</li><li>清除相关标志位</li><li>擦除Flash</li><li>写入Flash</li><li>锁定Flash</li></ol><h2 id="1-3-Flash的底层操作函数-仅限Stm32"><a href="#1-3-Flash的底层操作函数-仅限Stm32" class="headerlink" title="1.3 Flash的底层操作函数(仅限Stm32)"></a>1.3 Flash的底层操作函数(仅限Stm32)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLASH_Unlock(); <span class="comment">//Flash解锁函数</span></span><br><span class="line">FLASH_Lock();   <span class="comment">//Flash锁定函数</span></span><br><span class="line"><span class="function">FLASH_Status <span class="title">FLASH_EraseSector</span><span class="params">(<span class="keyword">uint32_t</span> FLASH_Sector, <span class="keyword">uint8_t</span> VoltageRange)</span></span>;    <span class="comment">//Flash擦除函数</span></span><br><span class="line"><span class="function">FLASH_Status <span class="title">FLASH_ProgramWord</span><span class="params">(uint32_r Address， <span class="keyword">uint32_t</span> Data)</span></span>;   <span class="comment">//Flash写入函数</span></span><br></pre></td></tr></table></figure><h2 id="1-4-Flash的衍生操作函数"><a href="#1-4-Flash的衍生操作函数" class="headerlink" title="1.4 Flash的衍生操作函数"></a>1.4 Flash的衍生操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_If_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_If_Finish</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">FLASH_If_Erase</span><span class="params">(<span class="keyword">uint32_t</span> StartSector)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">FLASH_If_Write</span><span class="params">(__IO <span class="keyword">uint32_t</span>* FlashAddress, <span class="keyword">uint32_t</span>* Data ,<span class="keyword">uint32_t</span> DataLength)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_IF_Read</span><span class="params">(<span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> *pBuffer, <span class="keyword">uint32_t</span> NumToRead)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：Stm32F407VGT6的Flash</span></span><br><span class="line"><span class="comment">//FLASH 扇区的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) <span class="comment">//扇区0起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) <span class="comment">//扇区1起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) <span class="comment">//扇区2起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) <span class="comment">//扇区3起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) <span class="comment">//扇区4起始地址, 64 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) <span class="comment">//扇区5起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) <span class="comment">//扇区6起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) <span class="comment">//扇区7起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_8     ((uint32_t)0x08080000) <span class="comment">//扇区8起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_9     ((uint32_t)0x080A0000) <span class="comment">//扇区9起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_10    ((uint32_t)0x080C0000) <span class="comment">//扇区10起始地址,128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_11    ((uint32_t)0x080E0000) <span class="comment">//扇区11起始地址,128 Kbytes</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  GetSector</span></span><br><span class="line"><span class="comment">* 功  能 :  获取某个地址所在的flash扇区</span></span><br><span class="line"><span class="comment">* 说  明 :  Stm32F407VGT6的Flash扇区分配</span></span><br><span class="line"><span class="comment">* 入  参 :  fu32_Addr：flash地址</span></span><br><span class="line"><span class="comment">* 返  回 :  0~11,即addr所在的扇区</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint16_t <span class="title">GetSector</span><span class="params">(<span class="keyword">uint32_t</span> fu32_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_1)<span class="keyword">return</span> FLASH_Sector_0;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_2)<span class="keyword">return</span> FLASH_Sector_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_3)<span class="keyword">return</span> FLASH_Sector_2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_4)<span class="keyword">return</span> FLASH_Sector_3;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_5)<span class="keyword">return</span> FLASH_Sector_4;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_6)<span class="keyword">return</span> FLASH_Sector_5;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_7)<span class="keyword">return</span> FLASH_Sector_6;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_8)<span class="keyword">return</span> FLASH_Sector_7;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_9)<span class="keyword">return</span> FLASH_Sector_8;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_10)<span class="keyword">return</span> FLASH_Sector_9;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_11)<span class="keyword">return</span> FLASH_Sector_10; </span><br><span class="line"><span class="keyword">return</span> FLASH_Sector_11;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Init</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash初始化(解锁)</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_If_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FLASH_Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear pending flags (if any) */</span></span><br><span class="line">    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |</span><br><span class="line">                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 : FLASH_If_Finish</span></span><br><span class="line"><span class="comment">* 功  能 : stm32的内部flash关闭(上锁)</span></span><br><span class="line"><span class="comment">* 说  明 : none</span></span><br><span class="line"><span class="comment">* 入  参 : none</span></span><br><span class="line"><span class="comment">* 返  回 : none</span></span><br><span class="line"><span class="comment">* 设  计 : Shatang                    时  间 : 2020.07.29</span></span><br><span class="line"><span class="comment">* 修  改 : none                       时  间 : none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_If_Finish</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Clear pending flags (if any) */</span></span><br><span class="line">    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |</span><br><span class="line">                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);</span><br><span class="line">    </span><br><span class="line">    FLASH_Lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Erase</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash擦除</span></span><br><span class="line"><span class="comment">* 说  明 :  只针对APP文件地址的存储内容进行擦除</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="keyword">uint32_t</span> FLASH_If_Erase(<span class="keyword">uint32_t</span> StartSector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> UserStartSector;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the sector where start the user flash area */</span></span><br><span class="line">    UserStartSector = GetSector(StartSector);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = UserStartSector; i &lt;= GetSector(APPLICATION_END_ADDRESS); i += <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Device voltage range supposed to be [2.7V to 3.6V], the operation will</span></span><br><span class="line"><span class="comment">        be done by word */</span> </span><br><span class="line">        <span class="keyword">if</span> (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Error occurred while page erase */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Write</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash写操作</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="keyword">uint32_t</span> FLASH_If_Write(__IO <span class="keyword">uint32_t</span>* FlashAddress, <span class="keyword">uint32_t</span>* Data ,<span class="keyword">uint32_t</span> DataLength)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt; DataLength) &amp;&amp; (*FlashAddress &lt;= (APPLICATION_END_ADDRESS<span class="number">-4</span>)); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Device voltage range supposed to be [2.7V to 3.6V], the operation will</span></span><br><span class="line"><span class="comment">           be done by word */</span> </span><br><span class="line">        <span class="keyword">if</span> (FLASH_ProgramWord(*FlashAddress, *(<span class="keyword">uint32_t</span>*)(Data+i)) == FLASH_COMPLETE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check the written value */</span></span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint32_t</span>*)*FlashAddress != *(<span class="keyword">uint32_t</span>*)(Data+i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Flash content doesn't match SRAM content */</span></span><br><span class="line">                <span class="keyword">return</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Increment FLASH destination address */</span></span><br><span class="line">            *FlashAddress += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Error occurred while writing data in Flash memory */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  STMFLASH_ReadWord</span></span><br><span class="line"><span class="comment">* 功  能 :  读取指定地址的半字(16位数据) </span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  fu32_Addr：读地址 </span></span><br><span class="line"><span class="comment">* 返  回 :  对应数据</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">STMFLASH_ReadWord</span><span class="params">(<span class="keyword">uint32_t</span> fu32_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span>*)fu32_Addr; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  STMFLASH_ReadWord</span></span><br><span class="line"><span class="comment">* 功  能 :  从指定地址开始读出指定长度的数据</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  ReadAddr：起始地址</span></span><br><span class="line"><span class="comment">            pBuffer：数据指针</span></span><br><span class="line"><span class="comment">            NumToRead：读的数据个数</span></span><br><span class="line"><span class="comment">* 返  回 :  对应数据</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_IF_Read</span><span class="params">(<span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> *pBuffer, <span class="keyword">uint32_t</span> NumToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumToRead;i++)</span><br><span class="line">&#123;</span><br><span class="line">pBuffer[i] = STMFLASH_ReadWord(ReadAddr);<span class="comment">//读取4个字节.</span></span><br><span class="line">ReadAddr+=<span class="number">4</span>;<span class="comment">//偏移4个字节.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、详细应用实例"><a href="#二、详细应用实例" class="headerlink" title="二、详细应用实例"></a>二、详细应用实例</h1><p>&emsp;&emsp;具体实际应用：基于Xmodem协议的IAP升级，可以看这篇文章：<a href="https://shatang.github.io/2020/08/12/IAP%E5%8D%87%E7%BA%A7-Bootloader%E5%88%B6%E4%BD%9C/#more">IAP升级 &amp; Bootloader制作</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;由于嵌入式IAP升级时，制作的Bootloader往往会涉及到Stm32的Flash的一些操作(用于写入App程序)，因此这里讲解一下Stm32的Flash相关操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="bootloader" scheme="http://shatang.github.io/tags/bootloader/"/>
    
      <category term="stm32" scheme="http://shatang.github.io/tags/stm32/"/>
    
      <category term="Flash" scheme="http://shatang.github.io/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验算法原理分析</title>
    <link href="http://shatang.github.io/2020/08/10/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://shatang.github.io/2020/08/10/CRC校验算法原理分析/</id>
    <published>2020-08-10T15:20:22.000Z</published>
    <updated>2020-08-12T13:51:16.820Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里提一下各种通讯协议都经常使用的CRC校验，为后面的知识做铺垫。</p><a id="more"></a><h1 id="一、CRC分析"><a href="#一、CRC分析" class="headerlink" title="一、CRC分析"></a>一、CRC分析</h1><p>&emsp;&emsp;我只是把网上能搜到的资料根据自己的理解重新写了一遍，本文大部分内容都来自于下面的两位博主:</p><p>wchonline  ， <a href="https://www.cnblogs.com/wchonline/p/11698677.html" target="_blank" rel="noopener">CRC校验算法详解</a><br>偏执灬  ， <a href="https://blog.csdn.net/sinat_23338865/java/article/details/73549076" target="_blank" rel="noopener">CRC校验算法原理分析</a></p><h2 id="1-1-数据校验"><a href="#1-1-数据校验" class="headerlink" title="1.1 数据校验"></a>1.1 数据校验</h2><p>&emsp;&emsp;数据在传输过程（比如通过网线在两台计算机间传文件）中，由于传输信道的原因，可能会有误码现象（比如说发送数字5但接收方收到的却是6），如何发现误码呢？方法是发送额外的数据让接收方校验是否正确，这就是数据校验。</p><p>&emsp;&emsp;最容易想到的校验方法是和校验，就是将传送的数据(按字节方式)加起来计算出数据的总和，并将总和传给接收方，接收方收到数据后也计算总和，并与收到的总和比较看是否相同。如果传输中出现误码，那么总和一般不会相同，从而知道有误码产生，可以让发送方再发送一遍数据。</p><h2 id="1-2-CRC校验原理"><a href="#1-2-CRC校验原理" class="headerlink" title="1.2 CRC校验原理"></a>1.2 CRC校验原理</h2><p>&emsp;&emsp;CRC(Cyclic Redundancy Check)循环冗余校验是常用的数据校验方法。CRC校验码的基本思想是利用线性编码理论， 在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的监督码（既CRC码）r位，并附在信息后边，构成一个新的二进制码序列数共(k+r)位，最后发送出去。在接收端，则根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错，在数据存储和数据通讯领域常用。</p><h2 id="1-3-CRC多项式-理解就行"><a href="#1-3-CRC多项式-理解就行" class="headerlink" title="1.3 CRC多项式(理解就行)"></a>1.3 CRC多项式(理解就行)</h2><p>&emsp;&emsp;一般在数据传输之前，发送端与接收端会相互约定好一个除数（也是一个二进制序列，用来进行模2除法）。这个除数就是生成多项式。</p><p><strong><font color="red">Ps：</font></strong> 这个多项式的最高位和最低位必须为1</p><p>&emsp;&emsp;生成多项式的选择是 CRC 算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。</p><p>&emsp;&emsp;在构建一个新的 CRC 多项式或者改进现有的 CRC 时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。</p><ul><li>生成多项式的最高位和最低位必须为1。</li><li>当被传送信息（CRC码）任何一位发生错误时，被生成多项式做模2除后，应该使余数不为0。</li><li>不同位发生错误时，应该使余数不同。</li><li>对余数继续做模2除，应使余数循环。</li></ul><h2 id="1-4-CRC校验简单理解-要点"><a href="#1-4-CRC校验简单理解-要点" class="headerlink" title="1.4 CRC校验简单理解(要点)"></a>1.4 CRC校验简单理解(要点)</h2><p>&emsp;&emsp;在数据传输之前，发送方与接收方会相互约定好一个除数（多项式，进行模2算法）。</p><ul><li>发送方：生成CRC校验码。<strong>CRC校验码就是将数据除以某个固定的数（比如ANSI-CRC16中，这个数是0x18005），所得到的余数就是CRC校验码。</strong></li><li>接收方：接收到数据包+CRC校验码。由于CRC校验码是之前发送方求余出来的数据，将数据包+CRC校验码合并后再进行模2除法校验，理论上余数为0。如果是余数不为0，说明了传输的数据错误。</li><li>因此，不同协议的CRC校验码基本不一样，因为约定的除数会根据自己协议制定(例如Modbus通讯)。</li></ul><hr><p>&emsp;&emsp;如果被除数比除数小，那么余数就是被除数本身，比如说只要传一个字节，那么它的CRC就是它自己，为避免这种情况，<strong>在做除法之前先将它移位，使它大于除数</strong>，那么移多少位呢？这就与所选的固定除数有关了，左移位数比除数的位数少1。</p><p>&emsp;&emsp;关于模2除法中除数的选择，这个可以自己随意选择。但由 1.3 可知，随意选择的除数会导致帧校验的<br>正确率下降，这是不确定的，要看你选择的除数。而我们一般的除数的选择是直接去参照一些专家讲过<br>多次试验下来的一些除数，这些除法能极大的保证帧校验的正确率。</p><p>&emsp;&emsp;一般而言，crc8校验的错误率为1/256(最小单元)，crc16校验的错误率为1/65536(最小单元)，crc32校验的错误率为1/2^32(最小单元)。CRC16的错误率已经是非常小了，所以一般在数据不多的情况下用CRC16校验就可以了，而在整个文件的校验中一般用CRC32校验。</p><hr><p>下面是常用标准中的除数：</p><blockquote><p>通用CRC多项式</p></blockquote><p>&emsp;&emsp;由1.3上面要求罗列出常用的多项式如下：</p><ul><li>CRC8-Dallas/Maxim：多项式是X8+X5+X4+1，对应的数字是0x131，左移8位</li><li>CRC8-ATM：多项式是 X8+X2+X1+1，对应的数字是0x107（0x07），左移8位</li><li>CRC8-CCITT：多项式是 X8+X6+X4+X3+X2+X1，对应的数字是0x15E（0x5E），左移8位</li><li>CRC12：多项式是 X12+X11+X3+X2+1，对应的数字是0x180D，左移12位</li><li>CRC16-CCITT：多项式是 X16+X12+X5+1，对应的数字是0x11021，左移16位</li><li>CRC16-ANSI ：多项式是 X16+X15+X2+1，对应的数字是0x18005，左移16位</li><li>CRC32：多项式是X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+1，对应数字是0x104C11DB7，左移32位</li></ul><p>因此，在得到字节串对应的数字后，再将数字左移M位（比如ANSI-CRC16是左移16位），就得到了被除数。</p><p><strong><font color="red">Ps：</font></strong> 由于多项式的最高为都为1，但在代码实现的crc计算中，最高位是不使用的；使用的是上面例子中括号内的值</p><p>&emsp;&emsp;从上面可以看到，即使是同为CRC8校验，多项式也有多种；因此计算CRC校验要格外注意多项式是否相同。不同的多项式，起检错能力是不同的。<strong>例如Modbus协议就规定 0xA001 就是它CRC校验的多项式。</strong></p><h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><p>&emsp;&emsp;算术上的除法，计算机当然会做，但因为减法有借位，很耗时间和指令!所以，计算CRC是除法，但是用XOR来代替减法。除法（XOR）的目的是逐步消掉二进制数最高位的1或0！由于过程是XOR的，所以商是没有意义的，我们不要。我们要的是余数。 </p><h2 id="2-1-顺序异或-amp-反序异或"><a href="#2-1-顺序异或-amp-反序异或" class="headerlink" title="2.1 顺序异或 &amp; 反序异或"></a>2.1 顺序异或 &amp; 反序异或</h2><p>&emsp;&emsp;CRC校验算法，就是把需要校验的数据与多项式进行循环异或（XOR），但进行XOR的方式与实际中数据传输时，是高位先传、还是低位先传有关。对于数据高位先传的方式，XOR从数据的高位开始，我们就叫它顺序异或吧；对于数据低位先传的方式，XOR从数据的低位开始，我们就叫它反序异或吧。两种不同的异或方式，即使对应相同的多项式，计算出来的结果也是不一样的。</p><p>&emsp;&emsp;比如前面ccitt-crc16的正序是0x1021，如果是反转就是0x8408（就是将0x1021倒过来低位变高位）。数据传输可能是先传低位再传高位（比如串口就是低位在前高位在后）。反转的CRC算法与正序类似，只是需要注意移位的方向相反。</p><p>&emsp;&emsp;这个问题一般不是问题。因为如果是自己写的发送方，当然是可以随便写！(开玩笑的)。如果是写接收方，发送方要么会给详细说明，或者有源码，直接搬迁过来就行了。</p><h2 id="2-2-代码例子"><a href="#2-2-代码例子" class="headerlink" title="2.2 代码例子"></a>2.2 代码例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_table_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i, crc;</span><br><span class="line"></span><br><span class="line">    crc = value;</span><br><span class="line">    <span class="comment">/* 数据往左移了8位，需要计算8次 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)  <span class="comment">/* 判断最高位是否为1 */</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* 最高位为1，不需要异或，往左移一位，然后与0x31异或 */</span></span><br><span class="line">        <span class="comment">/* 0x31(多项式：x8+x5+x4+1，100110001)，最高位不需要异或，直接去掉 */</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 最高位为0时，不需要异或，整体数据往左移一位 */</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-CRC校验表"><a href="#2-3-CRC校验表" class="headerlink" title="2.3 CRC校验表"></a>2.3 CRC校验表</h2><p>&emsp;&emsp;2.2的代码计算一个字节的crc结果，如果计算多个字节的结果也是比较简单的，先计算第一个字节的crc结果，然后把第一个字节的crc结果与第二个字节进行异或，异或后的值再进行一次crc计算就可以了，多个字节也是反复这过程就好。</p><p>&emsp;&emsp;但是需要的运行量也是不少的，每一个字节都需要进行8次判断、移位、或异或操作。但是其实每个字节异或的结果是一定的，那就可以事先算好的CRC存入数组。采用查表法，大大减少计算量，先计算出 0x00~0xFF 每一个字节的crc校验结果，后面就可以通过表来查出每个字节的crc结果，大大 减少计算量。</p><p>下面是一个表生成程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=<span class="number">0xFF</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i%<span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        j = i&amp;<span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, cal_table_high_first (j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的表整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> crc_table[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x62</span>,<span class="number">0x53</span>,<span class="number">0xc4</span>,<span class="number">0xf5</span>,<span class="number">0xa6</span>,<span class="number">0x97</span>,<span class="number">0xb9</span>,<span class="number">0x88</span>,<span class="number">0xdb</span>,<span class="number">0xea</span>,<span class="number">0x7d</span>,<span class="number">0x4c</span>,<span class="number">0x1f</span>,<span class="number">0x2e</span>,</span><br><span class="line">    <span class="number">0x43</span>,<span class="number">0x72</span>,<span class="number">0x21</span>,<span class="number">0x10</span>,<span class="number">0x87</span>,<span class="number">0xb6</span>,<span class="number">0xe5</span>,<span class="number">0xd4</span>,<span class="number">0xfa</span>,<span class="number">0xcb</span>,<span class="number">0x98</span>,<span class="number">0xa9</span>,<span class="number">0x3e</span>,<span class="number">0x0f</span>,<span class="number">0x5c</span>,<span class="number">0x6d</span>,</span><br><span class="line">    <span class="number">0x86</span>,<span class="number">0xb7</span>,<span class="number">0xe4</span>,<span class="number">0xd5</span>,<span class="number">0x42</span>,<span class="number">0x73</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x3f</span>,<span class="number">0x0e</span>,<span class="number">0x5d</span>,<span class="number">0x6c</span>,<span class="number">0xfb</span>,<span class="number">0xca</span>,<span class="number">0x99</span>,<span class="number">0xa8</span>,</span><br><span class="line">    <span class="number">0xc5</span>,<span class="number">0xf4</span>,<span class="number">0xa7</span>,<span class="number">0x96</span>,<span class="number">0x01</span>,<span class="number">0x30</span>,<span class="number">0x63</span>,<span class="number">0x52</span>,<span class="number">0x7c</span>,<span class="number">0x4d</span>,<span class="number">0x1e</span>,<span class="number">0x2f</span>,<span class="number">0xb8</span>,<span class="number">0x89</span>,<span class="number">0xda</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x3d</span>,<span class="number">0x0c</span>,<span class="number">0x5f</span>,<span class="number">0x6e</span>,<span class="number">0xf9</span>,<span class="number">0xc8</span>,<span class="number">0x9b</span>,<span class="number">0xaa</span>,<span class="number">0x84</span>,<span class="number">0xb5</span>,<span class="number">0xe6</span>,<span class="number">0xd7</span>,<span class="number">0x40</span>,<span class="number">0x71</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,</span><br><span class="line">    <span class="number">0x7e</span>,<span class="number">0x4f</span>,<span class="number">0x1c</span>,<span class="number">0x2d</span>,<span class="number">0xba</span>,<span class="number">0x8b</span>,<span class="number">0xd8</span>,<span class="number">0xe9</span>,<span class="number">0xc7</span>,<span class="number">0xf6</span>,<span class="number">0xa5</span>,<span class="number">0x94</span>,<span class="number">0x03</span>,<span class="number">0x32</span>,<span class="number">0x61</span>,<span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0xbb</span>,<span class="number">0x8a</span>,<span class="number">0xd9</span>,<span class="number">0xe8</span>,<span class="number">0x7f</span>,<span class="number">0x4e</span>,<span class="number">0x1d</span>,<span class="number">0x2c</span>,<span class="number">0x02</span>,<span class="number">0x33</span>,<span class="number">0x60</span>,<span class="number">0x51</span>,<span class="number">0xc6</span>,<span class="number">0xf7</span>,<span class="number">0xa4</span>,<span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0xf8</span>,<span class="number">0xc9</span>,<span class="number">0x9a</span>,<span class="number">0xab</span>,<span class="number">0x3c</span>,<span class="number">0x0d</span>,<span class="number">0x5e</span>,<span class="number">0x6f</span>,<span class="number">0x41</span>,<span class="number">0x70</span>,<span class="number">0x23</span>,<span class="number">0x12</span>,<span class="number">0x85</span>,<span class="number">0xb4</span>,<span class="number">0xe7</span>,<span class="number">0xd6</span>,</span><br><span class="line">    <span class="number">0x7a</span>,<span class="number">0x4b</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0xbe</span>,<span class="number">0x8f</span>,<span class="number">0xdc</span>,<span class="number">0xed</span>,<span class="number">0xc3</span>,<span class="number">0xf2</span>,<span class="number">0xa1</span>,<span class="number">0x90</span>,<span class="number">0x07</span>,<span class="number">0x36</span>,<span class="number">0x65</span>,<span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x39</span>,<span class="number">0x08</span>,<span class="number">0x5b</span>,<span class="number">0x6a</span>,<span class="number">0xfd</span>,<span class="number">0xcc</span>,<span class="number">0x9f</span>,<span class="number">0xae</span>,<span class="number">0x80</span>,<span class="number">0xb1</span>,<span class="number">0xe2</span>,<span class="number">0xd3</span>,<span class="number">0x44</span>,<span class="number">0x75</span>,<span class="number">0x26</span>,<span class="number">0x17</span>,</span><br><span class="line">    <span class="number">0xfc</span>,<span class="number">0xcd</span>,<span class="number">0x9e</span>,<span class="number">0xaf</span>,<span class="number">0x38</span>,<span class="number">0x09</span>,<span class="number">0x5a</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x74</span>,<span class="number">0x27</span>,<span class="number">0x16</span>,<span class="number">0x81</span>,<span class="number">0xb0</span>,<span class="number">0xe3</span>,<span class="number">0xd2</span>,</span><br><span class="line">    <span class="number">0xbf</span>,<span class="number">0x8e</span>,<span class="number">0xdd</span>,<span class="number">0xec</span>,<span class="number">0x7b</span>,<span class="number">0x4a</span>,<span class="number">0x19</span>,<span class="number">0x28</span>,<span class="number">0x06</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0xf3</span>,<span class="number">0xa0</span>,<span class="number">0x91</span>,</span><br><span class="line">    <span class="number">0x47</span>,<span class="number">0x76</span>,<span class="number">0x25</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xd0</span>,<span class="number">0xfe</span>,<span class="number">0xcf</span>,<span class="number">0x9c</span>,<span class="number">0xad</span>,<span class="number">0x3a</span>,<span class="number">0x0b</span>,<span class="number">0x58</span>,<span class="number">0x69</span>,</span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x35</span>,<span class="number">0x66</span>,<span class="number">0x57</span>,<span class="number">0xc0</span>,<span class="number">0xf1</span>,<span class="number">0xa2</span>,<span class="number">0x93</span>,<span class="number">0xbd</span>,<span class="number">0x8c</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x79</span>,<span class="number">0x48</span>,<span class="number">0x1b</span>,<span class="number">0x2a</span>,</span><br><span class="line">    <span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xa3</span>,<span class="number">0x92</span>,<span class="number">0x05</span>,<span class="number">0x34</span>,<span class="number">0x67</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0x49</span>,<span class="number">0x1a</span>,<span class="number">0x2b</span>,<span class="number">0xbc</span>,<span class="number">0x8d</span>,<span class="number">0xde</span>,<span class="number">0xef</span>,</span><br><span class="line">    <span class="number">0x82</span>,<span class="number">0xb3</span>,<span class="number">0xe0</span>,<span class="number">0xd1</span>,<span class="number">0x46</span>,<span class="number">0x77</span>,<span class="number">0x24</span>,<span class="number">0x15</span>,<span class="number">0x3b</span>,<span class="number">0x0a</span>,<span class="number">0x59</span>,<span class="number">0x68</span>,<span class="number">0xff</span>,<span class="number">0xce</span>,<span class="number">0x9d</span>,<span class="number">0xac</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>采用查表法计算crc代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_crc_table</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr, <span class="keyword">unsigned</span> <span class="keyword">char</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  crc = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">    &#123;</span><br><span class="line">        crc = crc_table[crc ^ *ptr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-反序异或计算的代码"><a href="#2-4-反序异或计算的代码" class="headerlink" title="2.4 反序异或计算的代码"></a>2.4 反序异或计算的代码</h2><p>&emsp;&emsp;反序异或与顺序异或差异在数据先判断最低位，并且数据是向右移的，并且多项式数据位需要高低位反转一下。还是以多项式：x8+x5+x4+1（二进制为：100110001）为例：则计算一个字节的crc校验代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_table_low_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i, crc;</span><br><span class="line"></span><br><span class="line">    crc = value;</span><br><span class="line">    <span class="comment">/* 同样需要计算8次 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x01</span>)  <span class="comment">/* 反序异或变成判断最低位是否为1 */</span></span><br><span class="line">            <span class="comment">/* 数据变成往右移位了 */</span></span><br><span class="line">            <span class="comment">/* 计算的多项式从0x31（0011 0001）变成了0x8C (1000 1100) */</span></span><br><span class="line">    <span class="comment">/* 多项式值，原来的最高位变成了最低位，原来的最低位变成最高位，8位数据高低位交换一下位置 */</span></span><br><span class="line">            crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、例程：Modbus的CRC16校验"><a href="#三、例程：Modbus的CRC16校验" class="headerlink" title="三、例程：Modbus的CRC16校验"></a>三、例程：Modbus的CRC16校验</h1><p>&emsp;&emsp;代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> UCHAR aucCRCHi[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> UCHAR aucCRCLo[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x01</span>, <span class="number">0xC3</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0xC2</span>, <span class="number">0xC6</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>,</span><br><span class="line">    <span class="number">0x05</span>, <span class="number">0xC5</span>, <span class="number">0xC4</span>, <span class="number">0x04</span>, <span class="number">0xCC</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0xCD</span>, <span class="number">0x0F</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0x0E</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0x0B</span>, <span class="number">0xC9</span>, <span class="number">0x09</span>, <span class="number">0x08</span>, <span class="number">0xC8</span>, <span class="number">0xD8</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0xD9</span>,</span><br><span class="line">    <span class="number">0x1B</span>, <span class="number">0xDB</span>, <span class="number">0xDA</span>, <span class="number">0x1A</span>, <span class="number">0x1E</span>, <span class="number">0xDE</span>, <span class="number">0xDF</span>, <span class="number">0x1F</span>, <span class="number">0xDD</span>, <span class="number">0x1D</span>, <span class="number">0x1C</span>, <span class="number">0xDC</span>,</span><br><span class="line">    <span class="number">0x14</span>, <span class="number">0xD4</span>, <span class="number">0xD5</span>, <span class="number">0x15</span>, <span class="number">0xD7</span>, <span class="number">0x17</span>, <span class="number">0x16</span>, <span class="number">0xD6</span>, <span class="number">0xD2</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0xD3</span>,</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0xD1</span>, <span class="number">0xD0</span>, <span class="number">0x10</span>, <span class="number">0xF0</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0xF3</span>, <span class="number">0xF2</span>, <span class="number">0x32</span>,</span><br><span class="line">    <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0x37</span>, <span class="number">0xF5</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0xF4</span>, <span class="number">0x3C</span>, <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0x3D</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0xFE</span>, <span class="number">0xFA</span>, <span class="number">0x3A</span>, <span class="number">0x3B</span>, <span class="number">0xFB</span>, <span class="number">0x39</span>, <span class="number">0xF9</span>, <span class="number">0xF8</span>, <span class="number">0x38</span>, </span><br><span class="line">    <span class="number">0x28</span>, <span class="number">0xE8</span>, <span class="number">0xE9</span>, <span class="number">0x29</span>, <span class="number">0xEB</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0xEA</span>, <span class="number">0xEE</span>, <span class="number">0x2E</span>, <span class="number">0x2F</span>, <span class="number">0xEF</span>,</span><br><span class="line">    <span class="number">0x2D</span>, <span class="number">0xED</span>, <span class="number">0xEC</span>, <span class="number">0x2C</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0xE5</span>, <span class="number">0x27</span>, <span class="number">0xE7</span>, <span class="number">0xE6</span>, <span class="number">0x26</span>,</span><br><span class="line">    <span class="number">0x22</span>, <span class="number">0xE2</span>, <span class="number">0xE3</span>, <span class="number">0x23</span>, <span class="number">0xE1</span>, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">0xE0</span>, <span class="number">0xA0</span>, <span class="number">0x60</span>, <span class="number">0x61</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0xA3</span>, <span class="number">0xA2</span>, <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0x67</span>, <span class="number">0xA5</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0xA4</span>,</span><br><span class="line">    <span class="number">0x6C</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0x6D</span>, <span class="number">0xAF</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0xAE</span>, <span class="number">0xAA</span>, <span class="number">0x6A</span>, <span class="number">0x6B</span>, <span class="number">0xAB</span>, </span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0xA9</span>, <span class="number">0xA8</span>, <span class="number">0x68</span>, <span class="number">0x78</span>, <span class="number">0xB8</span>, <span class="number">0xB9</span>, <span class="number">0x79</span>, <span class="number">0xBB</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0xBA</span>,</span><br><span class="line">    <span class="number">0xBE</span>, <span class="number">0x7E</span>, <span class="number">0x7F</span>, <span class="number">0xBF</span>, <span class="number">0x7D</span>, <span class="number">0xBD</span>, <span class="number">0xBC</span>, <span class="number">0x7C</span>, <span class="number">0xB4</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0xB5</span>,</span><br><span class="line">    <span class="number">0x77</span>, <span class="number">0xB7</span>, <span class="number">0xB6</span>, <span class="number">0x76</span>, <span class="number">0x72</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0x73</span>, <span class="number">0xB1</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x51</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x92</span>, <span class="number">0x96</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x97</span>,</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x95</span>, <span class="number">0x94</span>, <span class="number">0x54</span>, <span class="number">0x9C</span>, <span class="number">0x5C</span>, <span class="number">0x5D</span>, <span class="number">0x9D</span>, <span class="number">0x5F</span>, <span class="number">0x9F</span>, <span class="number">0x9E</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5A</span>, <span class="number">0x9A</span>, <span class="number">0x9B</span>, <span class="number">0x5B</span>, <span class="number">0x99</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x98</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x4B</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x4A</span>, <span class="number">0x4E</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x4F</span>, <span class="number">0x8D</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x8C</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0x87</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x83</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x81</span>, <span class="number">0x80</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USHORT</span><br><span class="line">usMBCRC16( UCHAR * pucFrame, USHORT usLen )</span><br><span class="line">&#123;</span><br><span class="line">    UCHAR           ucCRCHi = <span class="number">0xFF</span>;</span><br><span class="line">    UCHAR           ucCRCLo = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">int</span>             iIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( usLen-- )</span><br><span class="line">    &#123;</span><br><span class="line">        iIndex = ucCRCLo ^ *( pucFrame++ );</span><br><span class="line">        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );</span><br><span class="line">        ucCRCHi = aucCRCLo[iIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ( USHORT )( ucCRCHi &lt;&lt; <span class="number">8</span> | ucCRCLo );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里提一下各种通讯协议都经常使用的CRC校验，为后面的知识做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="校验" scheme="http://shatang.github.io/tags/%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>128个字符的ASCII码表</title>
    <link href="http://shatang.github.io/2020/06/28/128%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84ASCII%E7%A0%81%E8%A1%A8/"/>
    <id>http://shatang.github.io/2020/06/28/128个字符的ASCII码表/</id>
    <published>2020-06-28T02:02:43.000Z</published>
    <updated>2020-06-28T02:11:37.541Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里复习、细讲ASCII码表，为后面的知识做铺垫。</p><a id="more"></a><h1 id="一、128个字符的ASCII码表"><a href="#一、128个字符的ASCII码表" class="headerlink" title="一、128个字符的ASCII码表"></a>一、128个字符的ASCII码表</h1><p>&emsp;&emsp;重新认识一下128字符的ASCII码表。<strong>基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。</strong></p><table><thead><tr><th>Dec</th><th>Hex</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>1</td><td>01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>2</td><td>02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>3</td><td>03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>4</td><td>04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>5</td><td>05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>6</td><td>06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>7</td><td>07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>8</td><td>08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>9</td><td>09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>10</td><td>0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>11</td><td>0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>12</td><td>0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>13</td><td>0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>14</td><td>0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>15</td><td>0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>16</td><td>10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>17</td><td>11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>18</td><td>12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>19</td><td>13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>20</td><td>14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>21</td><td>15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>22</td><td>16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>23</td><td>17</td><td>ETB (end of trans. block)</td><td>传输块结束</td></tr><tr><td>24</td><td>18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>25</td><td>19</td><td>EM (end of medium)</td><td>介质中断</td></tr><tr><td>26</td><td>1A</td><td>SUB (substitute)</td><td>替补</td></tr><tr><td>27</td><td>1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>28</td><td>1C</td><td>FS (file separator)</td><td>文件分割符</td></tr><tr><td>29</td><td>1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>30</td><td>1E</td><td>RS (record separator)</td><td>记录分离符</td></tr><tr><td>31</td><td>1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>32</td><td>20</td><td>(space)</td><td>空格</td></tr><tr><td>33</td><td>21</td><td>!</td><td></td></tr><tr><td>34</td><td>22</td><td>“</td><td></td></tr><tr><td>35</td><td>23</td><td>#</td><td></td></tr><tr><td>36</td><td>24</td><td>$</td><td></td></tr><tr><td>37</td><td>25</td><td>%</td><td></td></tr><tr><td>38</td><td>26</td><td>&amp;</td><td></td></tr><tr><td>39</td><td>27</td><td>‘</td><td></td></tr><tr><td>40</td><td>28</td><td>(</td><td></td></tr><tr><td>41</td><td>29</td><td>)</td><td></td></tr><tr><td>42</td><td>2A</td><td>*</td><td></td></tr><tr><td>43</td><td>2B</td><td>+</td><td></td></tr><tr><td>44</td><td>2C</td><td>,</td><td></td></tr><tr><td>45</td><td>2D</td><td>-</td><td></td></tr><tr><td>46</td><td>2E</td><td>.</td><td></td></tr><tr><td>47</td><td>2F</td><td>/</td><td></td></tr><tr><td>48</td><td>30</td><td>0</td><td></td></tr><tr><td>49</td><td>31</td><td>1</td><td></td></tr><tr><td>50</td><td>32</td><td>2</td><td></td></tr><tr><td>51</td><td>33</td><td>3</td><td></td></tr><tr><td>52</td><td>34</td><td>4</td><td></td></tr><tr><td>53</td><td>35</td><td>5</td><td></td></tr><tr><td>54</td><td>36</td><td>6</td><td></td></tr><tr><td>55</td><td>37</td><td>7</td><td></td></tr><tr><td>56</td><td>38</td><td>8</td><td></td></tr><tr><td>57</td><td>39</td><td>9</td><td></td></tr><tr><td>58</td><td>3A</td><td>:</td><td></td></tr><tr><td>59</td><td>3B</td><td>;</td><td></td></tr><tr><td>60</td><td>3C</td><td>&lt;</td><td></td></tr><tr><td>61</td><td>3D</td><td>=</td><td></td></tr><tr><td>62</td><td>3E</td><td>&gt;</td><td></td></tr><tr><td>63</td><td>3F</td><td>?</td><td></td></tr><tr><td>64</td><td>40</td><td>@</td><td></td></tr><tr><td>65</td><td>41</td><td>A</td><td></td></tr><tr><td>66</td><td>42</td><td>B</td><td></td></tr><tr><td>67</td><td>43</td><td>C</td><td></td></tr><tr><td>68</td><td>44</td><td>D</td><td></td></tr><tr><td>69</td><td>45</td><td>E</td><td></td></tr><tr><td>70</td><td>46</td><td>F</td><td></td></tr><tr><td>71</td><td>47</td><td>G</td><td></td></tr><tr><td>72</td><td>48</td><td>H</td><td></td></tr><tr><td>73</td><td>49</td><td>I</td><td></td></tr><tr><td>74</td><td>4A</td><td>J</td><td></td></tr><tr><td>75</td><td>4B</td><td>K</td><td></td></tr><tr><td>76</td><td>4C</td><td>L</td><td></td></tr><tr><td>77</td><td>4D</td><td>M</td><td></td></tr><tr><td>78</td><td>4E</td><td>N</td><td></td></tr><tr><td>79</td><td>4F</td><td>O</td><td></td></tr><tr><td>80</td><td>50</td><td>P</td><td></td></tr><tr><td>81</td><td>51</td><td>Q</td><td></td></tr><tr><td>82</td><td>52</td><td>R</td><td></td></tr><tr><td>83</td><td>53</td><td>S</td><td></td></tr><tr><td>84</td><td>54</td><td>T</td><td></td></tr><tr><td>85</td><td>55</td><td>U</td><td></td></tr><tr><td>86</td><td>56</td><td>V</td><td></td></tr><tr><td>87</td><td>57</td><td>W</td><td></td></tr><tr><td>88</td><td>58</td><td>X</td><td></td></tr><tr><td>89</td><td>59</td><td>Y</td><td></td></tr><tr><td>90</td><td>5A</td><td>Z</td><td></td></tr><tr><td>91</td><td>5B</td><td>[</td><td></td></tr><tr><td>92</td><td>5C</td><td>\</td><td></td></tr><tr><td>93</td><td>5D</td><td>]</td><td></td></tr><tr><td>94</td><td>5E</td><td>^</td><td></td></tr><tr><td>95</td><td>5F</td><td>_</td><td></td></tr><tr><td>96</td><td>60</td><td>`</td><td></td></tr><tr><td>97</td><td>61</td><td>a</td><td></td></tr><tr><td>98</td><td>62</td><td>b</td><td></td></tr><tr><td>99</td><td>63</td><td>c</td><td></td></tr><tr><td>100</td><td>64</td><td>d</td><td></td></tr><tr><td>101</td><td>65</td><td>e</td><td></td></tr><tr><td>102</td><td>66</td><td>f</td><td></td></tr><tr><td>103</td><td>67</td><td>g</td><td></td></tr><tr><td>104</td><td>68</td><td>h</td><td></td></tr><tr><td>105</td><td>69</td><td>i</td><td></td></tr><tr><td>106</td><td>6A</td><td>j</td><td></td></tr><tr><td>107</td><td>6B</td><td>k</td><td></td></tr><tr><td>108</td><td>6C</td><td>l</td><td></td></tr><tr><td>109</td><td>6D</td><td>m</td><td></td></tr><tr><td>110</td><td>6E</td><td>n</td><td></td></tr><tr><td>111</td><td>6F</td><td>o</td><td></td></tr><tr><td>112</td><td>70</td><td>p</td><td></td></tr><tr><td>113</td><td>71</td><td>q</td><td></td></tr><tr><td>114</td><td>72</td><td>r</td><td></td></tr><tr><td>115</td><td>73</td><td>s</td><td></td></tr><tr><td>116</td><td>74</td><td>t</td><td></td></tr><tr><td>117</td><td>75</td><td>u</td><td></td></tr><tr><td>118</td><td>76</td><td>v</td><td></td></tr><tr><td>119</td><td>77</td><td>w</td><td></td></tr><tr><td>120</td><td>78</td><td>x</td><td></td></tr><tr><td>121</td><td>79</td><td>y</td><td></td></tr><tr><td>122</td><td>7A</td><td>z</td><td></td></tr><tr><td>123</td><td>7B</td><td>{</td><td></td></tr><tr><td>124</td><td>7C</td><td>|</td><td></td></tr><tr><td>125</td><td>7D</td><td>}</td><td></td></tr><tr><td>126</td><td>7E</td><td>~</td><td></td></tr><tr><td>127</td><td>7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><h1 id="二、ASCII码表带来的现象"><a href="#二、ASCII码表带来的现象" class="headerlink" title="二、ASCII码表带来的现象"></a>二、ASCII码表带来的现象</h1><h2 id="2-1-Modbus协议模式选择"><a href="#2-1-Modbus协议模式选择" class="headerlink" title="2.1 Modbus协议模式选择"></a>2.1 Modbus协议模式选择</h2><p>&emsp;&emsp;在Modbus通讯协议中，分为RTU &amp; ASCII 模式。在底层的串口配置中，RTU模式只能配置 8-e-1，8-o-1,8-n-1的8位数据位；而ASCII模式不仅可以配置以上的模式，还可以配置7-e-1，7-o-1，7-n-1。</p><p>这里的原因，就是因为ASCII基本码就是128个，完全(刚好)能用7个bit来表示。而RTU发送十六进制的数据，则需要8个bit(0xff)，被去掉了一位，因为是不支持7位的数据位发送。</p><p>&emsp;&emsp;这里又暗示了串口的一个理解上的误区。<strong>串口发送的最小单位</strong>和<strong>数据帧的最小单位</strong>。假如串口模式是7位的数据位，你发的是数据基本单位是0xff(8bit)；例如你发 0xff 0x12 0x34 ，此时串口会截取掉高位，只发每个数据单元的7bit。不会说这先发这个数据的7bit，多出来的 1bit 下次再填进去补给你(下次一定)。</p><h2 id="2-2-中文字符乱码"><a href="#2-2-中文字符乱码" class="headerlink" title="2.2 中文字符乱码"></a>2.2 中文字符乱码</h2><p>&emsp;&emsp;从上面延伸出来的串口发送知识误区，得到一种 中文字符乱码 的现象。假如一个产品，有中英文，可以通过串口打印出数据；你会发现一旦串口配置为7位数据位，英文版本打印正常，而中文版本打印异常。</p><p>这就是因为汉字是双字的，拆分出来两个8bit(0xff)，假如串口使用7位的数据位，就会截取掉高位；而英文是ASCII，只需要7bit，因此英文显示正常。</p><h2 id="2-3-对字符的解析"><a href="#2-3-对字符的解析" class="headerlink" title="2.3 对字符的解析"></a>2.3 对字符的解析</h2><p>&emsp;&emsp;常见于几种情况，举例如下：</p><ol><li>制作裸机不带enwin的嵌入式led驱动</li><li>与GSM模块等通讯</li><li>通讯协议的数据包的识别区分(例如X-modem协议)</li></ol><hr><p>&emsp;&emsp;led驱动的字符显示驱动，把要显示的字符串，截取成逐个的字符，做显示；显示会做判断两种情况，:</p><ul><li>*s &lt; 128 , 显示ASCII码库的字符</li><li>*s &gt; 128 , 显示自己写的(汉字)库的字符(汉字双字节 0xffff 明显超过 0x7f)</li></ul><hr><p>&emsp;&emsp;与GSM模块进行通讯配置的时候，而且这种通讯是字符的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)cmd&lt;=<span class="number">0XFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((USART3-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待上一次数据发送完成  </span></span><br><span class="line">        USART3-&gt;DR=(u32)cmd;</span><br><span class="line">    &#125;<span class="keyword">else</span> u3_printf(<span class="string">"%s\r\n"</span>,cmd);<span class="comment">//发送命令</span></span><br></pre></td></tr></table></figure><p>如果是有写过类似GSM模块通讯的，应该都看过类似上面语句。主控发给模块的指令，先分解逐个字符；再根据是否小于0xff，是直接发还是用字符串打印函数。</p><p>&emsp;&emsp;如果是小于0xff，当然是可以用串口8位的数据位进行发送；但是什么时候才会大于0xff，就是该 cmd 非ASCII的时候(而是字符串)，例如汉字。</p><hr><p>&emsp;&emsp;X-modem协议的数据包的识别区分。当利用Xmodem协议进行传输文本文件，因为数据包的结束符 CTRL-Z(0x1A) 不是前128个ascii码中的通用可见字母字符( 0x1A 对应 SUB[替补]，非文本文件的字符 )。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里复习、细讲ASCII码表，为后面的知识做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符编码" scheme="http://shatang.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>大数据割韭菜法</title>
    <link href="http://shatang.github.io/2020/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%89%B2%E9%9F%AD%E8%8F%9C%E6%B3%95/"/>
    <id>http://shatang.github.io/2020/06/25/大数据割韭菜法/</id>
    <published>2020-06-25T03:37:21.000Z</published>
    <updated>2020-06-25T03:39:59.605Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;现在的大数据杀熟是一件常见的事，更有一些大佬们呕心沥血的算法加持下；我觉得只要数据足够多，那么它就能做到很多匪夷所思、神奇的事情。但是巧妇难为无米之炊，那些数据到底是哪里来的呢？</p><a id="more"></a><p>&emsp;&emsp;以前根据自己的分析，怀疑是输入法、浏览记录导致信息泄漏，进而看见那些广告推送。直到看半佛老师的：<a href="https://www.bilibili.com/video/BV1SC4y1a7k5" target="_blank" rel="noopener">你的手机是如何监控你的</a>，开拓了我不少眼界，例如唤醒监控、推送SDK同家公司等，也让我对其更深的理解。</p><h1 id="一、半佛老师的视频笔记总结"><a href="#一、半佛老师的视频笔记总结" class="headerlink" title="一、半佛老师的视频笔记总结"></a>一、半佛老师的视频笔记总结</h1><h2 id="1-1-信息泄漏基本不会来源于录音，但是会识别关键词"><a href="#1-1-信息泄漏基本不会来源于录音，但是会识别关键词" class="headerlink" title="1.1 信息泄漏基本不会来源于录音，但是会识别关键词"></a>1.1 信息泄漏基本不会来源于录音，但是会识别关键词</h2><ul><li>信息泄漏基本不会来源于(手机)录音：效率低，利润低，误差率高，成本高<ul><li>(某APP)持续录音，会对手机内存的占用；现象：发热，卡，且容易被杀掉进程和检测出来</li><li>录下来的音频存放点。存放本地存储，长时间占用太大；将其使用流量上传，但流量并非免费</li><li>将其录下来的音频转换成文字保存或直接上传，则会遇到下面问题：语音识别误差率大</li><li>语音识别误差率大，分辨不出是谁在讲话，而且语音不标准(即口音)。还有语义问题，不同场景，同一句湖就是不同意思</li></ul></li><li>不做录音。但是真的有时候就是没有浏览只是日常讲话提及，随之会出现在广告推送。<ul><li>通过特定的关键词唤醒监控。<ul><li>常见的唤醒方案：小爱，siri。所以有些app要求录音权限 ，可用于唤醒监控</li></ul></li><li>只做关键词，无论是直接上传还是识别度都是操作相对简单很多</li></ul></li></ul><p><strong><font color="red">Ps：</font></strong> 注意手机的App，对其录音的权限是否关闭</p><h2 id="1-2-输入法"><a href="#1-2-输入法" class="headerlink" title="1.2 输入法"></a>1.2 输入法</h2><ul><li>输入法，只要打字，就离不开输入法。<ul><li>纯文本的语意分析，那可是相对成熟的技术。</li><li>另外所有的输入法都是越用月好用，越用越懂你。</li><li>那么，到底是怎么懂你的呢？当你在触摸方便之门的时候，方便也在触摸着你</li></ul></li></ul><p><strong><font color="red">Ps：</font></strong> 建议关闭输入法用户体验计划？最好禁用其联网</p><h2 id="1-3-推送类sdk"><a href="#1-3-推送类sdk" class="headerlink" title="1.3 推送类sdk"></a>1.3 推送类sdk</h2><ul><li>现在各种手机推送大都是专门有公司做成sdk嵌入到各大app里面的，然后专门做推送。<ul><li>做推送的，往往对于各类手机和应用的适配做得比较好；比App自己开发要好用很多。</li><li>所以很多app都是使用外采推送sdk的，不然市面上这么多的手机型号，自己还要一个一个去适配，还要去实验规则。</li><li>假如你手机上有30个app，它可能背后都归属于同一家或者是多家公司提供的推送sdk(<strong>推送类SDK核心威力所在</strong>)</li></ul></li></ul><p>&emsp;&emsp;常见的信息泄漏，最基础的就是：App请求获取你的应用列表。它可以根据你装的App来分析你到底是什么用户；而且有没有同行App之类在里面，再根据结果推荐不同的推荐策略。</p><p>&emsp;&emsp;但是对于推送SDK公司而言，它甚至可以不需要获取你的应用列表，因为你装的App很多都加载了它的推送SDK。你的手机信息是可以被获取的，而且很显然会知道一台手机到底装了哪些app；用户常用那些app，甚至用户对于手机的应用轨迹和应用行为。</p><h2 id="1-4-App的信息收集"><a href="#1-4-App的信息收集" class="headerlink" title="1.4 App的信息收集"></a>1.4 App的信息收集</h2><p>&emsp;&emsp;手机app的信息收集，例如上面的获取手机Applist。举例如下：</p><ul><li>Applist 有 x多多，该用户为价格敏感性</li><li>Applist 有 x哩x哩，可能是个年轻二次元用户</li><li>通过读取applist，该用户有多个同行App，就发大额优惠券拉拢用户；反之垄断则考虑割韭菜</li><li>读取地理位置信息，对应的推荐策略</li></ul><p><strong><font color="red">Ps：</font></strong> 建议尽可能禁掉获取Applist的权限，只留一些基本App</p><h2 id="1-5-浏览记录，搜索记录"><a href="#1-5-浏览记录，搜索记录" class="headerlink" title="1.5 浏览记录，搜索记录"></a>1.5 浏览记录，搜索记录</h2><p>&emsp;&emsp;最表层的，你在pc和手机端app搜索记录。<strong>大家都在收集这些记录，而且很热衷</strong>，都是用来相互交易，明码标价；而且app是绑定手机号的，你的每次搜索记录都会转换成市面的数据包进行交易。</p><p><strong><font color="red">Ps：</font></strong> 无痕浏览只是不保存记录在本地上，网络上是有你的搜索记录的</p><h2 id="1-6-数据糅合推送"><a href="#1-6-数据糅合推送" class="headerlink" title="1.6 数据糅合推送"></a>1.6 数据糅合推送</h2><p>&emsp;&emsp;即使是你尽可能谨慎，少泄漏信息；但是有时候你就是能收到贴心的广告推送。这个推荐策略，并非来自你的信息泄漏，而是周边人信息的泄漏。只要你周边的信息足够多，就能够反推出对你的推荐策略。</p><p>&emsp;&emsp;例如你是小明，那么你的广告推送有部分决策来源于，小明朋友的相关数据、小明小红父母的相关数据。例如小红怀孕，搜索母婴用品；自然小明那边就可能推送母婴用品等的广告。</p><h1 id="二、我的经历和看法"><a href="#二、我的经历和看法" class="headerlink" title="二、我的经历和看法"></a>二、我的经历和看法</h1><h2 id="2-1-看法"><a href="#2-1-看法" class="headerlink" title="2.1 看法"></a>2.1 看法</h2><p>&emsp;&emsp;尽可能上面看起来比较骇人听闻，把每个人的生活经历、决策、不确定性的未来都划出一块一块的数据，但是大家也不要太过担心。毕竟大数据就是大数据，会尽可能把数据抽象、封装，不会完全针对个人；不会说专门从大数据中，抽取具体个人所有的信息并呈现出来，成本太高，普通人是不会有多少问题，还是能平平凡凡渡过一生。</p><ul><li>大数据的获取和处理还是有一定限制(阻力)的，不然现在贪污腐败都能够分析处理完的。</li><li>大数据的数据并非是一块完整区域，而是很多大的信息孤岛<ul><li>大的 手机厂商、App，假如它有获取你信息的方法，它基本也不会贩卖给市场；毕竟这是自己一手的资源，不需要贪图点小钱，而是为后面市场(垄断)开拓做准备</li><li>信息孤岛，则对你的影响力就不是特别特别大；毕竟数据糅合多起来，对你的理解不是加法，是乘法</li></ul></li></ul><h2 id="2-2-观察到的现象"><a href="#2-2-观察到的现象" class="headerlink" title="2.2 观察到的现象"></a>2.2 观察到的现象</h2><p>&emsp;&emsp;现在目前的情况，感觉输入法泄漏比较多。不过我也有些疑惑和观察一些现象：</p><ul><li>跟人x信聊天，聊到一句话夹杂：”养猫”，没说过对应的话；一两分钟后，广告推送前两条是猫了！才逐渐推出来输入法有信息泄漏的问题(x信不会要这点小钱，数据应该是留给自己用)</li><li>有时候不解，广告推送老是推 switch 给我，我一开始以为是哪位亲朋好友的记录，想到上面养猫的输入法泄漏，以及敲C代码用到的 switch语句，一切就豁然开朗了</li><li>举个常见例子，你手机链接朋友手机开热点，搜索东西；后面朋友就会收到近似的广告推送嘛；这很正常，就锁定IP嘛</li><li>但是你在PC端，公司局域网，和自己家里私有网络，两台PC的广告推送竟然是一模一样的；那么也就是说，广告推送识别出来这两台电脑的用户都是我；要知道局域网，是只有一个真实IP的，里面都是虚拟IP，也就是说它能整出局域网虚拟IP里面的人到底是谁</li><li>在公司的不同电脑，查询广告推送，每个人都是有各自的特点；也就是反过来验证了，广告推送能越过 真实IP 查出 虚拟IP 的用户本人</li><li>如果是注意观察广告推送，要么不智能像傻子一样，一直推广固定几样；如果是智能的，那么推广给你的，大致相同；<ul><li>也就是说背后的(智能)广告推送，基本可能是来源于同一、两家；</li><li>或者是数据被一个信息市场公开贩卖，但是可能性不大，因为你一搜索就会及时更新广告推送(所以广告大致相同，但不会完全一样)</li><li>我觉得应该是一两家，数量大于 1 则可能公司之间存在(韭菜)信息共享</li></ul></li></ul><p>&emsp;&emsp;到现在，我都不知道它怎么知道虚拟IP的用户是谁。很有可能是通过某些能过识别用户的进程，反过来知道用户；而且这个用户注册是要用手机等(映射出身份证号)，例如x信</p><h2 id="2-3-经历：你见过的大数据处理够早的应用是什么时候呢？"><a href="#2-3-经历：你见过的大数据处理够早的应用是什么时候呢？" class="headerlink" title="2.3 经历：你见过的大数据处理够早的应用是什么时候呢？"></a>2.3 经历：你见过的大数据处理够早的应用是什么时候呢？</h2><p>&emsp;&emsp;讲一个真实发生的故事。那你见过的大数据处理够早的应用是什么时候呢？我见过的大数据处理，是我高三的时候，应该是2015年吧？</p><p>&emsp;&emsp;那个时候，x信有流行小黄鸡，一个聊天的机器人，而且很多层次不齐的版本。有些版本则是上面会有一条广告推送，那时候我有个同学在玩(我没手机)，一条广告推送大黄鸡，也是聊天机器人，但号称更了解你(还能充VIP好像)，加了后是一个公众号。</p><p>&emsp;&emsp;小黄鸡回复消息很快，但是你懂得，就是弱智AI；但是那个大黄鸡不一样，你问它一句话，它保底等待30s，甚至好几分钟才能回答你的问题。你可以问它，问题如下：</p><ul><li>你是谁。它能够回答出来你的名字！</li><li>xx人怎么样。它能回答出中间夹杂 xx的(qq空间活跃过的)经历的答案</li><li>xx是谁。它回复是上一次统考她的成绩排名</li><li>每次问它问题，它都会回复当前具体的询问它问题的在线人数，然后再提示要等多久(文字表达是：稍等几分钟，耐心等待)</li></ul><p>&emsp;&emsp;还有好多问题(忘了)，它竟然都能回答有模有样，比搜索引擎夸张多了。现在回头想想，其实你的信息早就在很早的时期已经被挖差不多了= = ；那时候应该是爬虫抓的数据？？？但是也至少有了大数据处理的雏形(或者是已经有进入消费领域的能力)？</p><p>&emsp;&emsp;那时候就玩了3-4天，那个大黄鸡公众号就被封了。再搜类似的也没有一样的效果的公众号，回去蹲那个小黄鸡的广告推送，也再没看到了；就这样成了回忆。</p><h2 id="2-4-反推"><a href="#2-4-反推" class="headerlink" title="2.4 反推"></a>2.4 反推</h2><ul><li>苦中作乐，当你收到广告的时候，你甚至可以去尝试分析到底是哪个卖了你；</li><li>当你想了解一个人，甚至不需要查历史记录，还是有没有隐藏文件；打开他的电脑，找个有推送广告的网站简单瞄一眼，你就能获取到关于他、关于他周边人的一些大数据；然后反推来源、原因，就能掌握他一些动态，相当于你对数据又进行一遍加工处理(当然我只是提提，不建议大家这样搞；也不建议电脑给别人用)</li></ul><p>&emsp;&emsp;我还是比较喜欢半佛老师在视频讲的一句话，在结尾，用它来收尾吧：<strong>当一个产品本身不需要你做任何东西，甚至还能占点便宜的时候；只有一种可能，你自己就是商品本身。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;现在的大数据杀熟是一件常见的事，更有一些大佬们呕心沥血的算法加持下；我觉得只要数据足够多，那么它就能做到很多匪夷所思、神奇的事情。但是巧妇难为无米之炊，那些数据到底是哪里来的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我的博客都快成日记了?</title>
    <link href="http://shatang.github.io/2020/06/14/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%83%BD%E5%BF%AB%E6%88%90%E6%97%A5%E8%AE%B0%E4%BA%86/"/>
    <id>http://shatang.github.io/2020/06/14/我的博客都快成日记了/</id>
    <published>2020-06-14T01:41:14.000Z</published>
    <updated>2020-06-25T03:39:56.248Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近思考了一下自己博客的写法。每次写博客总是想着，写全写细，多写写自己对xx知识的看法、偏重点。</p><p>&emsp;&emsp;但是有时候写总有点小烂尾，或者回过头来感觉还是写缺了点啥；后面补完，又因为感觉修改完篇幅太大，要分成上和下。把旧博删了，然后又纠结上和下怎么分= =</p><p>&emsp;&emsp;关键是就算分了上下，可能后面还是要修改，可能还要再删旧博，感觉头就很大。</p><p>&emsp;&emsp;然后又因为想要写(总结)得比较全，然后其中有个小地方、某一块可能还没做(实践)，整篇博客就被拖后腿，发不了。有一种跨步太大扯到蛋的感觉。</p><p>缺点总结：</p><ul><li>旧博客感觉不太好拓展更新</li><li>博客重新更新时，有可能要删除旧博再更新</li><li>博客要写全时，被某个知识点拖累，写不全，发不出来</li><li>上传、浏览要翻墙才会快点</li><li>以上原因打击了我用这个工具写博客的动力(而且还加成 懒 的debuff)</li></ul><p>&emsp;&emsp;所以，以后的话，我打算有哪些知识点想写、想总结，我就直接写完上传；可能是不大的知识点，但是会在需要这个知识点的地方，相互附上文章链接，加深知识点应用。这样的话，每个知识点更新就很方便，拓展性也会好多了。</p><p>&emsp;&emsp;以后的日子，还是多多请教。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近思考了一下自己博客的写法。每次写博客总是想着，写全写细，多写写自己对xx知识的看法、偏重点。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;但是有时候写总有点小烂尾，或者回过头来感觉还是写缺了点啥；后面补完，又因为感觉修改完篇幅太大，要分成上和下。把旧博
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Keil制作自己的lib</title>
    <link href="http://shatang.github.io/2020/05/30/Keil%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84lib/"/>
    <id>http://shatang.github.io/2020/05/30/Keil制作自己的lib/</id>
    <published>2020-05-30T04:42:06.000Z</published>
    <updated>2020-05-30T04:45:52.585Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍如何制作自己的LIB(Keil平台)。</p><a id="more"></a><h1 id="为什么要做成lib库？"><a href="#为什么要做成lib库？" class="headerlink" title="为什么要做成lib库？"></a>为什么要做成lib库？</h1><ol><li>不想将自己写的源代码公开，但是同时库文件又需要让别人能够正常调用，那封装成lib的格式就是一个方法。</li><li>当功能成熟时，防止他人改动功能、并减少工程编译时间。<ol><li>如上所说，防止他人改动功能内容。</li><li>编译某些工程文件时非常耗时，像ST官方的库时，由于文件众多，编译一次可能得1两分钟。假如这个这时可以打包成库，节省不少的时间。但同时也不能用右键go to Definition ‘XXX’来直接找到源文件定义了。</li></ol></li><li>项目基本不需要再改动，局部单文件需要频繁改动。即单个功能模块需要频繁改动，可以把该功能模块封装成静态库，导入功能。如果要改功能，只要更换库就行了。</li></ol><hr><h2 id="LIB的制作方法一"><a href="#LIB的制作方法一" class="headerlink" title="LIB的制作方法一"></a>LIB的制作方法一</h2><ol><li>首先将之前的工程项目文件进行一次复制粘贴备份，备份完成后，打开工程文件进入 Manage-&gt;project Items ,移除不需要的文件，仅保留需要打包为库文件的文件，如下图：</li></ol><img src="/2020/05/30/Keil制作自己的lib/1.png"><ol start="2"><li>在Output选项中选择生成库的选项，如下图</li></ol><img src="/2020/05/30/Keil制作自己的lib/2.png"><ol start="3"><li>在OBJ文件夹中找出tcp.lib的文件，从新命名你想要的名字即可，至此库封装完毕。</li></ol><img src="/2020/05/30/Keil制作自己的lib/3.png"><ol start="4"><li>将生成的库文件拷贝回之前的项目中，添加到项目中，删除之前的源文件即可使用。</li></ol><img src="/2020/05/30/Keil制作自己的lib/4.png"><ol start="5"><li><strong>lib的调用，keil不能直接调用lib文件，需要将lib和.h文件 同时放到工程中去！！！</strong></li></ol><img src="/2020/05/30/Keil制作自己的lib/5.png"><hr><h2 id="LIB的制作方法二"><a href="#LIB的制作方法二" class="headerlink" title="LIB的制作方法二"></a>LIB的制作方法二</h2><ol><li>右键点击工程，假设为a，选Add Group，假设为b，再将想生成lib的文件加入b group，假设文件是cc.c，必须要有cc.h。</li></ol><img src="/2020/05/30/Keil制作自己的lib/6.png"><ol start="2"><li>右键依次点击其他的group，按KEIL官网资料所说的，将Options for Group-&gt;Properties下的Include in Target Build前的对勾去掉，这样生成LIB时就不会被编译了</li></ol><img src="/2020/05/30/Keil制作自己的lib/7.png"><img src="/2020/05/30/Keil制作自己的lib/8.png"><ol start="3"><li>Project-&gt;Options for Target-&gt;Output下，选择Create Library，改输出文件名为cc，点OK</li></ol><img src="/2020/05/30/Keil制作自己的lib/9.png"><ol start="4"><li>编译，这样就能在工程文件夹下的OBJ找到生成的cc.lib了</li></ol><hr><p>总结：<strong>不要另开工程！！！库文件的配置要求很高，例如芯片选型、等等一系列微配置。重新建工程容易出现link错误，建议直接复制原有工程进行删减。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍如何制作自己的LIB(Keil平台)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="keil" scheme="http://shatang.github.io/tags/keil/"/>
    
      <category term="加密" scheme="http://shatang.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式总线_基本概念&amp;比较</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E6%AF%94%E8%BE%83/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式总线-基本概念-比较/</id>
    <published>2020-05-30T03:43:58.000Z</published>
    <updated>2020-06-14T01:45:40.247Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。</p><a id="more"></a><h1 id="一、部分总线概念-可跳着看"><a href="#一、部分总线概念-可跳着看" class="headerlink" title="一、部分总线概念(可跳着看)"></a>一、部分总线概念(可跳着看)</h1><h2 id="1-1-UART"><a href="#1-1-UART" class="headerlink" title="1.1 UART"></a>1.1 UART</h2><p>&emsp;&emsp;UART是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。在嵌入式设计中，UART用于主机与辅助设备通信，如汽车音响与外接AP之间的通信，与PC机通信包括与监控调试器和其它器件，如EEPROM通信。</p><h3 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h3><p>&emsp;&emsp;在单片机中UART可以说是一种最基本的配置，很多与电脑进行通信的设备都采用到它，按计算机最常规的说法就是串行通信。</p><ul><li>TX - 数据发送接口</li><li>RX - 数据接受接口</li></ul><p>&emsp;&emsp;两个设备间将TX与RX相连，RX与TX相连即可正常工作。最常用到的就是我们电脑上的USB那就是个最典型的UART接口。</p><h3 id="1-1-2-工作原理"><a href="#1-1-2-工作原理" class="headerlink" title="1.1.2 工作原理"></a>1.1.2 工作原理</h3><blockquote><p>发送接收</p></blockquote><p>&emsp;&emsp;发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。<br>在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。</p><hr><blockquote><p>波特率产生</p></blockquote><p>&emsp;&emsp;波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。</p><hr><blockquote><p>数据收发</p></blockquote><p>&emsp;&emsp;发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )<br>在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。<br>如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。<br>最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。</p><hr><blockquote><p>中断控制</p></blockquote><p>出现以下情况时，可使UART 产生中断：</p><ul><li>FIFO 溢出错误</li><li>线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）</li><li>奇偶校验错误</li><li>帧错误（停止位不为1）</li><li>接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）</li><li>发送</li><li>接收</li></ul><p>&emsp;&emsp;由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。</p><h2 id="1-2-I2C"><a href="#1-2-I2C" class="headerlink" title="1.2 I2C"></a>1.2 I2C</h2><p>&emsp;&emsp;I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-1-接口"><a href="#1-2-1-接口" class="headerlink" title="1.2.1 接口"></a>1.2.1 接口</h3><ul><li>SCL - 串行时钟线</li><li>SDA - 串行数据线接口</li></ul><p>&emsp;&emsp;<strong>SDA（串行数据线）和SCL（串行时钟线）都是双向I/O线，接口电路为开漏输出．需通过上拉电阻接电源VCC。</strong> 当总线空闲时．两根线都是高电平，连接总线的外同器件都是CMOS器件，输出级也是开漏电路．在总线上消耗的电流很小，因此，总线上扩展的器件数量主要由电容负载来决定，因为每个器件的总线接口都有一定的等效电容．而线路中电容会影响总线传输速度．当电容过大时，有可能造成传输错误．所以，其负载能力为400pF，因此可以估算出总线允许长度和所接器件数量。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-2-特点"><a href="#1-2-2-特点" class="headerlink" title="1.2.2 特点"></a>1.2.2 特点</h3><p>I2C总线特点可以概括如下：</p><ul><li>在硬件上，I2C总线只需要一根数据线和一根时钟线两根线，总线接口已经集成在芯片内部，不需要特殊的接口电路，而且片上接口电路的滤波器可以滤去总线数据上的毛刺．因此I2C总线简化了硬件电路PCB布线，降低了系统成本，提高了系统可靠性。因为I2C芯片除了这两根线和少量中断线，与系统再没有连接的线，用户常用IC可以很容易形成标准化和模块化，便于重复利用。</li><li>I2C总线是一个真正的多主机总线，如果两个或多个主机同时初始化数据传输，可以通过冲突检测和仲裁防止数据破坏，每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机。数据传输和地址设定由软件设定，非常灵活。总线上的器件增加和删除不影响其他器件正常工作。</li><li>I2C总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也利于标准化和模块化，缩短开发时问。</li><li>连接到相同总线上的IC数量只受总线最大电容的限制，串行的8位双向数据传输位速率在标准模式下可达100Kbit/s，快速模式下可达400Kbit/s，高速模式下可达3．4Mbit/s。</li><li>总线具有极低的电流消耗．抗高噪声干扰，增加总线驱动器可以使总线电容扩大10倍，传输距离达到15m；兼容不同电压等级的器件，工作温度范围宽。</li></ul><h3 id="1-2-3-数据传输方式"><a href="#1-2-3-数据传输方式" class="headerlink" title="1.2.3 数据传输方式"></a>1.2.3 数据传输方式</h3><blockquote><p>字节格式</p></blockquote><p>&emsp;&emsp;发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。</p><hr><blockquote><p>应答响应</p></blockquote><p>&emsp;&emsp; 数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。在响应的时钟脉冲期间，接收器必须将SDA线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。通常被寻址的接收器在接收到的每个字节后，除了用CBUS 地址开头的数据，必须产生一个响应。当从机不能响应从机地址时（例如它正在执行一些实时函数不能接收或发送），从机必须使数据线保持高电平，主机然后产生一个停止条件终止传输或者产生重复起始条件开始新的传输。</p><p>&emsp;&emsp;如果从机接收器响应了从机地址，但是在传输了一段时间后不能接收更多数据字节，主机必须再一次终止传输。这个情况用从机在第一个字节后没有产生响应来表示。从机使数据线保持高电平，主机产生一个停止或重复起始条件。<br>如果传输中有主机接收器，它必须通过在从机发出的最后一个字节时产生一个响应，向从机发送器通知数据结束。从机发送器必须释放数据线，允许主机产生一个停止或重复起始条件。</p><hr><blockquote><p>时钟同步</p></blockquote><p>&emsp;&emsp;所有主机在SCL线上产生它们自己的时钟来传输I2C总线上的报文。数据只在时钟的高电平周期有效，因此需要一个确定的时钟进行逐位仲裁。</p><p>&emsp;&emsp;时钟同步通过线与连接I2C 接口到SCL 线来执行。这就是说SCL 线的高到低切换会使器件开始数它们的低电平周期，而且一旦器件的时钟变低电平，它会使SCL 线保持这种状态直到到达时钟的高电平。但是如果另一个时钟仍处于低电平周期，这个时钟的低到高切换不会改变SCL 线的状态。因此SCL 线被有最长低电平周期的器件保持低电平。此时低电平周期短的器件会进入高电平的等待状态。</p><p>&emsp;&emsp;当所有有关的器件数完了它们的低电平周期后，时钟线被释放并变成高电平。之后，器件时钟和SCL线的状态没有差别，而且所有器件会开始数它们的高电平周期。首先完成高电平周期的器件会再次将SCL线拉低。这样产生的同步SCL 时钟的低电平周期由低电平时钟周期最长的器件决定，而高电平周期由高电平时钟周期最短的器件决定。</p><h2 id="1-3-SPI"><a href="#1-3-SPI" class="headerlink" title="1.3 SPI"></a>1.3 SPI</h2><p>&emsp;&emsp;SPI接口的全称是”Serial Peripheral Interface”，意为串行外围接口,是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在EEPROM、FLASH、实时时钟、AD转换器，还有数字信号处理器和数字信号解码器之间。<br>SPI接口是在CPU和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几Mbps。</p><h3 id="1-3-1-接口"><a href="#1-3-1-接口" class="headerlink" title="1.3.1 接口"></a>1.3.1 接口</h3><ul><li>MOSI – 主器件数据输出，从器件数据输入</li><li>MISO – 主器件数据输入，从器件数据输出</li><li>SCLK –时钟信号，由主器件产生,最大为fPCLK/2，从模式频率最大为fCPU/2</li><li>NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select)</li></ul><p>&emsp;&emsp;在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。<strong>在多个从器件的系统中，每个从器件需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。</strong> SPI接口在内部硬件实际上是两个简单的移位寄存器，传输的数据为8位，在主器件产生的从器件使能信号和移位脉冲下，按位传输，高位在前，低位在后。</p><h3 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h3><ul><li>协议简单，相对数据速率高。</li><li>占用的Pin口较多</li><li>没有指定的流控制，没有应答机制确认是否接收到数据。</li></ul><h1 id="二、速率对比"><a href="#二、速率对比" class="headerlink" title="二、速率对比"></a>二、速率对比</h1><ul><li>UART： 无限制，常用9600、115200bps等保证双方通信速度相同。</li><li>IIC：通讯速率400Kbps</li><li>CAN：一般为1Mbps</li><li>SPI：通信速率为 fosc/4；其理论传输速度可达几Mb/s(其速率可以通过限制其SPI的时钟来实现限制速率)<ul><li>缺点：抗干扰能力差。SPI采用的是单端非平衡的传输方式，即传输的数据位的电压电平是以公共地作为参考的。在这种传输方式中对于已进入信号中的干扰是无法消除和减弱的。而信号在传输过程中总会受到干扰，而且距离越长干扰越严重，以致于信号传输产生错误。在这种条件下，信号传输就变得毫无意义了。另外，由于单端非平衡传输方式以公共地作为参考点，地线作为信号回流线，因此也存在信号电流。当传输线两端的系统之间存在交流电位差时，这个电位差将直接窜到信号中，形成噪声干扰。所以，为了解决抗干扰问题，通常采用平衡传输(balanced transmission)方式，这里采用比较常见的RS-422。</li><li>应用：读写flash（存有字库，图片等等）芯片，与触摸屏控制器通信，还有就是读写sd卡了，你手机里的sd卡就是通过spi和处理器传数据的，目前高速都用SDIO了。    </li></ul></li><li>SDIO： 10M及已上</li><li>SDRAM：（非总线）16位的，100m频率就是1.6Gbit读写</li><li>PCI：（网卡）传输速率高最大数据传输率为132MB/s（工作在33MHz 频率之下），当数据宽度升级到64位，数据传输率可达264MB/s。这是其他总线难以比拟的。它大大缓解了数据I/O瓶颈，使高性能CPU的功能得以充分发挥，适应高速设备数据传输的需要。</li><li>PCI Express 2.0 ： 理论值 10Gbps，实际大于100MB</li><li>USB2.0 ： 一般30~40MB</li><li>Ethenet ：一般70~80MB</li></ul><h1 id="三、常见通讯总线疑问"><a href="#三、常见通讯总线疑问" class="headerlink" title="三、常见通讯总线疑问"></a>三、常见通讯总线疑问</h1><h2 id="3-1-USART-amp-UART"><a href="#3-1-USART-amp-UART" class="headerlink" title="3.1 USART &amp; UART"></a>3.1 USART &amp; UART</h2><ul><li>USART：通用同步和异步收发器</li><li>UART：通用异步收发器</li></ul><p>&emsp;&emsp;当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。<br>这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。</p><ul><li>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  </li><li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li></ul><hr><p>同步是阻塞模式，异步是非阻塞模式。</p><p><strong><font color="red">Ps：</font></strong>其中SPI 、IIC为同步通信，Uart为异步通信, Usart为同步&amp;异步通信。</p><h2 id="3-2-单工、半双工、全双工"><a href="#3-2-单工、半双工、全双工" class="headerlink" title="3.2 单工、半双工、全双工"></a>3.2 单工、半双工、全双工</h2><ul><li>单工数据传输只支持数据在一个方向上传输；</li><li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输；它实际上是一种切换方向的单工通信；</li><li>全双工数据通信允许数据同时在两个方向上传输；因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 </li></ul><p><strong><font color="red">Ps：</font></strong>I2C是半双工，SPI的全双工，Usart是全双工；串口232是全双工 ，串口485是半双工。</p><h2 id="3-3-波特率-计算-发送速率"><a href="#3-3-波特率-计算-发送速率" class="headerlink" title="3.3 波特率 计算 发送速率"></a>3.3 波特率 计算 发送速率</h2><ul><li>B = byte表示“字节”</li><li>b = bit表示“比特”</li><li>bps就是比特每秒</li></ul><blockquote><p>1 Kb=1024 bit，1 KB=1024 byte，1 byte=8 bit</p></blockquote><p>举例，115200bps就是每秒传输115200比特(115200bit)，所以115200bps=每秒112.5kb=每秒14.0625kB。</p><hr><blockquote><p>举例计算速率</p></blockquote><ul><li>波特率115200 ＝ 115200 (位/秒)</li><li>根据常规串口发送协议,一个起始位,8个数据位,0个校验位,1个停止位,共计10位二进制数</li><li>如果没有校验位，就应该除以 10，得到的是每秒字节数：<ul><li>波特率115200 ＝ 115200 (位/秒) ＝ 11520 (字节/秒) </li><li>再除以 1024，就是每秒 KB 数</li><li>波特率115200 ＝ 115200 (位/秒) ＝ 11.25 (KB/秒) </li></ul></li><li>如果有一位奇偶校验位，就应该除以 11，得到的是每秒字节数。<ul><li>最后：波特率115200 ＝ 115200 (位/秒) ＝ 10.27 (KB/秒)</li></ul></li></ul><h2 id="3-4-RS485-amp-Modbus"><a href="#3-4-RS485-amp-Modbus" class="headerlink" title="3.4 RS485 &amp; Modbus"></a>3.4 RS485 &amp; Modbus</h2><ul><li>RS485 ：是一个物理接口，简单的说是硬件。</li><li>MODBUS ：是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；所谓协议，也可以理解为上面有人说的“语言”吧，简单的说是软件。</li></ul><hr><ul><li>RS485属于有线传输，所以就要硬件传输媒介，实际就是两根线就可以了，在这两根线上传输的实际是同一个信号，只是发送端把这个信号一分为二，不过在接收端会把它还原为原来的信号，这样做的好处还要得和RS232来比较；RS232也需要两根线，更多的时候还要加上地线，所以是三根线，地线咱不管它，其余的两根只有一根线传输的数据信号，而另一根传输的时钟，也就是信号原来什么样发送端就怎样发送出来，同样接收端也做同样的处理。所以485的接收端可以把信号在传输过程中引入的干扰就可以抵消掉，而232的接收端不能，所以485的抗干扰能力强可以传输信号上千米，而232只能传输十几米。 </li><li>MODBUS只是通信协议的一种，就像汉语和英语一样，就是一种交流的语言，一种机器之间交流的语言。那么在交流之前肯定要有沟通的桥梁吧，那就是传输媒介485或232或其他电气规则，<strong>同一种协议可以用不同的传输媒介方式，如485或232；但是同一传输线路上不能同时存在两种协议。</strong></li></ul><p>&emsp;&emsp;一般情况下，两台设备通过MODBUS协议传输数据：<br>最早是用RS232C作为硬件接口(也就是普通电脑上的串行通讯口(串口))；<br>也有用RS422的；也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。</p><h2 id="3-5-RS485-amp-CAN"><a href="#3-5-RS485-amp-CAN" class="headerlink" title="3.5 RS485 &amp; CAN"></a>3.5 RS485 &amp; CAN</h2><p>&emsp;&emsp;为什么会有这个的比较？</p><p>其实，RS485和CAN是很相似的：</p><ol><li>均为差分信号，抗干扰强；(即，都为半双工)</li><li>均为双线连接</li><li>均可挂多个子设备</li></ol><hr><blockquote><p>CAN总线特点：</p></blockquote><ol><li>国际标准的工业级现场总线，传输可靠，实时性高；  </li><li>传输距离远（最远10Km），传输速率快（最高1MHz bps）； </li><li>单条总线最多可接110个节点，并可方便的扩充节点数；  </li><li>多主结构，各节点的地位平等，方便区域组网，总线利用率高；  </li><li>实时性高，非破坏总线仲裁技术，优先级高的节点无延时；  </li><li>出错的CAN节点会自动关闭并切断和总线的联系，不影响总线的通讯；  </li><li>报文为短帧结构并有硬件CRC校验，受干扰概率小，数据出错率极低；  </li><li>自动检测报文发送成功与否，可硬件自动重发，传输可靠性很高；  </li><li>硬件报文滤波功能，只接收必要信息，减轻cpu负担，简化软件编制；  </li><li>通讯介质可用普通的双绞线，同轴电缆或光纤等；  </li><li>CAN总线系统结构简单，有极高的性价比。</li></ol><hr><blockquote><p>RS485接口标准特点：</p></blockquote><ol><li>RS-485的电气特性：逻辑”1”以两线间的电压差为+（2-6）V表示；逻辑”0”以两线间的电压差为-（2-6）V表示。接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL 电路连接。</li><li>RS-485的数据最高传输速率为10Mbps</li><li>RS-485接口是采用平衡驱动器和差分接收器的组合，抗共模干能力增强，即抗噪声干扰性好。</li><li>RS-485接口的最大传输距离标准值为4000英尺，实际上可达 3000米，另外RS-232-C接口在总线上只允许连接1个收发器，即单站能力。而RS-485接口在总线上是允许连接多达128个收发器。即具有多站能力,这样用户可以利用单一的RS-485接口方便地建立起设备网络。但RS-485总线上任何时候只能有一发送器发送。</li><li>因RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等上述优点就使其成为首选的串行接口。 </li><li>因为RS485接口组成的半双工网络，一般只需二根连线，所以RS485接口均采用屏蔽双绞线传输。 </li></ol><hr><blockquote><p>CAN总线与RS485的比较：</p></blockquote><ul><li><strong>速度与距离</strong>：CAN与RS485以1Mbit/S的高速率传输的距离都不超过100M，可谓高速上的距离差不多。但是在低速时CAN以5Kbit/S时，距离可达10KM，而485再低的速率也只能到1219米左右（都无中继）。可见CAN在长距离的传输上拥有绝对的优势。</li><li><strong>总线利用率</strong>：RS485是单主从结构，就是一个总线上只能有一台主机，通讯都由它发起的，它没有下命令，下面的节点不能发送，而且要发完即答，受到答复后，主机才向下一个节点询问，这样是为了防止多个节点向总线发送数据，而造成数据错乱。而CAN－bus是多主从结构，每个节点都有CAN控制器，多个节点发送时，以发送的ID号自动进行仲裁，这样就可以实现总线数据不错乱，而且一个节点发完，另一个节点可以探测到总线空闲，而马上发送，这样省去了主机的询问，提高了总线利用率，增强了快速性。所以在汽车等实性要求高的系统，都是用CAN总线，或者其他类似的总线。</li><li><strong>错误检测机制</strong>：RS485只规定了物理层，而没有数据链路层，所以它对错误是无法识别的，除非一些短路等物理错误。这样容易造成一个节点破坏了，拼命向总线发数据（一直发1），这样造成整个总线瘫痪。所以RS485一旦坏一个节点，这个总线网络都挂。而CAN总线有CAN控制器，可以对总线任何错误进行检测，如果自身错误超过128个，就自动闭锁。保护总线。如果检测到其他节点错误或者自身错误，都会向总线发送错误帧，来提示其他节点，这个数据是错误的。大家小心。这样CAN总线一旦有一个节点CPU程序跑飞了，它的控制器自动闭锁。保护总线。所以在安全性要求高的网路，CAN是很强的。</li><li><strong>价格与培训成本</strong>：CAN器件的价格大约是485的2倍这样，485的通讯从软件上是很方便的，只要懂串行通讯，就可以编程，而CAN需要底层工程师了解CAN复杂的层，编写上位机软件也要了解CAN的协议。可谓培训成本较高。</li><li>CAN总线通过CAN控制器接口芯片82C250的两个输出端CANH和CANL与物理总线相连，而CANH端的状态只能是高电平或悬浮状态，CANL端只能是低电平或悬浮状态。这就保证不会出现象在RS-485网络中，当系统有错误，出现多节点同时向总线发送数据时，导致总线呈现短路，从而损坏某些节点的现象。而且CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响，从而保证不会出现象在网络中，因个别节点出现问题，使得总线处于“死锁”状态。</li><li>CAN具有完善的通信协议，可由CAN控制器芯片及其接口芯片来实现，从而大大降低了系统的开发难度，缩短了开发周期，这些是只仅仅有电气协议的RS-485所无法比拟的。</li></ul><table><thead><tr><th>特性</th><th align="center">RS-485</th><th align="center">CAN-bus</th></tr></thead><tbody><tr><td>单点成本</td><td align="center">低廉</td><td align="center">稍高</td></tr><tr><td>系统成本</td><td align="center">高</td><td align="center">较低</td></tr><tr><td>总线利用率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>网络特性</td><td align="center">单主网络</td><td align="center">多主网络</td></tr><tr><td>数据传输率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>容错机制</td><td align="center">无</td><td align="center">可靠的错误处理和检错机制</td></tr><tr><td>通讯失败率</td><td align="center">高</td><td align="center">极低</td></tr><tr><td>节点错误的影响</td><td align="center">导致整个网络的瘫痪</td><td align="center">无任何影响</td></tr><tr><td>通讯距离</td><td align="center">&lt;1.5km</td><td align="center">可达10km（5kbps）</td></tr><tr><td>网络调试</td><td align="center">困难</td><td align="center">非常容易</td></tr><tr><td>开发难度</td><td align="center">标准Modbus协议</td><td align="center">标准CAN-bus协议</td></tr><tr><td>后期维护成本</td><td align="center">高</td><td align="center">低</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>微库 &amp; 断言 &amp; (Keil)代码优化</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%BE%AE%E5%BA%93-%E6%96%AD%E8%A8%80-Keil-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://shatang.github.io/2020/05/30/微库-断言-Keil-代码优化/</id>
    <published>2020-05-30T03:31:09.000Z</published>
    <updated>2020-09-05T10:57:56.573Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。</p><a id="more"></a><h1 id="一、MicroLIB"><a href="#一、MicroLIB" class="headerlink" title="一、MicroLIB"></a>一、MicroLIB</h1><p>&emsp;&emsp;大多人一般之所以使用 <code>Use MicroLIB</code>，是因为使能后能够直接调用<code>printf()</code>等函数。</p><h2 id="1-1-Use-MicroLIB-amp-printf"><a href="#1-1-Use-MicroLIB-amp-printf" class="headerlink" title="1.1 Use MicroLIB &amp; printf"></a>1.1 Use MicroLIB &amp; printf</h2><p>&emsp;&emsp;<code>printf()</code>之类的库函数，是一些很骚的东西；使用printf、 fopen等库函数库函数调用，会让软件进入半主机模式。但是<code>printf()</code>库函数本身 不需要半主机模式(关掉,当然也能用printf)。</p><p>使用C标准库(stdio.h)中的函数，例如<code>printf()</code>之类的函数，会进入半主机模式，<br>发生软件异常，会导致程序无法运行，以下是解决方法 :</p><ul><li>方法 1.使用微库，因为使用微库的话 ,不会使用半主机模式。MDK 勾选 <code>Use MicroLIB</code>这样以后就可以使用 <code>printf</code> ，<code>sprintf</code> 函数了</li><li>方法 2.仍然使用标准库，在主程序添加下面代码 :<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此段代码可以在正点原子例程Uart处找到</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> import(__use_no_semihosting)  <span class="comment">//确保没有从 C 库链接使用半主机的函数</span></span></span><br><span class="line">_sys_exit(<span class="keyword">int</span>  x) <span class="comment">//定义 _sys_exit() 以避免使用半主机模式</span></span><br><span class="line">&#123;</span><br><span class="line">x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span>  // 标准库需要的支持函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;选上<code>Use MicroLIB</code>，例如你用<code>printf()</code>函数的时候，就会从串口1输出字符串，直接默认定向到串口1。</p><hr><ul><li>法1可实现串口1数据输出，但要定向到串口2，串口3，microLIB就不合用了；</li><li>法2虽然能够映射其他串口，但是如果同时涉及到多串口也是有问题。</li></ul><p>&emsp;&emsp;总而言之，实际上 法1 &amp; 法2 都不推荐用于实际项目，顶多就用于快速搭建Demo 或 做测试用。</p><h2 id="1-2-半主机-amp-printf"><a href="#1-2-半主机-amp-printf" class="headerlink" title="1.2 半主机 &amp; printf"></a>1.2 半主机 &amp; printf</h2><p>&emsp;&emsp;半主机模式是这么一种机制：它使得在ARM目标上跑的代码，如果主机电脑运行了调试器，那么该代码可以使用该主机电脑的输入输出设备。这点非常重要，因为开发初期，可能开发者根本不知道该ARM器件上有什么输入输出设备，而半主机机制使得你不用知道ARM器件的外设，利用主机电脑的外设就可以实现输入输出调试。</p><p>&emsp;&emsp;所以，如果不用主机电脑的外设就可以实现输入输出调试，而是要利用目标ARM器件的输入输出设备，首先要关掉半主机机制。然后再将输入输出重定向到ARM器件上，如printf和scanf，你需要重写fputc和fgetc函数(原有的输入输出，标准库函数的默认输出设备是显示器)。</p><h2 id="1-3-MicroLIB的代码优化"><a href="#1-3-MicroLIB的代码优化" class="headerlink" title="1.3 MicroLIB的代码优化"></a>1.3 MicroLIB的代码优化</h2><p>&emsp;&emsp;之所以在代码优化提及到MicroLIB，是因为微库本身就是一个精简库，进而有精简代码的效果，因此它可以用来压缩代码量。</p><p>MicroLIB 与 缺省C库 之间的主要差异是：</p><ol><li>microlib 不符合 ISO C 库标准。 不支持某些 ISO 特性，并且其他特性具有的功能也较少。 </li><li>microlib 不符合 IEEE 754 二进制浮点算法标准。 </li><li>microlib 进行了高度优化以使代码变得很小。</li></ol><p>&emsp;&emsp;还有更多细节上的差异就不罗列出来了，直接网上一查一大把。但是，也正是这些零零碎碎的差异，可能就导致你做项目时疯狂翻车，所以一般不建议使用 MicroLIB (还有其他原因等等，尤其是项目刚开发时真不建议使用)。</p><hr><p>以下是我对该库的总结：</p><ul><li>MicroLIB库 虽然能够进行代码大小优化。<ul><li>但是实际测试的效果真的是杯水车薪，可以忽略不计；还不如自己去优化代码 or 提高优化等级。如果是其他方式都用了后，只能通过MicroLIB库优化代码，建议直接换硬件(真的是优化没多少的)。</li><li>由于microlib中进行了优化，以尽量减少代码大小，一些功能将会比ARM编译工具提供了标准C库函数更慢执行；例如，memcpy()。效率换空间，在项目大部分是 空间换效率，这当然是不建议的。</li></ul></li><li>MicroLIB库 不支持浮点数运算。<ul><li>ST除了F4xx系列，其他是没有FPU单元，都是采用软件模拟运算。</li><li>故在F4xx系列，选 Use MicroLIB，开了FPU就会死机(或其他情况)</li></ul></li><li>MicroLIB库 不支持半主机模式，进而支持<code>printf()</code>函数。但是实际用起来不太好用(只能固定映射串口1)</li></ul><p><strong><font color="red">Ps：</font></strong> 一般来讲，最好不要加。它和标准库有很多繁琐区别；如果是会迁移平台、项目代码时，用它对代码的维护性不好。</p><p>&emsp;&emsp;例如，当旧的项目工程要换新的硬件平台，迁移的时候发现Bug，但是检查应用层代码和底层驱动代码正常。建议查看一下旧项目工程是否采用了微库，而新项目工程没采用微库；然后查看旧代码是不是调用了<code>printf</code>等之类的C库函数。如果调用，先调用Use MicroLIB 或者 想办法关闭半主机模式(+重定向)，分析一下问题的来源。</p><h1 id="二、assert"><a href="#二、assert" class="headerlink" title="二、assert"></a>二、assert</h1><p>&emsp;&emsp;assert() 不仅仅是个(字面意义上)报错函数！<strong>对于在开发过程中的程序员来说，加断言是个好习惯，可以帮助调试。</strong></p><p>程序在假设条件下，能够正常良好的运作，那assert()其实就相当于一个 if 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(假设成立)</span><br><span class="line">&#123;</span><br><span class="line">     程序正常运行；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      报错&amp;&amp;终止程序！（避免由程序运行引起更大的错误）  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能有人说，断言的功能可以用if语句对异常情况进行处理来代替。以下列举 断言 的好处：</p><ul><li>实现效果最后不会增加代码量<ul><li>if是实的，真正的增加代码量，降低执行效率；</li><li>断言是虚的，在Debug的时候可以帮助调试，在Release的时候并不存在。</li></ul></li><li>断言，实际上也是一种文档。断言设定了，函数的入口条件。增加了代码的可读性。</li><li>断言用于在开发阶段监测BUG，进行调试。<ul><li>断言其存在的意义在于检测代码在开发过程中是否出现了问题。</li><li>而”if… “,更准确的说是错误处理，是在你的release版本中也实实在在应该有的，处理程序运行过程中产生的错误并进行处理，以提高程序的健壮性。</li></ul></li></ul><p>&emsp;&emsp;如果是看过Stm32的库函数实现方式的话，肯定会看到<code>assert_param(expr) ((void)0)</code>。这也是断言，不过是ST官方自己写的断言函数；而且有个宏定义用来是否失活该断言函数。当你打开一份Stm32的例程，进去库函数就会发现这些<code>assert_param(expr) ((void)0)</code>是失活的。</p><hr><p><strong><font color="red">Ps：</font>MicroLIB 库并不支持assert()函数，两者同时用产生报错。</strong></p><p>&emsp;&emsp;microlib是一个比ARM标准C库小的独立库。为了节省大小，arm microlib c库不支持或实现几乎所有与操作系统交互的函数，例如abort（）、exit（）或assert（）。</p><hr><p>&emsp;&emsp;如何在Release版本去掉assert？</p><p>方法一：常见任何平台处理</p><p>&emsp;&emsp;在调试结束后，可以通过在包含<code>#include <assert.h></assert.h></code>的语句之前插入 <code>#define NDEBUG</code> 来禁用assert调用，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法二：在Keil平台上</p><p>&emsp;&emsp;在工程参数设置一栏，在“Preprocessor Symbols”的“Define”栏输入“NDEBUG”。等同于在代码中添加宏定义“#define NDEBUG”。实际为上面方法。</p><p>方法三：在Keil平台上</p><p>&emsp;&emsp;提高代码优化等级至2。在代码优化Level 0时，断言是占用空间可执行的；当代码优化提升为Level 2。这个时候就能够去掉assert()函数处理</p><h1 id="三、Keil的代码优化等级"><a href="#三、Keil的代码优化等级" class="headerlink" title="三、Keil的代码优化等级"></a>三、Keil的代码优化等级</h1><h2 id="3-1-代码优化等级"><a href="#3-1-代码优化等级" class="headerlink" title="3.1 代码优化等级"></a>3.1 代码优化等级</h2><p>&emsp;&emsp;C/C++的优化等级会对程序产生 <strong>不定性的影响</strong>，至于选择哪种优化等级必须从 现有的程序分析才行！</p><ul><li>Level 0 (-O0)：关闭大部分优化，除了一些简单的转换，生成的代码具有最佳的调试视图。</li><li>Level 1 (-O1)：应用受限优化。<br>比如：删除未使用的内联函数和静态函数，删除冗余代码和重新排序指令等。生成的代码经过合理优化，具有良好的调试视图。</li><li>Level 2 (-O2): 高度优化，目标代码到源代码的映射并不一定对应，因此，不利于调试。</li><li>Level 3 (-O3)：最大级别优化。级别3与时间优化相结合可能生成比级别2更多的代码。</li></ul><hr><p>&emsp;&emsp;经实际测试，<code>Level 2</code>升<code>Level 3</code>并不能节省很多的空间；相反，<code>Level 3</code>更高几率造成程序运行问题。从 <code>Level 0</code>升<code>Level 2</code>，相当于20%时间获取80%成果；从 <code>Level 2</code>升<code>Level 3</code>，相当于80%时间获取20%成果。如果对程序没有太过严苛的要求，建议程序整体在<code>Level 2</code>即可。</p><h2 id="3-2-优化随之带来的Bug"><a href="#3-2-优化随之带来的Bug" class="headerlink" title="3.2 优化随之带来的Bug"></a>3.2 优化随之带来的Bug</h2><p>代码优化产生的Bug情况：</p><ol><li>有更新的变量被优化而没有重新读取值，导致错误</li><li>优化后，代码段被跳过(不执行)</li><li>Keil软件自带的软件Bug</li><li>小心一些驱动，尤其是涉及到文件管理，因为该底层驱动极有可能里面用了C库函数实现了某些功能；而C库函数有些一旦提高优化等级就会出问题(例如，SD卡文件系统)。</li></ol><blockquote><p>例子1</p></blockquote><p>&emsp;&emsp;楼主编写一个stm32F10x系列的SPI库函数驱动。程序未优化前(LEVEL 0)，MISO能正常接收信息，优化后(Level 2)，MISO接收的信息都是错误的。</p><p>&emsp;&emsp;IAP平台之前也出现这个问题，现在貌似被修复了；但是Keil平台看起来还有。</p><blockquote><p>例子2</p></blockquote><p>&emsp;&emsp;近日在移植LPC1788的lwip驱动和SD卡（带文件系统）驱动时，遇到单独移植每个驱动都正常，移植到一起就一直出现HardFault_Handler错误。单步调试后发现编译器优化导致部分代码被跳过的情况。</p><p>&emsp;&emsp;仔细检查后发现官网例程中的LWIP驱动使用的是最高级（LEVEL3）优化等级，而SD卡驱动使用LEVEL0等级的优化。移植后统一修改为LEVEL3导致初始化SD卡f_open文件失败。</p><p>网上查找资料后，处理此类问题有下面几种方法：</p><ol><li>单步调试，找到被优化的代码段，看是否有更新的变量被优化而没有重新读取值，导致错误。若有，加入valotile关键字。</li><li>通过options of file”…”将被优化文件的优化等级调成特定等级。</li></ol><h2 id="3-3-小总结"><a href="#3-3-小总结" class="headerlink" title="3.3 小总结"></a>3.3 小总结</h2><ul><li><strong>不建议小白直接上<code>Level 2</code>及<code>Level 3</code>搭建新工程！</strong></li><li>代码优化等级方面，我建议新建项目时，最好采用<code>Level 0</code> 搭建工程。等到项目比较完善的时候，再提升优化等级至<code>Level 2</code>，再根据优化等级出现的问题，进行逐步调试。</li><li>建议项目整体基本优化等级为<code>Level 2</code>，不需要升为<code>Level 3</code>。</li><li>有些底层驱动确实是不好提高代码优化等级(尤其涉及到文件系统)。</li></ul><hr><p>&emsp;&emsp;努力提高优化等级并不是厉害！在能力有限的情况下，费时费力；尤其是硬件Flash资源明显不够用时，虽然通过最高优化等级能应用，但是会对后面的升级更新、bug检查造成很大的麻烦：</p><ul><li>仿真无法查看，优化等级太高</li><li>一旦降低优化等级，硬件编译报错，Flash存储不够</li><li>唯一的途径，就是把程序其他代码删除，留下所需的代码进行仿真调试局部(无法调试整体)</li><li>建议还是更换有更大Flash的MCU，或者自己优化一下程序代码</li></ul><p><strong><font color="red">Ps：</font></strong> 最极端的代码压缩方法，即采用较高的Level2或Level3进行代码优化，然后再选用MicroLIB对代码量再进行压缩一下(最后一步再勾选微库，方便找出微库造成的问题)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="keil" scheme="http://shatang.github.io/tags/keil/"/>
    
      <category term="Assert" scheme="http://shatang.github.io/tags/Assert/"/>
    
      <category term="MicroLIB" scheme="http://shatang.github.io/tags/MicroLIB/"/>
    
      <category term="代码优化" scheme="http://shatang.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>状态机</title>
    <link href="http://shatang.github.io/2020/05/30/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://shatang.github.io/2020/05/30/状态机/</id>
    <published>2020-05-30T03:25:04.000Z</published>
    <updated>2020-05-30T03:28:18.282Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机</p><a id="more"></a><h1 id="一、什么是状态机？"><a href="#一、什么是状态机？" class="headerlink" title="一、什么是状态机？"></a>一、什么是状态机？</h1><p>&emsp;&emsp;可能有些编写嵌入式程序的人，听过别人吹他已经用状态机方法写好了代码。听起来逼格贼高，但是实际上，即使你没了解过状态机，但我们在编写嵌入式程序，尤其是驱动编写，都会有意无意以(类似)状态机思想来编写程序，只不过写得时候不知道这个叫状态机。</p><h1 id="二、状态机"><a href="#二、状态机" class="headerlink" title="二、状态机"></a>二、状态机</h1><p>&emsp;&emsp;状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型，一种思想。重复一下：状态机是<strong>有限状态自动机</strong>的简称，是现实事物运行规则抽象而成的一个数学模型。</p><h2 id="2-1-状态机的四大概念"><a href="#2-1-状态机的四大概念" class="headerlink" title="2.1 状态机的四大概念"></a>2.1 状态机的四大概念</h2><ul><li>State ，状态<ul><li>一个状态机至少要包含两个状态。例如bool类型，有 true 和 false 两个状态。</li></ul></li><li>Event ，事件<ul><li>事件就是执行某个操作的触发条件或者口令。不同状态对应产生各自事件。</li></ul></li><li>Action ，动作<ul><li>事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。</li></ul></li><li>Transition ，变换<ul><li>通过多种动作满足一定条件，开始切换状态</li></ul></li></ul><p>&emsp;&emsp;主要概念还是状态，后三者往往在代码实现的时候糅合在一起比较模糊。</p><h2 id="2-2-举例应用"><a href="#2-2-举例应用" class="headerlink" title="2.2 举例应用"></a>2.2 举例应用</h2><p>&emsp;&emsp;状态机，是(快速)写(驱动)程序的好帮手。</p><p>街上的自动售货机中明显能看到状态机逻辑；我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。</p><ul><li>初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。</li><li>状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种。</li><li>到达“已足额付款”状态，还要进行余额清零和弹出汽水操作。然后重新进入初始化状态</li></ul><p>所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。</p><h2 id="2-3-实际代码实现"><a href="#2-3-实际代码实现" class="headerlink" title="2.3 实际代码实现"></a>2.3 实际代码实现</h2><p>&emsp;&emsp;实际从C的代码层面，更容易看到状态机的影子。最经典的就是 <code>switch</code> 和 <code>enum</code> 的搭配了。</p><p><code>switch</code> 罗列出状态机的所有可能状态。<code>enum</code> 产生对应的各种状态。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    DISCONNECT,</span><br><span class="line">    CONNECT,</span><br><span class="line">    RECONNECT,</span><br><span class="line">&#125;_enumGPRSState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(_enumGPRSState GPRSState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(GPRSState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DISCONNECT:<span class="keyword">break</span>;  <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> CONNECT:<span class="keyword">break</span>;     <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> RECONNECT:<span class="keyword">break</span>;   <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">//特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是很常见、很普通的状态机写法，很适用于快速开发底层驱动。当然，这是一个很简单的例子。还有更复杂的状态机，甚至多状态机相互影响切换其他状态机的状态。状态机也只是一种思想而已。</p><p>&emsp;&emsp;可以去看FreeModbus的通讯库。它就是一个很经典的状态机写法，但是涉及到多状态机。它的状态机有：(轮询)事件，串口发送中断，串口接收中断，其中还有个定时器能够变换 串口接收中断 状态机。</p><h2 id="2-4-FreeModbus库讲解-RTU模式为例"><a href="#2-4-FreeModbus库讲解-RTU模式为例" class="headerlink" title="2.4 FreeModbus库讲解(RTU模式为例)"></a>2.4 FreeModbus库讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。写的很好，这份源码还是很推荐看的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式IIC总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FIIC%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式IIC总线/</id>
    <published>2020-05-30T03:17:49.000Z</published>
    <updated>2020-05-30T03:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、IIC总线讲解"><a href="#一、IIC总线讲解" class="headerlink" title="一、IIC总线讲解"></a>一、IIC总线讲解</h1><p>&emsp;&emsp;IIC的硬件管脚为 VCC，GND，SDA，SCL。IIC的主要构成只有两个双向的信号线，一个是数据线SDA,一个是时钟线SCL。IIC总线有主从之分。</p><p>&emsp;&emsp;IIC总线实现的方式分为两种：硬件IIC &amp; 软件模拟IIC。硬件IIC有主从之分；当然，软件I2C也是标准的I2C协议，当然有分主从，但一般情况下，软件IIC为主机模式，即发送请求接收响应信息。为什么要写从机呢？mcu 对 mcu ？)。由于每种MCU的硬件IIC总线配置各不相同，且有些芯片的IIC有Bug(Stm32)，故接下来只讲 软件IIC。</p><ul><li>由于实际应用上，IIC总线通讯速率本身就不高，因此，硬件IIC总线 &amp; 软件IIC总线<br>本身速率方面就没多差大差距，不需要考虑IIC总线切换为软、硬件实现方式会给程序带来隐患。</li><li>无论是 硬件IIC 还是 软件IIC ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应IIC从器件的datasheet。IIC总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><h1 id="二、-软件-IIC总线"><a href="#二、-软件-IIC总线" class="headerlink" title="二、 (软件)IIC总线"></a>二、 (软件)IIC总线</h1><h2 id="2-1-基本知识"><a href="#2-1-基本知识" class="headerlink" title="2.1 基本知识"></a>2.1 基本知识</h2><p>&emsp;&emsp;软件IIC，也能更好让我们了解IIC总线协议的实现方式。</p><img src="/2020/05/30/嵌入式IIC总线/0.png" title="IIC总线"><p>&emsp;&emsp;<strong>I2C总线通过上拉电阻接正电源。即当总线空闲时，两根线均为高电平</strong>。如此，连在总线上的任一器件输出的低电平，都可以使得总线的信号变低，也就是说各器件的SDA和SCL都是线”与”关系。 </p><img src="/2020/05/30/嵌入式IIC总线/1.png" title="数据有效性规定"><p>数据位(1\0)有效性规定：<strong>I2C总线进行数据传送时，时钟信号为高电平期间，SDA线上的数据必须保持稳定</strong>；只有在SCL线的信号为低电平器件，SDA线的才可进行高低电平状态变化。</p><blockquote><p>起始信号、终止信号、应答信号</p></blockquote><img src="/2020/05/30/嵌入式IIC总线/2.png" title="起始信号和终止信号"><ul><li>起始信号：SCL线为高电平期间，SDA线由高电平向低电平跳变(下降沿)—-是一种电平跳变时序信号</li><li>终止信号：SCL线为高电平期间，SDA线由低电平向高电平跳变(上升沿)—-是一种电平跳变的时序信号</li></ul><img src="/2020/05/30/嵌入式IIC总线/3.png" title="应答信号"><ul><li>应答信号：在接收数据的IC(接收器)在接收到8bit数据后，向发送数据的IC(发送器)发出特定的低电平脉冲，表示已收到数据。即发送器在时钟脉冲9期间释放数据线，这样接收器就可以反馈一个应答信号。ACK(低电平)—-规定为有效应答位，NACK(高电平)，规定为非应答位，表示接收器接收该字节咩有成功。</li></ul><h2 id="2-2-软件模拟IIC驱动程序函数编写"><a href="#2-2-软件模拟IIC驱动程序函数编写" class="headerlink" title="2.2 软件模拟IIC驱动程序函数编写"></a>2.2 软件模拟IIC驱动程序函数编写</h2><p>&emsp;&emsp;在IIC程序设计中，都是以8bit为基础进行数据的传输</p><img src="/2020/05/30/嵌入式IIC总线/4.png" title="信号要求"><ul><li>IO管教初始化</li><li>发出起始信号</li><li>发出终止信号</li><li>发出应答ACK<ul><li>功能要求：由于IIC为双向数据通信，当从机发送完数据，主机也需要发送应答信号来说我接收到你的信息了，此时从机才可变为接收状态，接收来自主机的数据。</li></ul></li><li>发出应答NACK<ul><li>功能要求：当IIC程序运行到主机读取从机数据完成，需要停止此次数据传输时，主机发送一个发出主无应答信号，从机接收到后就停止发送数据，并释放SDA线；之后主机才可发送终止信号，停止此次数据的传输。</li></ul></li><li>发送一个字节数据<ul><li>基本思路：SCL在为0时，可以进行SDA数据的配置，当SCL为1时，SDA数据一定要锁定。其次为数据的移位，将待发送数据与0x80进行与运算，获得最高位的数据，通过8次循环完成1byte的数据发送。</li></ul></li><li>读取一个字节，并发送ACK或NACK(发送NACK基通知从机发送器结束数据发送，释放SDA线(SDA接口置1)<ul><li>功能要求：发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号(故读取完需要发送 ACK 或 NACK )</li></ul></li><li>等待ACK应答<ul><li>功能要求：当IIC主机进行获取数值时，主机需要等待从机的应答信号，以此来判断从机是否完成了数据的接收。从主机方看，为IIC等待ASK函数。</li><li>基本思路：通过 延时等待从机的ACK是否发送出来，如果发送出来，则函数返回0，主机可继续发送数据，如果返回1，则从机没有应答，此时需要停止IIC数据传输。防止出现错误数据。</li></ul></li></ul><h2 id="2-3-从具体I2C器件中读写数据"><a href="#2-3-从具体I2C器件中读写数据" class="headerlink" title="2.3 从具体I2C器件中读写数据"></a>2.3 从具体I2C器件中读写数据</h2><blockquote><p><strong>主机写(发送)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/5.png" title="主机写从机数据"><blockquote><p><strong>主机读(接收)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/6.png" title="主机读从机数据"><p><strong><font color="red">Ps：</font>IIC器件往往是 器件地址+0 为写数据 ，器件地址+1 为读数据</strong></p><p>主机读从机的情况分为两种：</p><ul><li><strong>读操作之前，都是需要进行一次写操作(写入读地址)，表明你要读的是哪个地址的数据，然后在进行一次读操作(故有两个器件地址)；</strong>(这是一般情况)</li><li>直接进行读操作，截取所需数据段</li></ul><p>&emsp;&emsp;因为有些IIC器件(从机)，例如24C02，当你需要读取它的数据，你要跟它说读取哪个地址数据，故先进行写操作；有些IIC器件，例如SD2403，它的时间日期地址是固定的（寄存器地址：00H-06H），因此读取该器件数据时，直接进行读操作，然后读出来7个数据，截取00H-06H的数据后，停止读取(这是特殊情况)</p><blockquote><p>DEVICEADDRESS(器件地址)</p></blockquote><p>&emsp;&emsp;器件地址的8位地址信息因器件而异；</p><h1 id="三、软件IIC实例"><a href="#三、软件IIC实例" class="headerlink" title="三、软件IIC实例"></a>三、软件IIC实例</h1><h2 id="3-1-EEPROM-24C02通信基础——IIC协议"><a href="#3-1-EEPROM-24C02通信基础——IIC协议" class="headerlink" title="3.1 EEPROM_24C02通信基础——IIC协议"></a>3.1 EEPROM_24C02通信基础——IIC协议</h2><p>&emsp;&emsp;24C02是一个可储存 256(8bit)字节数据的EEPROM，因此他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/7.png" title="24C02地址信息"><p>据2.3.1图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteOneByte</span><span class="params">(u16 WriteAddr, u8 DataToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_Starts();<span class="comment">//发出起始信号</span></span><br><span class="line">IIC_Send_Byte(<span class="number">0xA0</span>);<span class="comment">//写器件地址+写操作</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(WriteAddr&gt;&gt;8);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(WriteAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Send_Byte(DataToWrite);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Stop();</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//等AT24C02写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3.1图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">AT24CXX_ReadOneByte</span><span class="params">(u16 ReadAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 temp=<span class="number">0</span>;</span><br><span class="line">IIC_Start();  </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA0</span>);<span class="comment">//发送器件地址0XA0,写操作</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(ReadAddr/256);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(ReadAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();    </span><br><span class="line">IIC_Start();      </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA1</span>);<span class="comment">//进入接收模式</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line">temp=IIC_Read_Byte(<span class="number">0</span>);<span class="comment">//读一个字节数据完成，并发出No_Ack(输入参数：0)</span></span><br><span class="line">IIC_Stop();    </span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-24C02程序拓展——datasheet"><a href="#3-2-24C02程序拓展——datasheet" class="headerlink" title="3.2 24C02程序拓展——datasheet"></a>3.2 24C02程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于写入16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//WriteAddr  :开始写入的地址  </span></span><br><span class="line"><span class="comment">//DataToWrite:数据数组首地址</span></span><br><span class="line"><span class="comment">//Len        :要写入数据的长度2,4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteLenByte</span><span class="params">(u16 WriteAddr,u32 DataToWrite,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite&gt;&gt;(<span class="number">8</span>*t))&amp;<span class="number">0xff</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于读出16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//ReadAddr   :开始读出的地址 </span></span><br><span class="line"><span class="comment">//返回值     :数据</span></span><br><span class="line"><span class="comment">//Len        :要读出数据的长度2,4</span></span><br><span class="line"><span class="function">u32 <span class="title">AT24CXX_ReadLenByte</span><span class="params">(u16 ReadAddr,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line">u32 temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t<span class="number">-1</span>);     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查AT24CXX是否正常</span></span><br><span class="line"><span class="comment">//这里用了24XX的最后一个地址(255)来存储标志字.</span></span><br><span class="line"><span class="comment">//如果用其他24C系列,这个地址要修改</span></span><br><span class="line"><span class="comment">//返回1:检测失败</span></span><br><span class="line"><span class="comment">//返回0:检测成功</span></span><br><span class="line"><span class="function">u8 <span class="title">AT24CXX_Check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 temp;</span><br><span class="line">temp=AT24CXX_ReadOneByte(<span class="number">255</span>);<span class="comment">//避免每次开机都写AT24CXX   </span></span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">else</span><span class="comment">//排除第一次初始化的情况</span></span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(<span class="number">255</span>,<span class="number">0X55</span>);</span><br><span class="line">    temp=AT24CXX_ReadOneByte(<span class="number">255</span>);  </span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出指定个数的数据</span></span><br><span class="line"><span class="comment">//ReadAddr :开始读出的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer  :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToRead:要读出数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Read</span><span class="params">(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToRead)</span><br><span class="line">&#123;</span><br><span class="line">*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);</span><br><span class="line">NumToRead--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入指定个数的数据</span></span><br><span class="line"><span class="comment">//WriteAddr :开始写入的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer   :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToWrite:要写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Write</span><span class="params">(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToWrite--)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr,*pBuffer);</span><br><span class="line">WriteAddr++;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-实时时钟-SD2403——IIC总线"><a href="#3-3-实时时钟-SD2403——IIC总线" class="headerlink" title="3.3 实时时钟_SD2403——IIC总线"></a>3.3 实时时钟_SD2403——IIC总线</h2><p>&emsp;&emsp;SD2403是一个实时时钟，他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/8.png" title="SD2403地址信息"><p>据2.3图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteOneByte</span><span class="params">(<span class="keyword">uint8_t</span> addr,<span class="keyword">uint8_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(addr);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(data);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReakOneByte(<span class="keyword">uint8_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint8_t</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//先写入要读取的寄存器</span></span><br><span class="line"><span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);  </span><br><span class="line"><span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">&#123;</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SD2403_SendByte(addr); </span><br><span class="line">SD2403_WaitAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">//再读取的寄存器数据</span></span><br><span class="line">SD2403_start();</span><br><span class="line">SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">res=SD2403_ReceiveByte(<span class="number">0</span>); </span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-SD2403程序拓展——datasheet"><a href="#3-4-SD2403程序拓展——datasheet" class="headerlink" title="3.4 SD2403程序拓展——datasheet"></a>3.4 SD2403程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReadTimeDate(_strTimeDate *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i,dat[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat[i]=SD2403_ReceiveByte();</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            dat[<span class="number">2</span>]=BCDTODEC(dat[<span class="number">2</span>]&amp;<span class="number">0x7F</span>);<span class="comment">//24小时舍弃最高位(区分12/24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dat[i]=BCDTODEC(dat[i]);</span><br><span class="line">        *(&amp;pstrTimeDate-&gt;ucSec +i)=dat[i];</span><br><span class="line">        <span class="keyword">if</span> (i!=<span class="number">6</span>)         <span class="comment">//最后一个数据不应答</span></span><br><span class="line">        &#123;</span><br><span class="line">            SD2403_ACK();<span class="comment">////ACK 低</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_No_ACK();<span class="comment">//ACK 高结束</span></span><br><span class="line">    SD2403_stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint8_t</span> SD2403_WriteTimeDate(<span class="keyword">uint8_t</span> *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *set_time,i;</span><br><span class="line">    set_time=pstrTimeDate;</span><br><span class="line">    SD2403_WriteTimeOn();</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x00</span>);<span class="comment">//设置写起始地址</span></span><br><span class="line">    SD2403_WaitAck();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            SD2403_SendByte(<span class="number">0x80</span>|DECTOBCD(*set_time));<span class="comment">//最高位区分12/24小时制(1为24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SD2403_SendByte(DECTOBCD(*set_time));</span><br><span class="line">        SD2403_WaitAck();</span><br><span class="line">        set_time++;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_stop();</span><br><span class="line">    SD2403_WriteTimeOff();</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403允许程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0x80</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0x84</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403禁止程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOff</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">      SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、拓展——软件IIC从机"><a href="#四、拓展——软件IIC从机" class="headerlink" title="四、拓展——软件IIC从机"></a>四、拓展——软件IIC从机</h1><p>&emsp;&emsp;要实现IIC从机功能，最核心的部分就是如何精确的抓住IIC_SCL，也就是IIC主机发出来的时钟信号。只有抓住精确的时钟SCL，才能正确的读取到SDA的数据，才能真正模拟出IIC时序。</p><p>&emsp;&emsp;但是要抓住SCL信号可不容易，IIC最高速度有400K，最小有效脉宽达到1.4us(数字0/1)，最小脉冲是0.8us(应答和STOP信号产生的尖刺)，采用中断来识别SCL是不可能的做到的，因为即使在最高主频72MHZ情况下，STM32最小指令周期是1/72(us)，从SCL中断发生到STM32进入中断响应，至少要要40个指令周期，也就是40/72(us)，加上堆栈操作及变量，很可能已经错过了SCL信号。</p><p>因此根据IIC主机的速度，从机实现方法分为两种：</p><ol><li>采用中断方式识别SCL(适用于总线速度较慢)</li><li>采用查询方式识别SCL(适用于总线速度较快)</li></ol><p>&emsp;&emsp;反过来言之，当你做成一个(从机)模块，实现软件模拟IIC，实际上还会因为IIC主机的因素来决定你这个模块的实际使用效果。如果是做模块化，还是推荐使用硬件IIC的方式实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="IIC" scheme="http://shatang.github.io/tags/IIC/"/>
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式SPI总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FSPI%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式SPI总线/</id>
    <published>2020-05-30T03:14:26.000Z</published>
    <updated>2020-05-30T03:23:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、SPI总线讲解"><a href="#一、SPI总线讲解" class="headerlink" title="一、SPI总线讲解"></a>一、SPI总线讲解</h1><p>&emsp;&emsp;SPI的主要构成有三根线，一个是数据输出线MOSI,一个是数据输入线MISO，一个是时钟线SCLK。</p><p>&emsp;&emsp;SPI总线实现的方式分为两种：硬件IIC &amp; 软件模拟SPI。硬件SPI有主从之分；当然，软件SPI也是标准的SPI协议，当然有分主从，但一般情况下，(MCU)软件SPI为主机模式，即发送请求接收从机的响应信息。</p><p>&emsp;&emsp;可能大家不知道为什么我这MCU就是SPI主机，凭啥？你可以反过来想一下，MCU通讯的其他器件实质上都是从机，MCU要你的数据才会去找你；如果你MCU也是从机模式，从机与从机怎么通信？由于每种MCU的硬件SPI总线配置各不相同，故接下来主要讲 软件SPI。</p><ul><li>SPI通信是串行同步全双工(同时收发)</li><li>IIC通信是串行同步半双工(单收或单发)</li><li>无论是 硬件SPI 还是 软件SPI ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应SPI从器件的datasheet。SPI总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><p><strong><font color="red">Ps：</font>硬件SPI总线 &amp; 软件SPI总线 速率方面是有点差距的。具体没有实测，但是既然是用了软件SPI总线，就不要纠结速度问题了。但是硬件SPI总线的速度也不是无上限的，而且还要根据主、从机的配置。</strong></p><hr><p>&emsp;&emsp;以W5500为例，该芯片的SPI总线速率最高达到80Mhz。如果主控采用stm32f103,主频为72Mhz，SPI时钟最大为18Mhz。因此stm32f103无法发挥W5500完全的性能。</p><p>&emsp;&emsp;而如果使用STM40x处理器，SPI时钟使用42Mhz，使用DMA方式，可以达到回环测试17Mbps的速率（收+发），单独发送可以达到13Mbps的速率。</p><p>&emsp;&emsp;也就是说，SPI的速率本身就受器件限制。如果从机SPI时钟较低，主机被限制；主机时钟较低，从机性能被限制。编写硬件SPI驱动的时候，要多注意 主控芯片、从机器件 的datasheet。</p><h1 id="二、-主机-软件SPI总线"><a href="#二、-主机-软件SPI总线" class="headerlink" title="二、(主机)软件SPI总线"></a>二、(主机)软件SPI总线</h1><p>&emsp;&emsp;硬件上为4根线：</p><ul><li><code>MISO</code> ：主设备数据输入，从设备数据输出。</li><li><code>MOSI</code> ：主设备数据输出，从设备数据输入。</li><li><code>SCLK</code> ：时钟信号，由主设备产生。</li><li><code>CS</code> ：从设备片选信号，由主设备控制。</li></ul><p><strong><font color="red">Ps：</font>外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。</strong></p><img src="/2020/05/30/嵌入式SPI总线/1.png" title="硬件SPI时钟信号的相位和极性"><p>&emsp;&emsp;由上图的(硬件)SPI通信协议可知，时钟信号的相位和极性，决定了获取数据的方式；2*2=4，于是有四种模式；</p><img src="/2020/05/30/嵌入式SPI总线/2.png" title="SPI通信模式"><p>CPOL决定时钟空闲状态(1为空闲高电平，0为空闲低电平)</p><img src="/2020/05/30/嵌入式SPI总线/3.png" title="SPI通信模式"><p>CPHA决定获取数据的时钟相位(1为延迟一个相位，第二次SCLK突变为空闲状态获取数据；0为直接相位，SCLK空闲状态突变时，直接获取数据)</p><img src="/2020/05/30/嵌入式SPI总线/4.png" title="SPI通信模式总结"><p>&emsp;&emsp;以上就是软件SPI的要点；实现具体的软件SPI，需要对器件的datasheet进行查阅，看是哪种模式。</p><table><thead><tr><th>模式</th><th>CPOL</th><th>CPHA</th></tr></thead><tbody><tr><td>MODE0</td><td>0</td><td>0</td></tr><tr><td>MODE1</td><td>0</td><td>1</td></tr><tr><td>MODE2</td><td>1</td><td>0</td></tr><tr><td>MODE3</td><td>1</td><td>1</td></tr></tbody></table><p>下面简单列一个 CPOL=1，CPHA=1的SPI写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">函数：SOFT_SPI_RW() </span></span><br><span class="line"><span class="comment">描述: 根据SPI协议，写一字节数据到从机，同时从从机 读出一字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function">u8 <span class="title">SOFT_SPI_RW</span><span class="params">(u8 byte)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u8 i,Temp=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">// 循环8次 </span></span><br><span class="line">&#123; </span><br><span class="line">SPI1_SCK = <span class="number">0</span><span class="comment">//拉低时钟</span></span><br><span class="line"><span class="keyword">if</span>(byte&amp;<span class="number">0x80</span>)</span><br><span class="line">SPI1_MOSI = <span class="number">1</span>;<span class="comment">//若最到位为高，则输出高</span></span><br><span class="line"> <span class="keyword">else</span>       </span><br><span class="line">SPI1_MOSI = <span class="number">0</span>;<span class="comment">//若最到位为低，则输出低 </span></span><br><span class="line">byte &lt;&lt;= <span class="number">1</span>;<span class="comment">//低一位移位到最高位 </span></span><br><span class="line">SPI1_SCK = <span class="number">1</span>;<span class="comment">//拉高时钟</span></span><br><span class="line">Temp &lt;&lt;= <span class="number">1</span>;<span class="comment">//数据左移 </span></span><br><span class="line"><span class="keyword">if</span>(SPI1_MISO) </span><br><span class="line">Temp++;<span class="comment">//若从从机接收到高电平，数据自加一</span></span><br><span class="line"> SPI1_SCK = <span class="number">0</span>;<span class="comment">//拉低时钟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Temp);<span class="comment">//返回数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-FRAM-FM25L256为例——软件SPI"><a href="#2-1-FRAM-FM25L256为例——软件SPI" class="headerlink" title="2.1 FRAM_FM25L256为例——软件SPI"></a>2.1 FRAM_FM25L256为例——软件SPI</h2><p>&emsp;&emsp;FM25L256支持SPI模式的0和3，下面为CPOL=1，CPHA=1。基本的字节读写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  向存储器中写入一个字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write8bits</span><span class="params">(<span class="keyword">uint8_t</span> u8Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u8Data &amp; <span class="number">0x80</span>)         </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>          </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  从存储器中读出一个字节的数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">FRAM_Read8bits</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Data=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        <span class="keyword">if</span>(FRAM_SDO_READ)</span><br><span class="line">            u8Data |= <span class="number">0x01</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    <span class="keyword">return</span>  u8Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-FRAM-FM25L256程序扩展——datasheet"><a href="#2-2-FRAM-FM25L256程序扩展——datasheet" class="headerlink" title="2.2 FRAM_FM25L256程序扩展——datasheet"></a>2.2 FRAM_FM25L256程序扩展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write16bits</span></span><br><span class="line"><span class="comment">* 功  能 :  发送16位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write16bits</span><span class="params">(<span class="keyword">uint16_t</span> u16Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u16Data &amp; <span class="number">0x8000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>                 </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u16Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write32bits</span></span><br><span class="line"><span class="comment">* 返  回 :  写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write32bits</span><span class="params">(<span class="keyword">uint32_t</span> u32Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u32Data &amp; <span class="number">0x80000000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>              </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u32Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  读取指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 读取数据的首地址</span></span><br><span class="line"><span class="comment">* 返  回 :  uint32_t : 读出的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="keyword">uint32_t</span> FRAM_Read4Bytes(<span class="keyword">uint32_t</span> address)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_READ);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp  = temp &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        temp |= FRAM_Read8bits();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  写入指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 写入数据的首地址</span></span><br><span class="line"><span class="comment">*           FramData : 写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FRAM_Write4Bytes</span><span class="params">(<span class="keyword">uint32_t</span> address, <span class="keyword">uint32_t</span> FramData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WREN);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WRITE);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    FRAM_Write32bits(FramData);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_L;</span><br><span class="line">        FRAM_Write8bits(FRAM_CMD_RDSR);<span class="comment">//读取状态寄存器</span></span><br><span class="line">        u8Temp = FRAM_Read8bits();</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_H;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该位表示写入启用状态(为0时，WPEN和 /WP 寄存器标志位不起作用)</span></span><br><span class="line"><span class="comment">//防止软件误改动铁电芯片寄存器配置</span></span><br><span class="line">        <span class="keyword">if</span>(!(u8Temp &amp; <span class="number">0x02</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
      <category term="SPI" scheme="http://shatang.github.io/tags/SPI/"/>
    
  </entry>
  
</feed>
