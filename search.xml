<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[谢幕]]></title>
    <url>%2F2024%2F05%2F01%2F%E8%B0%A2%E5%B9%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;时间真的过得飞快啊，一下子恍惚三年多就过去了，而且还是疫情的三年。&emsp;&emsp;期间经历很多事，就算是疫情，现在也觉得是有点遥远的事情了，博客也是长久没更新。其实我是花了不少时间在语雀上记录笔记、经历，用hexo博客终究是不太方便，就算这个帖子也花了我不少时间上传，要重新装node、hexo的环境。&emsp;&emsp;不管是用什么平台，只要有坚持记录、归纳就行。至于平台则是选择尽量省心的，把多出来的精力记录更多。因此这帖应该是我hexo博客的最后一帖，该谢幕了。&emsp;&emsp;虽说是谢幕，其实是新的开始。欢迎大家来到我的语雀：https://www.yuque.com/shatang-sgdju。更新、整理了不少东西公开出来，还有一些还在重新梳理，不好意思公开。原本要是不公开还好，烂在里面、摆烂是无所谓；为了督促自己的状态，开始逐步重新整理公开。错别字啊，排版不适啊，描述得不够清楚要重新改一下啊，同时重温以前的知识点啊（淦），又突然发现以前理解的知识点有问题要改下啊，各种各样，真的有点烧脑，整理真的是一件痛苦的事。看着以前的博客想起以前养的猫，真的是有种时光恍惚感。&emsp;&emsp;今天是个很好的日子，希望能够五一假期能多多整点东西，玩也能尽情玩；不管做啥事都能专注于当前的事，做个纯粹的人。 &emsp;&emsp;还是那样：靡不有初，鲜克有终。不求过程有多好，哪怕踉踉跄跄，也要慢慢走下去啊。 特此记录，2024.05.01]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这段时间的经历21.03.16]]></title>
    <url>%2F2021%2F03%2F16%2F%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%8F%E5%8E%8621-03-16%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大概算了一下，距离上次的博客都快半年了。那我是太久偷懒没学习了？当然也不是= =。 &emsp;&emsp;就不说hexo博客本身排版、卡顿的问题了，时不时还因为node的高版本导致hexo博客上传异常= =，那个时候中期用有道云markdown同时双更新，确实是很累人的，而且有道云搞起来也很麻烦，连贴个图都要会员= =，虽然用其他方式实现了但是变得很繁琐了。后面的更新懒了，直接只更新有道云，但是它对知识整理确实是emmm的差（毕竟都在用，不能太嫌弃）。 &emsp;&emsp;直到有一天，我用了一个阿里系的软件：语雀，来整理笔记。确实是大大方便了笔记整理，这里也是推荐一下。我立马把笔记从有道云里重新整理迁移至语雀。然后markdown编辑器也换成了VNote，变得方便了许多。 &emsp;&emsp;不过最最重要的，还是偶然打开github，发现别人给我的一些库star，而且留言have fun；还有其他人fork了我的github.io。然后想起了自己搭博客留给自己的话It's not hard to give up, but it must be cool to stick to it.，又有了点动力（说不定等下又没了，哈哈）。 &emsp;&emsp;我本来就不求过程有多好，哪怕是很烂，一下子断更半年，那又怎样？有头有尾就行了，看不到尾，那就慢慢坚持下去就行了，又有谁知道自己终点的？ 特此记录，2021.03.16]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FatFs文件系统]]></title>
    <url>%2F2020%2F09%2F22%2FFatFs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大部分知识点来源于正点原子的ppt资料，我只是将其汇总并加一些个人理解。 一、文件系统1.1 文件系统是什么？&emsp;&emsp;负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。即在磁盘上组织文件的方法。 1.2 常用的文件系统有哪些？ FAT / FATFS NTFS: 基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构 CDFS：CDFS是大部分的光盘的文件系统 exFAT 1.3 FATFS文件系统的特点&emsp;&emsp;FATFS是一个完全免费开源的FAT 文件系统模块，专门为小型的嵌入式系统而设计。完全用标准C 语言编写，所以具有良好的硬件平台独立性。可以移植到8051、PIC、AVR、SH、Z80、H8、ARM 等系列单片机上而只需做简单的修改。它支持FAT12、FAT16 和FAT32，支持多个存储媒介；有独立的缓冲区，可以对多个文件进行读／写，并特别对8 位单片机和16 位单片机做了优化。 Ps： FATFS是可裁剪的文件系统(专门为小型嵌入式设计)。 Windows兼容的FAT文件系统（支持FAT12/FAT16/FAT32） 与平台无关，移植简单。全C语言编写。 代码量少、效率高。 多种配置选项 支持多卷（物理驱动器或分区，最多10个卷） 多个ANSI/OEM代码页包括DBCS 支持长文件名、ANSI/OEM或Unicode 支持RTOS 支持多种扇区大小 只读、最小化的API和I/O缓冲区等 二、FATFS系统结构2.1 FATFS模块的层次结构图 底层接口，包括存储媒介读／写接口（disk I/O）和供给文件创建修改时间的实时时钟，需要我们根据平台和存储介质编写移植代码。 中间层FATFS模块，实现了FAT 文件读／写协议。FATFS模块提供的是ff.c和ff.h。除非有必要，使用者一般不用修改，使用时将头文件直接包含进去即可。 最顶层是应用层，使用者无需理会FATFS的内部结构和复杂的FAT 协议，只需要调用FATFS模块提供给用户的一系列应用接口函数，如f_open，f_read，f_write 和f_close等，就可以像在PC 上读／写文件那样简单。 2.2 FATFS文件系统包结构 文件名 功能 说明 ffconf.h FATFS模块配置文件 需要根据需求来配置参数。 ff.h 文件系统实现头文件，定义有文件系统所需的数据结构 不需要修改 ff.c 文件系统实现源码 不需要修改 diskio.h 底层驱动头文件，就一些状态宏的定义和底层驱动函数的申明 不需要修改 diskio.c 储存介质底层驱动文件 与平台相关的代码,需要用户根据存储介质来编写函数。 interger.h 仅实现数据类型重定义,增加系统的可移植性 与编译器有关。 option文件夹 可选的外部功能（比如支持中文等） 汉字实验把字库放到SPI FLASH需要修改 &emsp;&emsp;FATFS模块在移植的时候，我们一般只需要修改2个文件，即ffconf.h和diskio.c。FATFS模块的所有配置项都是存放在ffconf.h里面，我们可以通过配置里面的一些选项，来满足自己的需求。diskio.c是硬件层，负责与底层硬件接口适配。 diskio.c和diskio.h是硬件层。 ff.c和ff.h是FatFs的文件系统层和文件系统的API层。 Ps： 大部分的可移植的小系统或者应用，都是采用类似这种将与底层打交道的源码开发给用户编写，然后提供顶层配置文件供配置。 2.3 FATFS关键配置文件: ffconf.h _FS_TINY。这个选项在R0.07版本中开始出现，之前的版本都是以独立的C文件出现（FATFS和Tiny FATFS），有了这个选项之后，两者整合在一起了，使用起来更方便。我们使用FATFS，所以把这个选项定义为0即可。 _FS_READONLY。这个用来配置是不是只读，本章我们需要读写都用，所以这里设置为0即可。 _USE_STRFUNC。这个用来设置是否支持字符串类操作，比如f_putc，f_puts等，本章我们需要用到，故设置这里为1。 _USE_MKFS。这个用来定时是否使能格式化，本章需要用到，所以设置这里为1。 _USE_FASTSEEK。这个用来使能快速定位，我们设置为1，使能快速定位。 _USE_LABEL。这个用来设置是否支持磁盘盘符（磁盘名字）读取与设置。我们设置为1，使能，就可以通过相关函数来读取和设置磁盘的名字了。 _CODE_PAGE。这个用于设置语言类型，包括很多选项（见FATFS官网说明），我们这里设置为936，即简体中文（GBK码，需要c936.c文件支持，该文件在option文件夹）。 _USE_LFN。该选项用于设置是否支持长文件名（还需要_CODE_PAGE支持），取值范围为0~3。0，表示不支持长文件名，1~3是支持长文件名，但是存储地方不一样，我们选择使用3，通过ff_memalloc函数来动态分配长文件名的存储区域。 _VOLUMES。用于设置FATFS支持的逻辑设备数目，我们设置为3的话，即支持3个设备（磁盘）。 _MAX_SS。扇区缓冲的最大值，一般设置为512。 2.4 FatFs提供的函数API 函数API 实现功能 f_mount 注册/注销一个工作区域（Work Area） f_open 打开/创建一个文件 f_close 关闭一个文件 f_read 读文件 f_write 写文件 f_lseek 移动文件读/写指针 f_truncate 截断文件 f_sync 冲洗缓冲数据 Flush Cached Data f_forward 直接转移文件数据到一个数据流 f_stat 获取文件状态 f_opendir 打开一个目录 f_closedir 关闭一个已经打开的目录 f_readdir 读取目录条目 f_mkdir 创建一个目录 f_unlink 删除一个文件或目录 f_chmod 改变属性（Attribute） f_utime 改变时间戳（Timestamp） f_rename 重命名/移动一个文件或文件夹 f_chdir 改变当前目录 f_chdrive 改变当前驱动器 f_getcwd 获取当前工作目录 f_getfree 获取空闲簇 Get Free Clusters f_getlabel Get volume label f_setlabel Set volume label f_mkfs 在驱动器上创建一个文件系统 f_fdisk Divide a physical drive f_gets 读一个字符串 f_putc 写一个字符 f_puts 写一个字符串 f_printf 写一个格式化的字符串 f_tell 获取当前读/写指针 f_eof 测试文件结束 f_size 获取文件大小 f_error 测试文件上的错误 2.5 底层磁盘I/O模块&emsp;&emsp;因为FatFs模块完全与磁盘I/O层分开，因此需要下面的函数来实现底层物理磁盘的读写与获取当前时间。底层磁盘I/O模块并不是FatFs的一部分，并且必须由用户提供。 函数名 函数功能 disk_initialize Initialize disk drive 初始化磁盘驱动器 disk_status Get disk status 获取磁盘状态 disk_read Read sector(s) 读扇区 disk_write Write sector(s) 写扇区 disk_ioctl Control device dependent features 设备相关的控制特性 get_fattime Get current time 获取当前时间 &emsp;&emsp;若想看具体详细参数，如下所示： 三、FATFS系统移植3.1 FatFs移植步骤思路 数据类型：在integer.h 里面去定义好数据的类型。这里需要了解你用的编译器的数据类型，并根据编译器定义好数据类型。 配置：通过ffconf.h配置FATFS的相关功能，以满足你的需要。 函数编写：打开diskio.c，进行底层驱动编写，一般需要编写6 个接口函数：即上面底层磁盘I/O模块 3.2 实例&emsp;&emsp;基于Stm32F407的SD卡升级&emsp;&emsp;基于Stm32F407的U盘Host，USB_FS升级&emsp;&emsp;基于Stm32F407的U盘Host，USB_HS复用为USB_FS升级 &emsp;&emsp;常见：如果你使用了FatFs文件系统做嵌入式Bootloader的U盘升级APP，如果插入的U盘是NTFS文件系统，则会导致无法识别文件进行升级！ 3.3 U盘驱动的知识3.3.1 USB中cdc、dfu、hid、msc的区别 cdc : communication device class CDC是通信设备级方案，是USB 转其他的接口的一类设备，比如USB转RS232，USB转Ethernet等 dfu : Device Firmware Upgrade DFU主要使用USB接口，实现固件的上传与下载 hid : humman interface device HID人机接口级方案，多为不需要驱动的键盘鼠标等 msc: mass storage class MSC大容量存储方案，多为移动存储设备 3.3.2 STM32 HS端口改为FS步骤stm32 HS端口改为FS步骤： 在usb_conf.h文件中 使能#define USE_USB_OTG_HS 宏 使能#define USE_EMBEDDED_PHY 宏 禁止#define USE_ULPI_PHY 宏 禁止#define VBUS_SENSING_ENABLED 宏 在usbd_user.c文件中，将原来的中断函数由 1234567891011void OTG_FS_IRQHandler(void)&#123; USBD_OTG_ISR_Handler(&amp;USB_OTG_dev);&#125;//改为下面的void OTG_HS_IRQHandler(void)&#123; USBD_OTG_ISR_Handler(&amp;USB_OTG_dev);&#125; 在usb_bsp.c中GPIO初始化其中语句 1234567891011121314//先将管脚基本配置弄好，例如原本USB_FS的PA11和PA12，现改成USB_HS的PB14和PB15//再执行下面的操作RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE);GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_OTG_FS);GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_OTG_FS);//改为下面的RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_OTG_HS, ENABLE);RCC_AHB1PeriphClockLPModeCmd(RCC_AHB1Periph_OTG_HS_ULPI, DISABLE);/* USB OTG HS ULPI clock Disabled */GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_OTG_HS_FS);GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_OTG_HS_FS); 在usb_bsp.c中使能中断USB_OTG_BSP_EnableInterrupt函数 123456789void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE * pdev)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn; //OTG_FS_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure);&#125; 在调用USB初始化时，记得切换为HS的ID 12//初始化USB主机USBH_Init(&amp;USB_OTG_Core,USB_OTG_HS_CORE_ID,&amp;USB_Host,&amp;USBH_MSC_cb,&amp;USR_Callbacks); 如此就可以正常将USB HS修改为FS使用了。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>IAP</tag>
        <tag>FatFs</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正点原子例程_内存管理(转)]]></title>
    <url>%2F2020%2F09%2F20%2F%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E4%BE%8B%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇内容的代码例程来自正点原子，讲解分析来自于这位博主郭志凯。因为本身涉及到的知识不多，因此该篇内容99.99%都是从博主那里转过来的。 一、Malloc.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#ifndef __MALLOC_H#define __MALLOC_H#include "stm32f10x.h"////////////////////////////////////////////////////////////////////////////////// //本程序只供学习使用，未经作者许可，不得用于其它任何用途//ALIENTEK战舰STM32开发板V3//内存管理 驱动代码 //正点原子@ALIENTEK//技术论坛:www.openedv.com//修改日期:2015/1/20//版本：V1.0//版权所有，盗版必究。//Copyright(C) 广州市星翼电子科技有限公司 2009-2019//All rights reserved ////////////////////////////////////////////////////////////////////////////////// #ifndef NULL#define NULL 0#endif //定义两个内存池#define SRAMIN 0 //内部内存池#define SRAMEX 1 //外部内存池 #define SRAMBANK 2 //定义支持的SRAM块数. //mem1内存参数设定.mem1完全处于内部SRAM里面.#define MEM1_BLOCK_SIZE 32 //内存块大小为32字节#define MEM1_MAX_SIZE 35*1024 //最大管理内存 40K#define MEM1_ALLOC_TABLE_SIZE MEM1_MAX_SIZE/MEM1_BLOCK_SIZE //内存表大小//mem2内存参数设定.mem2的内存池处于外部SRAM里面#define MEM2_BLOCK_SIZE 32 //内存块大小为32字节#define MEM2_MAX_SIZE 800 *1024 //最大管理内存960K#define MEM2_ALLOC_TABLE_SIZE MEM2_MAX_SIZE/MEM2_BLOCK_SIZE //内存表大小 //内存管理控制器struct _m_mallco_dev&#123; void (*init)(u8); //初始化 u8 (*perused)(u8); //内存使用率 u8 *membase[SRAMBANK]; //内存池 管理SRAMBANK个区域的内存 u16 *memmap[SRAMBANK]; //内存管理状态表 u8 memrdy[SRAMBANK]; //内存管理是否就绪&#125;;extern struct _m_mallco_dev mallco_dev; //在mallco.c里面定义void mymemset(void *s,u8 c,u32 count); //设置内存void mymemcpy(void *des,void *src,u32 n);//复制内存 void my_mem_init(u8 memx); //内存管理初始化函数(外/内部调用)u32 my_mem_malloc(u8 memx,u32 size); //内存分配(内部调用)u8 my_mem_free(u8 memx,u32 offset); //内存释放(内部调用)u8 my_mem_perused(u8 memx); //获得内存使用率(外/内部调用) //////////////////////////////////////////////////////////////////////////////////用户调用函数void myfree(u8 memx,void *ptr); //内存释放(外部调用)void *mymalloc(u8 memx,u32 size); //内存分配(外部调用)void *myrealloc(u8 memx,void *ptr,u32 size);//重新分配内存(外部调用)#endif 二、Malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include "malloc.h" ////////////////////////////////////////////////////////////////////////////////// //本程序只供学习使用，未经作者许可，不得用于其它任何用途//ALIENTEK战舰STM32开发板V3//内存管理 驱动代码 //正点原子@ALIENTEK//技术论坛:www.openedv.com//修改日期:2015/1/20//版本：V1.0//版权所有，盗版必究。//Copyright(C) 广州市星翼电子科技有限公司 2009-2019//All rights reserved ////////////////////////////////////////////////////////////////////////////////////内存池(32字节对齐)__align(32) u8 mem1base[MEM1_MAX_SIZE]; //内部SRAM内存池__align(32) u8 mem2base[MEM2_MAX_SIZE] __attribute__((at(0X68000000))); //外部SRAM内存池//内存管理表u16 mem1mapbase[MEM1_ALLOC_TABLE_SIZE]; //内部SRAM内存池MAPu16 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0X68000000+MEM2_MAX_SIZE))); //外部SRAM内存池MAP//内存管理参数 const u32 memtblsize[SRAMBANK]=&#123;MEM1_ALLOC_TABLE_SIZE,MEM2_ALLOC_TABLE_SIZE&#125;; //内存表大小const u32 memblksize[SRAMBANK]=&#123;MEM1_BLOCK_SIZE,MEM2_BLOCK_SIZE&#125;; //内存分块大小const u32 memsize[SRAMBANK]=&#123;MEM1_MAX_SIZE,MEM2_MAX_SIZE&#125;; //内存总大小//内存管理控制器struct _m_mallco_dev mallco_dev=&#123; my_mem_init, //内存初始化 my_mem_perused, //内存使用率 mem1base,mem2base, //内存池 mem1mapbase,mem2mapbase, //内存管理状态表 0,0, //内存管理未就绪&#125;;//复制内存//*des:目的地址//*src:源地址//n:需要复制的内存长度(字节为单位)void mymemcpy(void *des,void *src,u32 n) &#123; u8 *xdes=des; u8 *xsrc=src; while(n--)*xdes++=*xsrc++; &#125; //设置内存//*s:内存首地址//c :要设置的值//count:需要设置的内存大小(字节为单位)void mymemset(void *s,u8 c,u32 count) &#123; u8 *xs = s; while(count--)*xs++=c; &#125; //内存管理初始化 //memx:所属内存块void my_mem_init(u8 memx) &#123; mymemset(mallco_dev.memmap[memx], 0,memtblsize[memx]*2);//内存状态表数据清零 mymemset(mallco_dev.membase[memx], 0,memsize[memx]); //内存池所有数据清零 mallco_dev.memrdy[memx]=1; //内存管理初始化OK &#125; //获取内存使用率//memx:所属内存块//返回值:使用率(0~100)u8 my_mem_perused(u8 memx) &#123; u32 used=0; u32 i; for(i=0;i&lt;memtblsize[memx];i++) &#123; if(mallco_dev.memmap[memx][i])used++; &#125; return (used*100)/(memtblsize[memx]); &#125; //内存分配(内部调用)//memx:所属内存块//size:要分配的内存大小(字节)//返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 u32 my_mem_malloc(u8 memx,u32 size) &#123; signed long offset=0; u32 nmemb; //需要的内存块数 u32 cmemb=0;//连续空内存块数 u32 i; if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 if(size==0)return 0XFFFFFFFF;//不需要分配 nmemb=size/memblksize[memx]; //获取需要分配的连续内存块数 if(size%memblksize[memx])nmemb++; for(offset=memtblsize[memx]-1;offset&gt;=0;offset--)//搜索整个内存控制区 &#123; if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加 else cmemb=0; //连续内存块清零 if(cmemb==nmemb) //找到了连续nmemb个空内存块 &#123; for(i=0;i&lt;nmemb;i++) //标注内存块非空 &#123; mallco_dev.memmap[memx][offset+i]=nmemb; &#125; return (offset*memblksize[memx]);//返回偏移地址 &#125; &#125; return 0XFFFFFFFF;//未找到符合分配条件的内存块 &#125; //释放内存(内部调用) //memx:所属内存块//offset:内存地址偏移//返回值:0,释放成功;1,释放失败; u8 my_mem_free(u8 memx,u32 offset) &#123; int i; if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化 &#123; mallco_dev.init(memx); return 1;//未初始化 &#125; if(offset&lt;memsize[memx])//偏移在内存池内. &#123; int index=offset/memblksize[memx]; //偏移所在内存块号码 int nmemb=mallco_dev.memmap[memx][index]; //内存块数量 for(i=0;i&lt;nmemb;i++) //内存块清零 &#123; mallco_dev.memmap[memx][index+i]=0; &#125; return 0; &#125;else return 2;//偏移超区了. &#125; //释放内存(外部调用) //memx:所属内存块//ptr:内存首地址 void myfree(u8 memx,void *ptr) &#123; u32 offset; if(ptr==NULL)return;//地址为0. offset=(u32)ptr-(u32)mallco_dev.membase[memx]; my_mem_free(memx,offset); //释放内存 &#125; //分配内存(外部调用)//memx:所属内存块//size:内存大小(字节)//返回值:分配到的内存首地址.void *mymalloc(u8 memx,u32 size) &#123; u32 offset; offset=my_mem_malloc(memx,size); if(offset==0XFFFFFFFF)return NULL; else return (void*)((u32)mallco_dev.membase[memx]+offset); &#125; //重新分配内存(外部调用)//memx:所属内存块//*ptr:旧内存首地址//size:要分配的内存大小(字节)//返回值:新分配到的内存首地址.void *myrealloc(u8 memx,void *ptr,u32 size) &#123; u32 offset; offset=my_mem_malloc(memx,size); if(offset==0XFFFFFFFF)return NULL; else &#123; mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size); //拷贝旧内存内容到新内存 myfree(memx,ptr); //释放旧内存 return (void*)((u32)mallco_dev.membase[memx]+offset); //返回新内存首地址 &#125; &#125; 三、源码、思想讲解 1. 思想：将内存池分为块，首先定义每个块的字节数，和内存池的总字节数，用总字节数除以每个块的字节数得到块数 2. 内存池，实际上就是一个数组 3. 内存管理块，实际也是一个数组，总元素个数为内存块数，每个元素对应一个内存块，该元素非零时表示该内存块没有被占用 4. 将第一步中的信息用数组保存起来，方便后面的函数调用 5. 将内存抽象为一个结构体，传入的参数分别是，初始化函数，占用率函数，两个内存池（数组）的基地址，两个内存管理状态表（两个u16数组），两个内存池的就绪布尔值 6. 初始化函数，实际上就是将指定内存池（数组）内面的内容全部用0填充，将内存状态表（u16数组）全部用0填充，然后将该内存池的就绪布尔变量置1 7. 计算内存使用率(注意：得到的是块使用的比率，而不是字节使用的比率) 8. 复制，就是按字节依次赋值内容 9. 从起始位置将连续count个字节的区域用c填充 10. 分配内存（内部调用），成功：返回相对于数组首地址的偏移地址。-&gt; 判断指定的内存池是否已经初始化-&gt; 若传入参数为0，表示不需要分配，直接返回-&gt; 通过所需字节数对每个块的字节数分别取整，取余得到所需的连续块数-&gt; 从最后一个块往前面寻找所需的连续块，例如所需的块为3，当找到连续2块而，下一块已经被使用时，则将已经找的的连续块数清零，再在前面找连续的3块-&gt; 返回的偏移地址为所需连续块的起始块相对于内存池的偏移地址-&gt; 将即将用到的内存块对应的内存管理表中的元素置为所需的连续块数 11. 分配内存，首先判断偏移地址是否正确，然后返回连续块的首地址 12. 扩大分配内存，首先分配一个指定的内存，再将旧内存里面的内容拷贝到新内存（这里感觉战舰的源码有问题，旧的内存里面原来没有size个元素，却拷贝size个元素到新的空间），最后释放旧的内存空间，返回新的内存（块）首地址 13. 清除连续的内存块，成功：返回0-&gt; 首先通过偏移地址除以每个块的字节数，得到起始块的序号-&gt; 读取起始块对应的内存控制表元素，得到从起始块开始共要清除多少个连续的块-&gt; 所谓的清除，实际上只是将对应的内存控制表的元素清零，内存中的值未清零。-&gt; 为某个对象分配元素时，是分配的连续块，清除时，也是清除这几个连续块，不同对象占用不同的连续块，清除时，不会影响其他对象。 14. 内存释放函数，首先得出偏移地址，然后，调用上一步的函数释放内存]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Stm32</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux思维导图_微观]]></title>
    <url>%2F2020%2F09%2F06%2FLinux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%E5%BE%AE%E8%A7%82%2F</url>
    <content type="text"><![CDATA[这篇内容也是转载网上的，但是被人转载(抄)太多次，不太清楚来源；然后采摘总结下来。 一、命令细致讲解1.1 帮助命令 1.2 关机重启 1.3 权限管理 1.4 用户管理 1.5 文件管理 1.6 网络配置 1.7 文件搜索 1.8 压缩解压 二、思维导图2下面这张导图从以下四个方面讲解linux： Linux介绍 Linux目录结构 Linux常用命令 vim详解 三、思维导图3]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>计算机概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux思维导图_宏观]]></title>
    <url>%2F2020%2F09%2F06%2FLinux%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%E5%AE%8F%E8%A7%82%2F</url>
    <content type="text"><![CDATA[这篇内容是转载网上的，但是被人转载(抄)太多次，不太清楚来源了= =。 一、Linux学习路径 二、Linux桌面介绍 三、FHS(文件系统目录标准)3.1 详细版 3.2 简易版 四、Linux内核学习路线 五、Linux Security Coaching 六、Linux命令参考6.1 Linux命令速查表1 6.2 Linux命令速查表2]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>计算机概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础力扣学习]]></title>
    <url>%2F2020%2F09%2F06%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%9B%E6%89%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇内容基本来源于力扣官方在知乎给萌新学习力扣的建议。&emsp;&emsp;在开始刷题前，只需要你至少掌握一门编程语言，即使你从未刷过算法题，从现在开始好好利用这两个月的时间制定合适的学习计划，也可以给自己的算法水平带来质的提升。 首先，为什么搞嵌入式底层开发还是要学算法和数据结构？ &emsp;&emsp;虽然在搞嵌入式底层开发大多数数据结构用到的不多，学点常用的基本都能解决问题。例如，递归往往可以用于求解，其本质是从结果倒回输入的求解，常用于算法题，数据检索等；但不常见于嵌入式开发流程的场景应用，因为嵌入式往往是要从输入得到结果。但是我觉得还是有必要深入学习一下，这个不仅仅能够提升你代码的技术水平，还能提高你码代码的视界。 一、算法和数据结构的知识考点 算法和数据结构的关系 &emsp;&emsp;如果把算法比作建筑工程的图纸，数据结构就像是建造大楼的工具。数据结构设计的初衷就是方便程序员使用，虽然看似种类较多，但实际上每一种都不难，可以结合算法一起学习。 二、探索卡片&emsp;&emsp;对于零基础的同学来说，不建议一开始就从题库页开始按顺序刷题。在力扣的探索页面有十分丰富的算法和数据结构主题卡片，从探索卡片开始学习能帮助你快速入门。每个卡片都覆盖了详细的知识点介绍，概念讲解，结构特点，代码实现，例题及答题套路。 &emsp;&emsp;按照正确的顺序来刷探索卡片，由浅入深，逐层打好算法根基。 ! 三、进阶&emsp;&emsp;按着上面的探索卡片学习；有了一定的算法和数据结构基础以后，这时你就可以选择刷面试题、或者题库了。 &emsp;&emsp;要准备面试的话，多写写面试题；面试题可以选最近时期的「名企高频面试题」、「剑指 Offer」等。如果已经在准备面试冲刺的阶段，这时候不妨多刷两遍「剑指 Offer」题库。 &emsp;&emsp;当然也可以养生刷刷题库；根据题库页的标签分类进行专项刷题也是一个非常不错的选择。 四、刷题技巧&emsp;&emsp;当我们开始刷一类算法题前，如果对此算法的概念还不太熟悉，花费 5 分钟左右的时间了解其概念是很有必要的。在力扣题库页的 标签分类 中，点击对应的标签即可查看算法概念。 &emsp;&emsp;在足够多的准备工作后，我们就可以开始找一道简单～中等的题目小试牛刀了。有的同学会想：直接从困难题目开始练习，练会了困难题目，再去看简单题和中等题岂不是轻而易举？事实上我们不建议初学者直接练习困难题目。因为困难题目往往不够典型，困难题总是糅合了多种算法，难点在于对多种算法的综合应用，不适合在学习阶段用来专攻某一类算法。 &emsp;&emsp;下面举一个具体的例子，比如我们计划本周刷深度优先搜索的题目。先点击题库页「深度优先搜索」标签，查看其概念： &emsp;&emsp;从概念中我们知道，深度优先搜索，简称 DFS，主要用于遍历或搜索树或图。核心是沿着树的深度遍历树的节点，以深度优先的方式来遍历一棵树，直到找到需要搜索的节点或是遍历结束。 这不难理解，了解完概念，我们的脑中就对此算法有了一个粗略地认识： 想象我们正站在一棵大树前，我们想要浏览这棵树的整个结构。 于是我们选择从大树的根出发，往树枝处浏览； 遇到树木分叉的地方，就随机选择一个树枝开始浏览； 浏览完后，回到上一个分叉的地方，选择另一个树枝继续浏览，直到所有的树枝都浏览完成。 &emsp;&emsp;事实上，深度优先搜索和树形结构经常成双成对出现，二者总是密不可分。有了一个粗略的认识后，我们应该立即选择一道简单的题目开始练习： 看到题目，我们的第一想法可能是以根节点为中心，左边的最长路径加上右边的最长路径应该就是答案。如题目示例中的树： 根节点左边的最长路径为 2，右边的最长路径为 1，所以和为 3。 看起来没有错，我们再考虑一些特殊情况，有没有可能最长路径不经过根节点呢？不妨画个草图看一下： 对于这样一棵树，根节点没有右子树，所以根节点右边的最长路径为 0，而左边的最长路径是 3，所以这样算起来直径为 3。但我们发现以2做为根节点的子树直径为 4，大于我们当前算法算出的直径！显然我们之前的思路是错误的，根节点其实不一定经过根节点，子节点可能存在更长的直径。我们不得不选择另一种思路。 如果此时冥思苦想，仍然没有思路的话，我们可以点开题解区抄一下别人的解题思路。先依着葫芦画瓢，等学会了再自己创造。 我们看到本题题解区有力扣官方发布的题解： &emsp;&emsp;看完题解我们已经有了具体的解题思路。此时切记不要眼高手低，不要觉得看懂了就是会了，一定要亲自将代码敲一遍，有过刷题经验的人都知道，看别人解题和自己亲自上手是完全不一样的感觉。经常是脑子和眼睛在说：我会了。而手在说：不，你不会！ 仿照着官方题解，我们写出本题的 kotlin 解法： 12345678910111213141516class Solution &#123;var ans = 0fun diameterOfBinaryTree(root: TreeNode?): Int &#123; ans = 1 depth(root)return ans - 1 &#125;fun depth(node: TreeNode?): Int &#123;if (node == null) return 0 // 访问到空节点了，返回0val L = depth(node.left) // 左儿子为根的子树的深度val R = depth(node.right) // 右儿子为根的子树的深度 ans = Math.max(ans, L + R + 1) // 计算d_node即L+R+1 并更新ansreturn Math.max(L, R) + 1 // 返回该节点为根的子树的深度 &#125;&#125; &emsp;&emsp;这是一道非常典型的 DFS 算法题，刷完之后我们应该反复思索，做出总结：DFS 的核心是依次尝试，运用的主要手段是递归函数。 然后我们马上再找一道近似的题，继续练习本类算法，比如： &emsp;&emsp;这道题与上道题非常类似，它也是非常典型的 DFS 题，因为它没有掺杂多类算法，实际难度算不上困难。这一次我们争取不查看题解，先将上题的模板拷贝过来，加以修改写出解法： 12345678910111213141516class Solution &#123;var max = Int.MIN_VALUEfun maxPathSum(root: TreeNode?): Int &#123; maxDeep(root)return max &#125;fun maxDeep(node: TreeNode?): Int &#123;if (node == null) return 0val L = Math.max(maxDeep(node.left), 0)val R = Math.max(maxDeep(node.right), 0) max = Math.max(max, node.`val` + L + R)return node.`val` + Math.max(L, R) &#125;&#125; 如果此时仍然不能手打出一道完整的典型 DFS 题目，就继续反复练习，坚持这个过程，直至自己完全掌握此类题目。 总而言之，算法学习技巧可总结为四个步骤：一看二抄三改四写。 一看：先查看基本概念，知道这类算法是什么。 二抄：照着别人的解题思路，将代码完整敲一遍，理解其思路。学习算法切忌自己造轮子，绝大多数问题都早已经有了完善的解决方案。 三改：拷贝自己以前敲的模板代码，加以修改，反复巩固。 四写：看答案与改答案 AC 的题不能算是真的会了，必须自己能手打出完整的代码才是真正会了。 五、时间规划&emsp;&emsp;梳理完算法学习的先后顺序和刷题技巧，一份可执行的时间计划是非常重要的，大家可以根据自己的学习进度安排，下面列出一些计划的要点。 5.1 确定学习方式&emsp;&emsp;有的同学基础还比较薄弱，就需要花一定的时间梳理知识点，可以通过探索卡片或者看书学习，在刷题前至少保证一周左右的时间充分梳理知识点，而基础比较扎实的同学可以适当缩短梳理知识点的时间，或者直接从题目开始刷。 5.2 计划刷题总数量&emsp;&emsp;一般来说，刷 150 - 200 题就能比较充分地应对技术面试了。同学们可以根据时间按照实际情况调整。在这个基础上可以预估每天要花多少时间刷题，刷多少题。 5.3 预留面试前复习时间&emsp;&emsp;复习是刷题过程中非常重要的一个环节，刷了一定数量的题目后，可以准备一周的时间系统回顾错题和难题，避免出现面试时遇到做过的题仍然回答不上来的情况。 5.4 安排实战演练和冲刺时间&emsp;&emsp;在正式开始面试前的一到两周，你就需要进行大量实战演练和冲刺刷题了，在这个阶段反复练习 70+ 道2020 年互联网名企高频面试题探索卡片，保持刷题的手感。]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>计算机概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小二乘法]]></title>
    <url>%2F2020%2F09%2F05%2F%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇介绍 平常写嵌入式程序时常见的一种算法：最小二乘法。 一、最小二乘法求回归直线方程的推导过程&emsp;&emsp;第一章节内容主要来自这位博主：Neo_T。 &emsp;&emsp;实际上我们希望这n个离差构成的总离差越小越好，只有如此才能使直线最贴近已知点。换句话说，我们求回归直线方程的过程其实就是求离差最小值的过程。 &emsp;&emsp;一个很自然的想法是把各个离差加起来作为总离差。可是，由于离差有正有负，直接相加会互相抵消，如此就无法反映这些数据的贴近程度，即这个总离差不能用n个离差之和来表示，见下图： 一般做法是我们用离差的平方和，即： &emsp;&emsp;作为总离差，并使之达到最小。这样回归直线就是所有直线中Q取最小值的那一条。由于平方又叫二乘方，所以这种使“离差平方和为最小”的方法，叫做最小二乘法。用最小二乘法求回归直线方程中的a、b的公式如下： &emsp;&emsp;当然，我们肯定不能满足于直接得到公式，我们只有理解这个公式怎么来的才能记住它，用好它，因此给出上面两个公式的推导过程更加重要。在给出上述公式的推导过程之前，我们先给出推导过程中用到的两个关键变形公式的推导过程。首先是第一个公式： 接着是第二个公式： &emsp;&emsp;基本变形公式准备完毕，我们可以开始最小二乘法求回归直线方程公式的推导了： 至此，公式变形部分结束，从最终式子我们可以看到后两项 与a、b无关，属于常数项，我们只需 即可得到最小的Q值，因此： &emsp;&emsp;至此，公式推导完毕。 二、最小二乘法——C实现 2.1 算法代码123456789101112131415161718192021222324252627//-------------------------------------------------------------//功能 : 最小二乘法直线拟合 y = a + b*x， 计算系数a 和 b//参数 : x -- 辐照度的数组// y -- 功率的数组// num 是数组包含的元素个数，x[]和y[]的元素个数必须相等// a,b 都是返回值//返回 : 拟合计算成功返回true, 拟合计算失败返回false//-------------------------------------------------------------voud LeastSquareLinearFit(float x[], float y[], const int num, double &amp;a, double &amp;b)&#123; uint64_t sum_x2 = 0; uint64_t sum_y = 0; uint64_t sum_x = 0; uint64_t sum_xy = 0; for(uint32_t i = 0; i &lt; num; i++) &#123; sum_x2 += x[i]*x[i]; sum_y += y[i]; sum_x += x[i]; sum_xy += x[i]*y[i]; &#125; a = (double)(sum_x2*sum_y - sum_x*sum_xy)/(double)(num*sum_x2-sum_x*sum_x); b = (double)(num*sum_xy - sum_x*sum_y)/(double)(num*sum_x2 - sum_x*sum_x);&#125; 2.2 常见用法&emsp;&emsp;最小二乘法的常见用法，就有 直线拟合 &amp; 曲线拟合。由于这里是讲解 直线拟合，因此只讲 直线拟合 的应用场合。 &emsp;&emsp;直线拟合 最常见、最基础的用法，实际就是求 K ，在实际的应用场合就是对应的变化率，利用 K 值大小来进行一些状态判断。例如重量的斜率K，就是重量的变化量，实际上就是流量。]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>计算机概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式(Stm32)程序跑飞]]></title>
    <url>%2F2020%2F08%2F22%2F%E5%B5%8C%E5%85%A5%E5%BC%8F-Stm32-%E7%A8%8B%E5%BA%8F%E8%B7%91%E9%A3%9E%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;搞嵌入式开发，有时候总会因为自己的粗心，或者是硬件本身的缺陷导致的程序跑飞；要找到程序跑飞的原因，排查方法尤为重要，这里介绍一些经验。 一、常见的 程序跑飞&emsp;&emsp;分享常见的三种死机情况： 无操作系统程序死机 常见的就是内存溢出(数组下标、申请内存的长度) 语法问题，导致死循环、或者条件异常直接跳转出去(常见低级错误) 带操作系统程序死机 临界区代码没有进行保护，导致堆栈溢出；常见于底层驱动中断 任务的堆栈(内存)设置太小；出现程序死机时，可以尝试扩大任务的堆栈大小，若无死机情况了再从大往小了减。 emwin的不当操作导致死机 emwin由于是不开源的，所以有时候不当的操作，比如没有创建窗口时就删除该窗口，就会导致死机。 所以在运用emwin的时候一定要严格遵循他要求的顺序，如果可以的话多加一下判断再删除界面。 二、进入HardFault_Handler&emsp;&emsp;STM32出现HardFault_Handler故障的根本原因有两个方面： 内存溢出或者访问越界。 堆栈溢出。(增加堆栈的大小，大多数是因为中断嵌套) &emsp;&emsp;但是能造成故障的方法有很多种：例如，数组越界操作、中断处理错误、中断嵌套过多等等。 这里只介绍两种简单排查的方法。 2.1 方法1&emsp;&emsp;默认的HardFault_Handler处理方法不是 B .(汇编) or while(1)(C语言) 这样的死循环么？楼主将它改成 BX LR直接返回的形式。 &emsp;&emsp;然后在这条语句打个断点，一旦在断点中停下来，说明出错了，然后再Step两下，就可以返回到出错的位置的下一条语句那儿。 123456789__asm void wait()&#123; BX lr&#125;void HardFault_Handler(void)&#123; /* Go to infinite loop when Hard Fault exception occurs */ wait();&#125; 2.2 方法2&emsp;&emsp;在硬件中断函数HardFault_Handler里的while(1)处打调试断点，程序执行到断点处时点击“STOP”停止仿真。 &emsp;&emsp;在Keil菜单栏点击“View”——“Call Stack Window”弹出“Call Stack + Locals”对话框。然后在对话框中右键选择“Show Caller Code”，就会跳转到出错之前的函数处；仔细查看这部分函数被调用或者数组内存使用情况。 三、上操作系统(ucOS)程序跑飞&emsp;&emsp;频繁操作文件，容易出现死机，操作文件时，最好关闭任务；操作完成后，再打开任务； uC/OS-II的OSSchedLock()和OSSchedUnlock()函数应成对出现，允许应用程序锁定当前任务不被其它任务抢占。使用时应当注意的是：当你调用了OSSchedLock()之后，而在调用OSSchedUnlock()之前，千万不要再调用诸如OSFlagPend()、OSMboxPend()、OSMutexPend()、OSQPend()、OSSemPend()之类的事件等待函数！而且应当确保OSSchedLock()和OSSchedUnlock()函数成对出现，特别是在有些分支条件语句中，要考虑各种分支情况，不要有遗漏！ &emsp;&emsp;任务优先级。每个任务都必须符合事件驱动的编程模型，即uC/OS-II的应用程序都必须是“事件驱动的编程模型”。一个任务首先等待一个事件的发生，事件可以是系统中断发出的，也可以是其它任务发出的，又可以是任务自身等待的时间片。当一个事件发生了，任务再作相应处理，处理结束后又开始等待下一个事件的发生。如此周而复始的任务处理模型就是“事件驱动的编程模型”。事件驱动模型也涵盖了中断驱动模型，uC/OS-II事件归根结底来自三个方面： 中断服务函数发送的事件 系统延时时间到所引起的 其它任务发送的事件。 其中“中断服务函数发送的事件”就是指每当有硬件中断发生，那么中断服务程序就会以事件的形式告诉任务，而等待该事件的最高优先级任务就会马上得以运行；“系统延时时间到所引起的”事件其实也是硬件中断导致的，那就是系统定时器中断。而“其它任务发送的事件”则是由任务代码自身决定的，这是完全的“软事件”。不管“软事件”还是“硬事件”，反正引起uC/OS-II任务切换的原因就是“事件”，所以用户编写应用代码的时候一定要体现出“事件驱动的编程模型”。任务的优先级也一定要分配得当； 查看堆栈是否满； &emsp;&emsp;不可重入函数。一些C语言函数，用到uCOS-II操作系统中，有时也可能出现问题，例如：gotoxy（）；printf（）。 &emsp;&emsp;OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()也可以用来保护应用程序中的临界代码；然而要特别小心，如果再调用一些如 OSTimeDel() 之类的功能函数之前关中断，应用程序将会死机；原因是任务被挂起一段时间，直到挂起时间到，但由于中断关掉了，时钟节拍中断一直得不到服务，显然所有的挂起类调用都有这样的问题，所以要特别小心。 &emsp;&emsp;需要一并提醒的是：当调用开关中断函数 OS_ENTER_CRITICAL() 和 OS_EXIT_CRITICAL() 时也要确保成对出现，否则系统将可能崩溃！不过，在 OS_ENTER_CRITICAL() 和 OS_EXIT_CRITICAL() 函数之间调用 OSFlagPend()、 OSMboxPend()、 OSMutexPend()、 OSQPend()、 OSSemPend()之类的事件等待函数是允许的。 &emsp;&emsp;官方ucOS-III 不支持stm32f4x系列的FPU功能(ucOS-III代码没考虑到该功能)；一旦使能FPU，程序会进入到HardFault_Handler，或者出现打印浮点数异常(打印就死机)的现象。修改进行对源码的一些修改才能使用！]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Stm32</tag>
        <tag>程序跑飞</tag>
        <tag>内存溢出</tag>
        <tag>HardFault</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stm32的内存管理(Code,RO-data,RW-data,ZI-data)]]></title>
    <url>%2F2020%2F08%2F22%2FStm32%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Code-RO-data-RW-data-ZI-data%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;单纯从C语言角度来讲内存管理，有点宏观；这里介绍具体嵌入式的内存分配管理。 一、内存分配&emsp;&emsp;对于一个C语言程序而言，内存空间主要由五个部分组成：代码段(.text)、数据段(.data)、静态区(.BSS)、堆和栈组成。 BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量和静态变量（这里注意一个问题：一般的书上都会说全局变量和静态变量是会自动初始化的，那么哪来的未初始化的变量呢？变量的初始化可以分为显示初始化和隐式初始化，全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化，那就是不管什么类型都初始化为0，这种没有显示初始化的就是我们这里所说的未初始化。既然都是0那么就没必要把每个0都存储起来，从而节省磁盘空间，这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据，只是简单的维护开始和结束的地址，即总大小，以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在，即不占用磁盘空间而只在运行的时候占用内存空间，所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。 数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配，可以分为只读数据段和读写数据段。字符串常量等，但一般都是放在只读数据段中。 代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等，但一般都是放在只读数据段中。 栈区：由系统自动分配，栈区的分配运算内置于处理器的指令集，当函数执行结束时由系统自动释放。存放局部变量。栈的缺点是：容量有限，当相应的区间被释放时，局部变量不可再使用。查询栈容量的命令：ulimits -s。栈是一块连续的区域，向高地址扩展，栈顶和容量是事先约定好的。 堆区：在程序的执行过程中才能分配，由程序员决定，编译器在编译时无法为他们分配空间，只有在程序运行时分配，所以被称为动态分配。堆是不连续的区域，向高地址扩展。由于系统用链表来描述空闲的地址空间，链表的遍历是由地地址向高地址的，故堆区是不连续的动态的存储空间。 &emsp;&emsp;更多具体的C语言基础内存分配知识，可以看这篇博文：内存分配方式 。 二、Stm32的内存管理编写一个空工程，BUILD后， 1Program Size: Code=340 RO-data=252 RW-data=0 ZI-data=1632 &emsp;&emsp;程序已用了1600多的RAM，要是在51单片机上，会心疼死了，这1600多的RAM跑哪儿去了？？？ 分析完map，你会发现是堆和栈占用的。在startup_stm32f10x_md.s文件中，它的前面几行就有以下定义，这下该明白了吧。 12Stack_Size EQU 0x00000400Heap_Size EQU 0x00000200 &emsp;&emsp;一般 MCU 包含的存储空间有：片内 Flash 与片内 RAM，RAM 相当于内存，Flash 相当于硬盘。 编译器会将一个程序分为好几个部分，分别存储在 MCU 不同的存储区。Keil 工程在编译完之后，会有相应的程序所占用的空间提示信息，如下所示： 1Program Size: Code=12266 RO-data=790 RW-data=232 ZI-data=8096 上面提到的 Program Size 包含以下几个部分： Code：代码段，存放程序的代码部分； RO-data：只读数据段，存放程序中定义的常量； RW-data：读写数据段，存放初始化为非 0 值的全局变量； ZI-data：0 数据段，存放未初始化的全局变量及初始化为 0 的全局变量； 编译完工程会生成一个. map 的文件，该文件说明了各个函数占用的尺寸和地址，在文件的最后几行也说明了上面几个字段的关系： 123Total RO Size (Code + RO Data) 13056 ( 12.75kB)Total RW Size (RW Data + ZI Data) 8328 ( 8.13kB)Total ROM Size (Code + RO Data + RW Data) 13288 ( 12.98kB) RO Size = (Code + RO-data)：表示程序占用 Flash 空间的大小； RW Size = (RW-data + ZI-data)：表示运行时占用的 RAM 的大小； ROM Size = (Code + RO Data + RW Data)：表示烧写程序所占用的 Flash 空间的大小。 &emsp;&emsp;这个是MDK编译之后能够得到的每个段的大小，也就能得到占用相应的FLASH和RAM的大小。 Flash = Code + RO Data + RW Data; RAM = RW-data+ZI-data; Ps：堆和栈都存在RAM里，他两各分多少看函数需求，但是他两的总值不能超过单片机硬件的实际RAM尺寸！(可以外扩RAM) 三、分散文件加载&emsp;&emsp;内存分配在嵌入式开发，有另外一个名字：分散文件加载。 该章节内容主要来自这位博主：Solaris_超，想更了解分散文件加载的可以看这位博主链接文章。 3.1 什么是分散加载&emsp;&emsp;简单来说就是让编译器高速MCU内核哪里存的是代码、哪里存的是数据，去哪个特定的地址找到下一步需要运行的函数，就是高速编译器把每一个编译好的函数、数据放到具体的哪一个物理地址。 3.2 分散加载常见应用场景 Bootloader &amp; 程序升级 Bootloader的原理就简单来说在MCU的Flash里面同时摆放2个（或多个）不同工程的程序，一个Bootloader程序和一个用户程序，那么这就需要调整分散加载文件，以达成在一个Flash里面同时摆放两个不同程序的目的。 程序升级都是为了增加一个小功能或修复一个小BUG，不需要全部升级而是只升级一点点。当然要实现这个功能同样需要分散加载的配合，把可能会后续升级的部分函数或数据事先分配好空间，留好空间上的余量，这些都需要分散加载来完成。 加速程序运行速度（如：对速度有较高要求的算法等、RTOS kernel） 在SRAM中运行的程序要比在XIP Flash中执行要快，性能提升明显。 访问扩展存储&amp;对存储区的划分 如果要把外扩的存储用于运行代码/扩展RW数据段等用途，简单来说就是把片内地址映射到片外，需要按照寻址空间的方式来访问扩展存储的话，比如扩展Nor-Flash、扩展SDRAM、扩展SRAM等，那就需要分散加载配合。（只作存储数据的话，分散加载不是必要的！！！） 3.3 分散加载的基本结构定义以及分散加载的目的 Code段：表示程序代码部分 RO-data段：程序定义的所有常量以及const类型数据 RW-data段：已经初始化的所有静态变量 ZI-data段：未初始化的静态变量 所以分散加载的根本目的就是： 指引把RO-data数据段、RW数据段从片内程序存储区里面（一般是片内Flash），搬到片内程序运行区（一般是片内SRAM）; 在片内程序运行区（一般是片内SRAM）内分配ZI数据段运行需要的空间并把这段数据初始化为0； 初始化堆栈； 对于有些指定加载到程序运行区（一般是片内SRAM）的RO数据段，把他们加载到程序运行区（一般是片内SRAM）里面。 Ps： 这个和使用的电脑运行操作系统或者软件原理类似，电脑就是把硬盘里面的操作系统加载到内存里面，然后CPU从内存里面取数据以及程序指令来运行的。 Ps： RW以及ZI数据段的初始化是在分散加载过程中完成的，也就是在__main中完成的，比如你定义一个全局变量，并给它赋值，只有在__main结束后你才能看到这个全局变量被赋值成功的，也就是说在__main之前，使用全局变量是行不通的。 &emsp;&emsp;我们可以在编译链接完层的代码后，链接器的输出打印上看到这部分信息，如下图，就是一个Hello World工程的输出打印，其中链接器打印出了这几个段的大小（蓝色底纹部分）： 如果大家想看更详细编译结果，可以双击工程名查看.map文件 &emsp;&emsp;.map文件最后有关于编译结果的详细介绍，我是用的这个hello world工程中的所有被编译&amp;链接的文件都会在.map（链接器的工作报表）文件里面详细记述，每一个文件编译后产生的Code、RO-Data、RW、ZI的大小，以及加在一起的总大小，如下图： Ps： 我们可以通过查看 .map 文件来规划Bootloader程序的存储空间的大小。 四、嵌入式的内存分配 内存管理：是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。内存管理的实现方法有很多种，他们其实最终都是要实现 2 个函数： malloc 和 free（不可重入函数，上操作系统注意调用，很危险）； malloc 函数用于内存申请， free 函数用于内存释放。 内存碎片：通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。 &emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用。 &emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做！一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的malloc 与free的使用容易造成内存碎片。没有MMU的管理，当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。 嵌入式内存的分配方式，常见如STM32可以先在启动文件中设置heap的大小，再使用动态内存分配： 1Heap_Size EQU 0x00000200 //也就是 512字节 &emsp;&emsp;嵌入式系统的堆栈，不管是用什么方法来得到内存，感觉他的方式都和编程中的堆差不多。目前我知道两种获得内存情况： 用庞大的全局变量数组来圈住一块内存，然后将这个内存拿来进行内存管理和分配。这种情况下，堆栈占用的内存就是上面说的：如果没有初始化数组，或者数组的初始化值为0，堆栈就是占用的RAM的ZI-data部分；如果数组初始化值不为0，堆栈就占用的RAM的RW-data部分。这种方式的好处是容易从逻辑上知道数据的来由和去向。 就是把编译器没有用掉的RAM部分拿来做内存分配，也就是除掉RW-data+ZI-data+编译器堆+编译器栈后剩下的RAM内存中的一部分或者全部进行内存管理和分配。这样的情况下就只需要知道内存剩下部分的首地址和内存的尾地址，然后要用多少内存，就用首地址开始挖，做一个链表，把内存获取和释放相关信息链接起来，就能及时的对内存进行管理了。 正点原子的方法即是上面的方法一，详情介绍可以看这篇文章：正点原子例程_内存管理 五、内存管理的好处&emsp;&emsp;内存管理，即进行内存分配、释放操作。 &emsp;&emsp;内存管理的核心好处，就是释放内存；开辟内存并不难，问题是及时把不用到的内存释放出来。当嵌入式项目用到文件系统、操作系统时，就需要内存管理了。一般如果做的嵌入式项目不涉及文件系统、操作系统，是不需要进行内存管理的。&emsp;&emsp;因为不涉及文件系统、操作系统的话，嵌入式项目内部采用所需的变量内存大小都是大致可知的；声明定义采用 足够长的局部数组类型，既分配了临时内存。离开后又自动及时释放；就根本不需要内存管理。&emsp;&emsp;但当涉及到文件系统时，项目程序开始有了不确定的输入，例如插入的SD卡、U盘有多个文件。例如我想实现一个文件(名)浏览功能： 需要读取所有文件名到内存，然后显示到LCD。 用上述不用内存管理的方法，是定义一个数组来存储所有文件名。 需要知道其中最大文件名的长度。设为255字节。 需要知道文件个数。 100？1000？10000 ？ 如果没有内存管理： 则要定义一个：u8 filenametbl[10000][255];的数组！！ 要2550K字节内存!(MCU表示压力山大…)]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Stm32</tag>
        <tag>内存管理</tag>
        <tag>分散文件加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[M0的中断向量表重映射]]></title>
    <url>%2F2020%2F08%2F12%2FM0%E7%9A%84%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E9%87%8D%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Stm32F030的Bootloader制作与其他ST芯片一致；但是Stm32F030的APP程序就有特殊变动：因为M0是不能设置重量向量表偏移量；本篇就讲M0的APP程序的中断向量表重映射，和还有一些会用到的冷知识，如编译工具链等。 一、M0的中断向量表重映射&emsp;&emsp;在STM32F103等cortex-m3/m4内核的单片机上可以通过设置中断向量表的偏移量，完成重映射中断向量表。 1SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; &emsp;&emsp;Stm32f0系列MCU中断矢量表的定位跟STM32其它系列相比有点差异，即M0系列没有像其它M3/M4/M0+系列所具备的中断矢量表重定位寄存器，其中断矢量表不能借助矢量重定位寄存器简单修改实现。所以Stm32f0x IAP的过程会跟其它系列的STM32芯片的IAP动作有所不同。 M0的中断向量表如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950__Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD SVC_Handler ; SVCall Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD PendSV_Handler ; PendSV Handler DCD SysTick_Handler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD RTC_IRQHandler ; RTC through EXTI Line DCD FLASH_IRQHandler ; FLASH DCD RCC_IRQHandler ; RCC DCD EXTI0_1_IRQHandler ; EXTI Line 0 and 1 DCD EXTI2_3_IRQHandler ; EXTI Line 2 and 3 DCD EXTI4_15_IRQHandler ; EXTI Line 4 to 15 DCD TS_IRQHandler ; TS DCD DMA1_Channel1_IRQHandler ; DMA1 Channel 1 DCD DMA1_Channel2_3_IRQHandler ; DMA1 Channel 2 and Channel 3 DCD DMA1_Channel4_5_IRQHandler ; DMA1 Channel 4 and Channel 5 DCD ADC1_COMP_IRQHandler ; ADC1, COMP1 and COMP2 DCD TIM1_BRK_UP_TRG_COM_IRQHandler ; TIM1 Break, Update, Trigger and Commutation DCD TIM1_CC_IRQHandler ; TIM1 Capture Compare DCD TIM2_IRQHandler ; TIM2 DCD TIM3_IRQHandler ; TIM3 DCD TIM6_DAC_IRQHandler ; TIM6 and DAC DCD 0 ; Reserved DCD TIM14_IRQHandler ; TIM14 DCD TIM15_IRQHandler ; TIM15 DCD TIM16_IRQHandler ; TIM16 DCD TIM17_IRQHandler ; TIM17 DCD I2C1_IRQHandler ; I2C1 DCD I2C2_IRQHandler ; I2C2 DCD SPI1_IRQHandler ; SPI1 DCD SPI2_IRQHandler ; SPI2 DCD USART1_IRQHandler ; USART1 DCD USART2_IRQHandler ; USART2 DCD 0 ; Reserved DCD CEC_IRQHandler ; CEC DCD 0 ; Reserved M0的中断向量表重映射方法如下： 将APP的中断向量表拷贝到SRAM里面去。M0的中断向量表由48个有序字(32bit)组成，把它们从flash区0x08004000开始的中断向量表拷贝到0x2000 0000的SRAM区。 做存储地址的映射，即把SRAM映射到代码执行区的地址0X00处。 123456789101112131415161718192021222324252627282930313233343536373839#define FLASH_BOOTLOADER_SIZE (uint32_t)(0x4000) #define APPLICATION_ADDRESS (uint32_t)(0x08000000+FLASH_BOOTLOADER_SIZE) #if (defined ( __CC_ARM )) __IO uint32_t VectorTable[48] __attribute__((at(0x20000000)));#elif (defined (__ICCARM__))#pragma location = 0x20000000 __no_init __IO uint32_t VectorTable[48];#elif defined ( __GNUC__ ) __IO uint32_t VectorTable[48] __attribute__((section(".RAMVectorTable")));#elif defined ( __TASKING__ ) __IO uint32_t VectorTable[48] __at(0x20000000);#endif static void VectorRemap(void)&#123; uint8_t i = 0; //拷贝中断向量表 for(i = 0; i &lt; 48; i++) &#123; VectorTable[i] = *(__IO uint32_t*)(APPLICATION_ADDRESS + (i&lt;&lt;2)); &#125; /* Enable the SYSCFG peripheral clock*/ RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE); /* Remap SRAM at 0x00000000 */ SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SRAM);&#125;//主函数int main(void)&#123; VectorRemap(); //按照平常程序运行&#125; &emsp;&emsp;经过上述操作步骤后，当APP里发生中断时，内核就从地址0x00处的向量表取相应中断的入口地址，即相当于从0x2000 0000处的向量表取中断入口地址，当然也相当于从0x08003000处的向量表取中断入口地址，然后去执行相应中断程序。 二、编译工具链&emsp;&emsp;STM32中ARM系列编译工具链的编译宏选择（__CC_ARM、__ICCARM__、__GNUC__、__TASKING__）。这里简单介绍一下。 在 core_cm3.h 文件中，有如下代码： 1234567891011121314151617#if defined ( __CC_ARM ) #define __ASM __asm /*!&lt; asm keyword for ARM Compiler */ #define __INLINE __inline /*!&lt; inline keyword for ARM Compiler */#elif defined ( __ICCARM__ ) #define __ASM __asm /*!&lt; asm keyword for IAR Compiler */ #define __INLINE inline /*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */#elif defined ( __GNUC__ ) #define __ASM __asm /*!&lt; asm keyword for GNU Compiler */ #define __INLINE inline /*!&lt; inline keyword for GNU Compiler */#elif defined ( __TASKING__ ) #define __ASM __asm /*!&lt; asm keyword for TASKING Compiler */ #define __INLINE inline /*!&lt; inline keyword for TASKING Compiler */#endif 这几个宏都是什么含义呢？分别对应什么平台呢？ __CC_ARM对应的平台是：ARM RealView RealView，是一套包含编译、调试和模拟的开发工具，需结合开发环境如uvision、eclipse或者CodeWarrior，形成集成开发环境来使用。 __ICCARM__对应的平台是：IAR EWARM Embedded Workbench for ARM 是IARSystems 公司为ARM 微处理器开发的一个集成开发环境(下面简称IAR EWARM)。比较其他的ARM 开发环境，IAR EWARM 具有入门容易、使用方便和代码紧凑等特点 __GNUC__对应的平台是：GNU Compiler Collection GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。 __TASKING__对应的平台是：Altinum Designer Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。 三、__attribute__ ((at()) 绝对定位 __attribute__ ，这个是用来指定变量或结构位域的特殊属性,该关键字后的双括弧中的内容是属性说明。 at ，该关键字可以用来设置变量的绝对地址,也就是你可以通过这个关键字,指定某个变量处于内存里面的某个给定的地址. &emsp;&emsp;__attribute__( at(绝对地址) ) 的用法分两种，一个是绝对定位到Flash，另一种是绝对定位到RAM。 定位到flash中，一般用于固化的信息，如出厂设置的参数，上位机配置的参数，ID卡的ID号，flash标记等等。 12const u16 gFlashDefValue[512] __attribute__((at(0x0800F000))) = &#123;0x1111,0x1111,0x1111,0x0111,0x0111,0x0111&#125;;//定位在flash中,其他flash补充为00const u16 gflashdata__attribute__((at(0x0800F000))) = 0xFFFF; 定位到RAM中，一般用于数据量比较大的缓存，如串口的接收缓存，再就是某个位置的特定变量 1u8 USART2_RX_BUF[USART2_REC_LEN] __attribute__ ((at(0X20001000)));//接收缓冲,最大USART_REC_LEN个字节,起始地址为0X20001000. 绝对定位不能在函数中定义；局部变量是定义在栈区的，栈区由MDK自动分配、释放，不能定义为绝对地址，只能放在函数外定义。 定义的长度不能超过栈或Flash的大小，否则，造成栈、Flash溢出。 四、重映射 &amp; 系统启动4.1 重映射1SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SRAM); 例如F072的参考文档张SYSCFG寄存器的介绍，如下图： MEM_MODE的介绍如下： 从以上内容我们可以得到以下信息： MEM_MODE的值在上电后由BOOT0，BOOT1的状态值决定。 MEM_MODE的值决定了哪个内存映射到地址0x0000 0000 ，也就是说: 当MEM_MODE =00/10时， Main Flash映射到地址0x0000 0000，即地址0x0800 0000映射到0x0000 0000。 当MEM_MODE =01时， System Flash映射到地址0x0000 0000，也就是芯片自带的Bootloader代码部分会映射到地址0x0000 0000；例如，0x1FFF C800映射到地址0x0000 0000。 当MEM_MODE =11时， Embeded SRAM映射到地址0x0000 0000，也就是内存地址0x2000 0000映射到地址0x0000 0000。 经过映射后，系统访问地址0x0000 0000地址，就相当于直接访问映射的地址，如0x0800 0000。 由BOOT0，BOOT1的状态决定MEM_MODE的值，进而决定哪个地址映射到地址0x0000 0000，这一过程我们称之为映射。默认映射是系统自动完成的，并由BOOT0，BOOT1的状态决定。 MEM_MODE位是RW的，也就是说可以修改的，如果修改其中，也就会相应的修改映射到0x0000 0000的地址，这一修改的过程，我们就叫其为重映射。重映射是通过用户代码通过修改MEM_MODE的值来完成的。 4.2 系统启动从STM32F072的参考手册的2.5章，我们可以看到如下内容： 从以上内容我们可以得到以下有用信息: 在复位启动后，系统在系统时钟的第4个上升沿根据BOOT0,BOOT1的配置获取其值，也就是存储到寄存器SYSCFG_CFGR1的MEM_MODE位上，根据前面3.1的信息可知，这里进一步确定了0x0000 0000的映射地址。这一过程是系统自动完成的。 在系统启动后，CPU从地址0x0000 0000获取栈顶地址，然后从0x0000 0004开始执行代码。换句话说，由于0x0000 0000被映射了其他地址，获取栈顶与执行实际上都是从映射的地址上实施的。也就是从映射的地址开始执行代码，比如从地址0x08000 0004开始执行代码(如Mian Flash映射)，比如0x1FFF C804(如System Flash映射，即BootLoader启动)。于是，我们简单整理下系统的整个启动流程: -&gt; 系统复位 -&gt; CPU在系统时钟的第4个上升沿根据BOOT0，BOOT1的配置确定寄存器SYSCFG_CFGR1的MEM_MODE的值 -&gt; MEM_MODE进一步决定哪个地址(Main Flash,System Flash,SRAM)映射到地址0x0000 0000. -&gt; CPU从地址0x0000 0000获取栈顶，从0x0000 0004开始执行代码，也就是从映射地址获取栈顶，从映射地址+4的地方开始执行代码。 映射地址+4对于着复位中断例程(如0x08000 0004)，也就是系统一开始就执行Reset_Handler，进而运行SystemInit然后进入到main函数，就这样，整个代码启动完成。 接下来就是中断产生于中断响应了。 &emsp;&emsp;在Coretext-M3与Coretext-M4核中，在 System Control Block 中存在一个向量表偏移量寄存器 VTOR(0xE000ED08)，系统产生中断后，内核通过这个寄存器的值来找到中断向量表的地址，进而执行中断例程代码，当然，此寄存器的值是可以修改的，它的默认值为0。 &emsp;&emsp;由于STM32F0XX采用的是M0核，它是没有这个VTOR寄存器的；将M0理解成M3/M4的特殊情况，M0假设也存在VTOR这么一个虚拟寄存器，只不过它的值不能修改,固定为0罢了，而M3/M4的这个VTOR寄存器一开始时它的值也是为默认值0，只不过在程序运行到SystemInit()函数后，在代码中明确对其进行了修改。 重新整理下，STM32F0XX中断的调用过程: -&gt; 产生中断 -&gt; CPU固定到地址0x0000 0000上找中断入口函数；由于映射关系，实际上是在从映射地址上寻找。 -&gt; 找到并执行中断例程 五、Stm32F030的App工程配置&emsp;&emsp;关于Stm32F0的APP，只需要更改工程配置的 IROM 和 IRAM 就行了。 &emsp;&emsp;IRAM存放着重映射中断向量表。1个地址存储1个byte(Falsh 和 Ram 都一样)，中断向量都是uint32_t；所以 48 * (32/8) = 0xC0 。 六、友情连接&emsp;&emsp;关于Stm32F0的IAP，ST官方有套参考代码；ST官方的IAP + Ymodem代码；提取码为：aan9&emsp;&emsp;本篇文章部分内容来自于这位博主：flydream0，有些更细致的内容可以了解他写的链接文章。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>bootloader</tag>
        <tag>编译工具链</tag>
        <tag>Stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IAP升级 & Bootloader制作]]></title>
    <url>%2F2020%2F08%2F12%2FIAP%E5%8D%87%E7%BA%A7-Bootloader%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇主要讲基于Stm32的IAP升级(即Bootloader升级)。主要是讲解Bootloader制作思路(该思路不只是用于该系列的芯片)。此篇文章内容较多，需要慢慢消化，部分内容可以先跳着看。 一、IAP &amp; Bootloader1.1 IAP &amp; ISP ISP：In System Programing，在系统编程 IAP：In applicating Programing，在应用编程 &emsp;&emsp;ISP是指可以在板级上进行编程，也就是不用拆芯片下来，写的是整个程序，一般是通过ISP接口线来写。 &emsp;&emsp;IAP虽然同样也是在板级上进行编程，但是是自已对自已进行编程，在应用中进行编程，也即可以只是更改某一部分而不影响系统的其它部分，另外接口程序是自已写的，这样可以进行远程升级而不影响应用。 &emsp;&emsp;ISP即是我们平常编程下载的方法，每次烧录程序都要把MCU的Flash全部都擦除一遍；IAP下载，则是擦除部分Flash(APP)，另外部分未擦除部分(Bootloader)可以根据自己祖传留下的代码搞一些骚操作，例如把自己的活(擦写存储APP代码的Flash)搞完就跑去执行被擦除(刷新)过Flash程序(APP)。常见的方法就是在Bootloader擦除APP程序，擦除完再跳转到新的APP程序继续运行，实现不需要烧录线进行ISP下载就能升级。 1.2 Bootloader&emsp;&emsp;源自linux上的BootLoader的概念，在linux上，BootLoader是首先执行的程序，BootLoader启动之后初始化CPU、RAM、Flash等设备，然后从Flash中读取Linux程序数据到RAM中去，最后跳转到RAM中Linux的起始地址中去启动Linux系统。除了从Flash中读取系统启动之外，BootLoader还能通过网络NFS协议从服务器上读取Linux并启动。BootLoader还能够更新Linux内核、配置Linux启动信息、测试系统等等。 &emsp;&emsp;在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像Window自带BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。 &emsp;&emsp;简单理解的话，Bootloader就是我们常见的计算机开机操作，而我们则是想要打开自己想用的软件Keil(APP)。我们没办法秒开机直接运行Keil(APP)，需要等待一段时间；计算机需要做底层软、硬件的配置(Bootloader)。 &emsp;&emsp;我们要做的STM32的BootLoader也是类似的工作原理，但是没有Linux系统的BootLoader功能那么强大。我们要做的STM32的BootLoader只有两个主要目的： 跳转到应用程序并执行； 更新应用程序(App)； Ps： 因此，下载新(App)程序后并不擦除bootLoader程序，下次启动依然先运行BootLoader程序，可以选择性更新或者不更新程序，所以STM32的BootLoader作用往往就是用来管理单片机程序的更新。 1.3 Bootloader &amp; App&emsp;&emsp;其实IAP升级，就需要将原有APP，分割成Bootloader和新APP。Bootloader负责检查更新APP，新APP则是继续执行原有APP功能；但是在MCU的Flash上，会产生地址分块(Bootloader+App)，新APP则是需要重映射中断向量表 Bootloader里面主要是 设置规划bootloader和app的空间 接收编译好的app的bin文件，写入flash 实现跳转至APP App里面主要修改的地方是 ROM起始地址和分配的空间大小 中断向量表 重定向 生成bin文件 Ps： 由于Bootloader可以对接收bin文件方法有多种多样，因此常见的升级方式为: 串口升级(私有协议或者X-Modem、Y-Modem) USB升级(DFU) U盘升级(OTG) 网络升级 无线升级(OTA,例如蓝牙) 二、IAP升级的预备知识2.1 复位序列&emsp;&emsp;M3单片机复位后，从0x00000000取栈指针（SP）， 从0x00000004取复位向量（PC），有了栈指针和复位向量后，单片机就按照正常流程运行了；在BootLoader里面，我们更新完程序后需要做的步骤之一就是设置栈指针，跳转复位向量。 2.1.1 栈指针&emsp;&emsp;CPU 按照 MSP 指针，到ROM存取地址或数据。 2.1.2 pc指针&emsp;&emsp;CPU 按照 PC 指针，到ROM去取指令代码。PC，是 program calculate 的缩写,即程序计数器； Ps： 当前PC在ROM的位置就是程序执行到的位置；在涉及到操作系统(ucOS)原理的时候，PC指针就扮演着十分重要的角色。 &emsp;&emsp;有了栈指针和复位向量后，单片机就能够运行了！ 2.2 重定位中断向量表2.2.1 中断向量表里面到底是什么，它放在哪里？到底有什么用？ 中断向量表实际上就是存放在 code区 0地址开始的一个数组，数组的成员为4个字节，而且这些数组在启动文件的时候已经初始化好，既然初始化好，那里面存放的是什么？ STM32根据内核和外设中断优先级，统一标号，标号越小，优先级越大。然后把内核和外设的中断服务函数的地址放到这个数组里面，数组的下标跟中断的优先级对应，我们也把这个中断的编号叫做中断向量。 在启动文件执行的时候，内核和每个外设的中断服务函数的地址都是已经确定好的，地址就存放在中断向量表中，而且在启动文件里面已经写好了中断服务函数，只是这些中断服务函数为空，而且带[weak]弱定义，那么我们就需要在C文件里面重新实现这个中断服务函数，用户写这个中断服务函数的时候，函数名必须跟启动文件里面写的中断函数名对应，因为函数名对应的就是中断服务函数的地址，如果名字搞错了，那么在响应中断的时候，就默认响应启动文件里面预先写好[weak]、空的中断服务函数，而且是一个死循环。 2.2.2 内核是如何响应中断的呢？&emsp;&emsp;当中断来临的时候，首先取向量，每个中断的中断向量不一样，然后根据向量查询中断向量表，根据表里面的地址找到中断服务函数，从而实现整个中断的响应过程。 2.2.3 理解了中断向量表后 那么你在C文件里面写中断服务函数的时候就知道为什么要这样写中断服务函数的名字，而且你也可以修改启动文件里面的中断向量表里面的地址（即修改函数名字即可）。 在后面移植ucosiii等os的时候，也知道PendSV要怎么移植和修改 &emsp;&emsp;BootLoader是一个完整的程序，更新用的App也是一个完整的程序。一个完整嵌入式程序都包含中断向量表，用于响应中断；两者当然无法共用一套中断处理(用法可能不同)，因此需要两个中断向量表，第一个中断向量表可以使用默认，而另外一个中断向量表则需要重定位(映射)。 2.3 ROM的起始地址&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址 0x08000000 ，也就是说如果上面的中断向量表要重定义向到Flash上，是以基地址 0x08000000 计算偏移的(也可以重定向到RAM)；程序所有函数的地址默认都在以0x08000000为基地址的一段ROM里面了。 2.3.1 程序起始地址0x08000000&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址0x0800 0000，而CM3手册规定芯片复位时要从0x0000 0000地址开始取出中断向量，那STM32怎么样执行代码呢？是地址重映射？或者在0x0000 0000里有对应有实际存储器？ &emsp;&emsp;仔细阅读手册，STM32设计的Flash起始地址是在0x0800 0000位置开始的；全部代码都只能从这里开始存储，故要重映射。详见STM32 referenc manual手册第54页。 &emsp;&emsp;那既然从这里才能存储代码，就必须在MDK里设置Flash地址为0x0800 0000，下面是MDK设置页面，这个应该都看到过。 这样就产生一个问题，CM3中规定上电后CPU是从0地址开始执行，STM32设计的Flash起始地址是在0x0800 0000位置开始的，因此中断向量表烧写在0x0800 0000地址里，那启动时不就找不到中断向量表了？ &emsp;&emsp;既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了。 当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取 所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。 这就是最难理解的地方，其实，这是基本上所有ARM芯片采用的启动映射方法。ARM7，ARM9没有内部Flash的通常都是这样做的。这个过程出自STM32 referenc manual手册，里面是有说明的。 2.4 hex文件和bin文件&emsp;&emsp;Bootloader程序升级，往往是采用写入bin文件；那hex文件和bin文件有什么关系呢？ hex文件 hex文件是以ASCII文本形式保存编译后的二进制文件信息。Hex文件使用ASCII文本的形式保存Bin文件的内容和Bin文件的一些配置信息。hex文件可以由下载器（比如jlink）烧写到MCU的ROM中。 平时用J-LINK或者串口ISP下载程序，都是下载hex文件的;因为hex文件包含地址信息，下载程序的时候知道程序下载到ROM的哪个区域。反过来讲，hex文件是不能直接写进ROM的，一边写需要一边转换(解码出地址信息，将对应内容写入ROM)。 bin文件 Bin文件是MCU固件烧写的最终形式，也就是说MCU的ROM中烧写的内容完全就是Bin文件的内容。 hex &amp; bin 区别 Hex文件有更好的可读性，最重要的是hex文件能够保证固件在保存与传输时的完整性。因此hex文件更适用于保存与传输。 Bin文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过Bin文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。 bin文件生成 &emsp;&emsp;默认情况下编译后生成的是hex文件，没有生成bin文件。keil的Bin文件生成方式有很多种，可以另外下载一个hex2bin工具，然后用Keil脚本执行；这里，介绍使用Keil自带的工具fromelf.exe。在Keil的安装目录下，例如：E:\Keil\ARM\ARMCC\bin\fromelf.exe 第一种方式：设置绝对路径(不建议这样做，别人用你工程需要再次修改路径) 1D:\Program Files\MDK516\ARM\ARMCC\bin\fromelf.exe" --bin -o ./obj/test_app.bin ./obj/test_app.axf 第二种方式：相对路径，直接复制下面的路径就能直接使用 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L &emsp;&emsp;bin文件生成在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下你可看到一个test1.bin（名字是根据你的hex文件名字一样）。 希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作： 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L 生成的文件也是在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin。 三、IAP升级的具体实现&emsp;&emsp;这次的例子采用的是串口Y-modem协议进行IAP升级。 3.1 Bootloader程序的编写程序编写主要几件事： 编写串口Y-modem（或者X-modem）协议，接收bin文件 把串口接收的bin文件缓存块，写入Stm32的flash指定地址 通过工程的 .map文件，大致规划好Bootloader和APP的Flash储存块地址(这肯定不能重叠了) Bootloader执行程序能跳转到APP去 编译完成后，注意查看 .map文件，在编译器配置限制一下Bootloader程序的大小。 &emsp;&emsp;对X-modem协议进一步了解的，可以看这篇博文： Xmodem协议&emsp;&emsp;对Stm32的flash如何写数据，可以看这篇博文： stm32内部flash基础知识&emsp;&emsp;放出官方源码：ST官方的IAP + Ymodem代码；提取码为：aan9 3.2 Bootloader 跳转代码的理解跳转代码如下，后面逐条分析: 1234567891011121314151617181920typedef void (*pFunction)(void);pFunction JumpApp;/********************************************************************************* 函数名 : IAP_LoadApp* 功 能 : Bootloader跳转至APP* 说 明 : none* 入 参 : none* 返 回 : none* 设 计 : Shatang 时 间 : 2020.06.23* 修 改 : none 时 间 : none********************************************************************************/void IAP_LoadApp(uint32_t Appxaddr)&#123; if(((*(__IO uint32_t*)Appxaddr) &amp; 0x2FFE0000) == 0x20000000) //检查栈顶地址是否合法. &#123; JumpApp = (pFunction)*(__IO uint32_t*)(Appxaddr + 4); //用户代码区第二个字为程序开始地址(复位地址) __set_MSP(*(__IO uint32_t*)Appxaddr); //初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址) JumpApp(); //跳转到APP. &#125;&#125; 12if (((*(__IO uint32_t*)Appxaddr) &amp; 0x2FFE0000 ) == 0x20000000)//判断栈定地址值是否在0x2000 0000 - 0x 2000 2000之间 在程序里 #define Appxaddr 0x8003000 *(__IO uint32_t*)Appxaddr) ，即取0x8003000开始到0x8003003 的4个字节的值 因为我们的应用程序APP中设置把 中断向量表 放置在0x08003000 开始的位置；而中断向量表里第一个放的就是栈顶地址的值 &emsp;&emsp;也就是说，这句话即通过判断栈顶地址值是否正确（是否在0x2000 0000 - 0x 2000 2000之内）来判断是否应用程序已经下载了，因为应用程序的启动文件刚开始就去初始化化栈空间，如果栈顶值对了，说应用程已经下载了，启动文件的初始化也执行了。 1JumpApp = (pFunction)*(__IO uint32_t*)(Appxaddr + 4); &emsp;&emsp;ApplicationAddress + 4 即为0x0800 3004 ,里面放的是运行必不可少的第二项“复位地址”。此处强制转换，将地址值转换成指向地址。&emsp;&emsp;void (*pFunction)(void); 是声明一个函数指针。将复位地址作为函数指针，当其执行该函数指针时，就是执行复位函数。 1__set_MSP(*(__IO uint32_t*) ApplicationAddress); //设置主函数栈指针 &emsp;&emsp;顾名思义，从上面可知内容，就是取 ApplicationAddress 开始到 ApplicationAddress+3 的4个字节的值，设置为栈顶地址(1个字，大小：4字节)。 总结： 因此Bootloader跳转到App，最核心的点就只有两个(保证程序运行)： 1)设置新复位向量(地址)，并跳转执行； 2)设置新栈顶地址，并将主函数栈指针指向该地址。 3.3 APP 重映射中断向量表&emsp;&emsp;中断向量表是可以在程序中多次被映射的(可能你有多个APP程序)。在Cortex-M3系列芯片中，控制它的就是CM3已经规定的 NVIC寄存器 SCB->VTOR 。在STM32库中给出的启动代码里，startup_stm32f10x_hd.s文件里，第146行，是上电后读取中断向量表中的复位中断位置，并执行复位中断处理代码，代码如下： 12345678910; Reset handlerReset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT __main IMPORT SystemInit LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP &emsp;&emsp;注意复位后第一个被执行的是SystemInit代码，这个代码在库目录下的 system_stm32f10x.c 文件里，它初始化了时钟，NVIC等一系列操作；这里摘要与中断向量有关的代码： 12345678910void SystemInit (void)&#123;......#ifdef VECT_TAB_SRAM SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */#else SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */#endif &#125; &emsp;&emsp;可以看出中断向量重映射是一个选择性编译，通常宏定义 VECT_TAB_SRAM 都没有被定义，所以这里执行结束后， SCB->VTOR 就是 FLASH_BASE 了，值为 0x08000000 。以后CM3再取中断向量里，就会根据 SCB->VTOR 的设置，从这里取向量执行了。中断向量自此开始偏移。 Ps： 这时连__main函数都还没进，中断向量的重映射位置还是够早的。 &emsp;&emsp;当然，有些其他系列ST芯片都没有SCB->VTOR，例如M0系列；这里有专门一篇文章讲解M0如何编写App的中断向量表重映射：M0的中断向量表重映射。 四、多种升级方式的源码&emsp;&emsp;基于Stm32F407的SD卡升级&emsp;&emsp;基于Stm32F407的U盘Host，USB_FS升级&emsp;&emsp;基于Stm32F407的U盘Host，USB_HS复用为USB_FS升级&emsp;&emsp;基于Stm32F103的485串口Ymodem协议升级]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>IAP</tag>
        <tag>bootloader</tag>
        <tag>Xmodem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xmodem协议]]></title>
    <url>%2F2020%2F08%2F12%2FXmodem%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;常用于嵌入式IAP串口升级。 一、什么是Xmodem协议？&emsp;&emsp;XMODEM协议是一种串口通信中广泛用到的异步文件传输协议。分为标准Xmodem和1k-Xmodem两种，前者以128字节块的形式传输数据，后者字节块为1k即1024字节，并且每个块都使用一个校验和过程来进行错误检测。在校验过程中如果接收方关于一个块的校验和与它在发送方的校验和相同时，接收方就向发送方发送一个确认字节(ACK)。由于Xmodem需要对每个块都进行认可，这将导致性能有所下降，特别是延时比较长的场合，这种协议显得效率更低。 &emsp;&emsp;除了Xmodem，还有Ymodem，Zmodem协议。他们的协议内容和Xmodem类似，但是进行了拓展。 Ymodem允许批处理文件传输，效率更高； Zmodem则是改进的了Xmodem，它只需要对损坏的块进行重发，其它正确的块不需要发送确认字节。减少了通信量。 二、Xmodem协议相关控制字符 命令字符 命令码 SOH 0x01 (Modem数据头) STX 0x02 EOT 0x04 (发送结束) ACK 0x06 (应答) NAK 0x15 (非应答) CAN 0x18 (取消发送) CTRLZ 0x1A 三、Xmodem数据包格式 标准Xmodem协议（每个数据包含有128字节数据）帧格式 | SOH | 信息包序号 | 信息包序号的补码 | 数据区段(128个字节) | 校验和 | 标准XModem传输流程 &emsp;&emsp;1k-Xmodem 只是在Xmodem协议基础上，进行了数据包长度的改进，从原有的128字节更改为1k字节。同时每个信息报的第一个字节的SOH变成了STX，STX定义为 0x02 ，能有效的加快数据传输速率。 四、校验方式和传输流程4.1 校验方式说明&emsp;&emsp;Xmodem协议支持2种校验和，它们是累加和与CRC校验。 当接收方一开始启动传输时发送的是NAK，表示它希望以累加和方式校验； 当接收方一开始启动传输时发送的是字符“C”，表示它希望以CRC方式校验。 &emsp;&emsp;可能有人会问，接收方想怎么校验发送方都得配合吗，难道发送方必须都支持累加和校验和CRC校验？事实上Xmodem要求支持CRC的就必须同时支持累加和。如果发送方只支持累加和，而接收方用字符“C”来启动，那么发送方只要不管它，当接收方继续发送“C”，三次后都没收到应答，就自动会改为发送 NAK；因为它已经明白发送方可能不支持CRC校验，现在接收方改为累加和校验和发送方通讯。发送方收到NAK就赶紧发送数据包响应。 4.2 启动传输&emsp;&emsp;传输由接收方启动，方法是向发送方发送”C”或者NAK （注意哦，这里提到的NAK是用来启动传输的；以后我们会看到NAK还可以用来对数据产生重传的机制）。 接收方发送NAK信号表示接收方打算用累加和校验； 发送字符”C”则表示接收方想打算使用CRC校验 举例，接收方要求发送方以校验和方式发送时以NAK来请求，发送方将对此做出应答。如下图： 4.3 传输过程&emsp;&emsp;当接收方发送的第一个”C”或者NAK到达发送方，发送方认为可以发送第一个数据包，传输已经启动。发送方接着应该将数据以每次128字节的数据加上包头，包号，包号补码，末尾加上校验和，打包成帧格式传送。 &emsp;&emsp;发送方发了第一包后就等待接收方的确认字节ACK，收到接收方传来的ACK确认，就认为数据包被接收方正确接收，并且接收方要求发送方继续发送下一个包；如果发送方收到接收方传来的NAK （这里，NAK用来告诉发送方重传，不是用来启动传输） 字节，则表示接收方请求重发刚才的数据包； &emsp;&emsp;如果发送方收到接收方传来的CAN字节，则表示接收方请求无条件停止传输。 4.4 结束传输&emsp;&emsp;如果发送方正常传输完全部数据，需要结束传输，正常结束需要发送方发送EOT 字节通知接收方。接收方回以ACK进行确认。当然接收方也可强制停止传输，当接收方发送CAN 字节给发送方，表示接收方想无条件停止传输，发送方收到CAN后，不需要再发送 EOT确认（因为接收方已经不想理它了，呵呵）。 4.5 特殊处理&emsp;&emsp;虽然数据包是以 SOH 来标志一个信息包的起始的，但在 SOH 位置上如果出现EOT则表示数据传输结束，再也没有数据传过来。 接收方首先应确认数据包序号的完整性，通过对数据包序号取补，然后和数据包序号的补码异或，结果为0表示正确，结果不为0则发送NAK请求重传。 接收方确认数据包序号正确后，然后检查是否期望的序号。如果不是期望得到的数据包序号，说明发生严重错误，应该发送一个 CAN 来中止传输。 如果接收到的数据包的包序号和前一包相同，那么接收方会忽略这个重复包，向发送方发出 ACK ，准备接收下一个包。 接收方确认了信息包序号的完整性和是正确期望的后，只对 128 字节的数据区段进行算术和校验，结果与帧中最后一个字节（算术校验和）比较，相同发送 ACK，不同发送 NAK。 4.6 数据包特殊说明&emsp;&emsp;对于标准Xmodem协议来说，如果传送的文件不是128的整数倍，那么最后一个数据包的有效内容肯定小于帧长，不足的部分需要用CTRL- Z(0x1A)来填充。这里可能有人会问，我数据末尾是0x1A呢？ 如果传送的是文本文件，那么接收方对于接收的内容是很容易识别的，因为Xmodem协议定义的CTRL-Z(0x1A) 不是前128个ascii码中的通用可见字母等字符( 0x1A 对应 SUB[替补] )。 如果传送的是二进制文件，例如 bootloader 工程生成的.bin文件。假如我的.bin文件最末尾是0x1A，那如何区分填充的0x1A？ 例如像excel文件等，由于其数据内部会有些结构表示各个字段长度等，所以不会读取多余的填充字符。 而.bin文件，一般是不做区分的，它直接把填充码直接同样写入flash Flash写入是要擦除的，如果想利用填充码位置的Flash，只能用一次性，不然会损坏到IAP升级的APP文件 Mcu其实不会把填充码当作代码来执行(没有跳转到该位置的代码块)。 如果使用 1k-Xmodem ，最极端的情况下，也就浪费Mcu不到1K flash；(对于芯片Flash容量小，即扇区也小，干脆直接用Xmodem升级) 五、补充知识：128个字符的ASCII码表&emsp;&emsp;由于上面的文本文件，对编码格式有疑惑的，建议重新看一下128字符的ASCII码表。基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。&emsp;&emsp;文章的链接为：128个字符的ASIIC码表 六、补充知识：CRC16校验的实现&emsp;&emsp;对CRC校验有疑惑、不了解的，可以看这篇博文：CRC校验算法原理分析 七、代码实例&emsp;&emsp;这里先放一个官方例程：ST官方的IAP + Ymodem代码；提取码为：aan9&emsp;&emsp;再放一个超级终端方便调试升级：超级终端(支持win10)；提取码为：3ejn 7.1 Ymodem协议&emsp;&emsp;从上述Xmodem知识讲解后，如果你去查询 Ymodem协议概念 ，你会发现及其相似。这里我放我的实例；根据官方IAP升级例程进行简化(阉割)，方便理解；芯片是Stm32F407vgt6，支持多串口任选升级 的代码：非标准Ymodem协议的IAP升级。 &emsp;&emsp;标准Ymodem的特点，就是相对Xmodem能进行批文件传输。Ymodem支持文件传输，体现在YModem的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输会先发。 且数据传输结束方法要进行确认： 数据传输完毕后，发送方发EOT，第一次接收方以NAK应答，准备二次确认。 发送方收到NAK后，重发EOT，接收方第二次收到结束符，就以ACK应答。 最后接收方再发送一个’C’，发送方在没有第二个文件要传输的情况下，发送数据SOH 00 FF 00~00(共128个) CRCH CRCL 接收方应答ACK后，正式结束数据传输。 &emsp;&emsp;这样的话，每次建立连接，标准Ymodem一次能传输多文件，即批文件传输。 Ps： 如果应用在嵌入式Bootloader的话，基本都只传一个文件，且要压缩Bootloader程序大小；即接收方嵌入式固件为非标准的Ymodem协议。 7.2 Xmodem &amp; Ymodem&emsp;&emsp;根据 7.1 的实例，能够通过Ymodem协议进行IAP升级；Xmodem 和 Ymodem 极其相似，直接切换成 Xmodem协议 进行升级能不能成呢？ 当然是理所当然地报错了！那么极其相似，但到底差别在哪里？ 文件传输的第一个数据包 Ymodem支持文件传输，体现在了传输文件第一个包；YModem的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输会先发； 而Xmodem是直接传输数据的 数据包报文中的 Byte2 和 Byte3，一个是数据包数，一个是数据包数补码 Ymodem协议，他的数据包数是0x00开始(因为要多接一个文件信息) Xmodem协议，它的数据包数是0x01开始的(= =|||) &emsp;&emsp;通过上述的总结，因为Ymodem与Xmodem很相似，可以根据上面的不同点稍微改一下，就能得到 基于Xmodem协议的IAP升级 代码： 基于Xmodem协议的IAP升级。(残留一些Ymodem的代码，想精简可去掉) 两者带来的差别：Flash的擦除 Ymodem协议，第一包数据可以知道文件名、文件大小，所以不必要直接连接上就擦除Flash； 可以第一包(文件)数据不符合要求就不擦除旧APP的Flash 因此连上超级终端，不升级，设备是不会变成砖的(未擦除) Xmodem协议，不清楚文件，因此一般会连接上后直接擦除旧APP存储的Flash； 因为擦除程序在连接成功后就做，那么如果连上后放弃升级，该设备自然就会变成砖(就我现在写的那个)； 当然也可以改进成在确实收到(识别)第一包数据包后，再擦除Flash；就能实现类似Ymodem的效果 7.3 文件加密(小技巧)&emsp;&emsp;通过上述的Xmodem、Ymodem进行文件传输时，有时候需要文件加密安全一点。我举一个自己在用的例子： 做一个简易的上位机，把bin文件拖进去；由于bin文件就是二进制文件，可以将其 异或 某条字符串，不断循环直至 整个文件异或成 新的文件 通过协议传输后，把获取到的数据，又重新异或一遍，这样的话，数据就会解密(数据异或两次就会变回原来的数据)，再写入Flash 上位机的字符串加密要可改写非固定，这样就能实现简单文件加密传输拉！！ Ps： 上面我的代码例程就有夹杂解密的，可以去掉；不过我代码的Ymodem没加CRC校验；Xmodem例程就加了CRC校验。实测加了校验，对实际传输的时间影响不大。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>IAP</tag>
        <tag>串口协议</tag>
        <tag>文件传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32内部Flash基础知识]]></title>
    <url>%2F2020%2F08%2F12%2Fstm32%E5%86%85%E9%83%A8Flash%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于嵌入式IAP升级时，制作的Bootloader往往会涉及到Stm32的Flash的一些操作(用于写入App程序)，因此这里讲解一下Stm32的Flash相关操作 一、Stm32的Flash1.1 Flash的基础原理&emsp;&emsp;此处内容可以看该篇博文：嵌入式存储器 1.2 Stm32的Flash特性、操作 已知Flash写入前需要擦除的特性 Nor Flash接口与RAM接口相同，因此往往MCU内部采用Nor Flash；即Stm32的Flash为 Nor Flash 因此如果是擦除大块区域时，会相对较慢 Stm32的Flash使用前后，需要 解锁 、 锁定 在实际发布的产品中，在STM32芯片的内部FLASH存储了控制程序，如果不作任何保护措施的话，可以使用下载器直接把内部FLASH的内容读取回来，得到bin或hex文件格式的代码拷贝，别有用心的厂商即可利用该代码文件山寨产品。 &emsp;&emsp;对STM32 内部FLASH进行编程操作，一般需要遵循以下流程： Flash解锁 清除相关标志位 擦除Flash 写入Flash 锁定Flash 1.3 Flash的底层操作函数(仅限Stm32)1234FLASH_Unlock(); //Flash解锁函数FLASH_Lock(); //Flash锁定函数FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange); //Flash擦除函数FLASH_Status FLASH_ProgramWord(uint32_r Address， uint32_t Data); //Flash写入函数 1.4 Flash的衍生操作函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182extern void FLASH_If_Init(void);extern void FLASH_If_Finish(void);extern uint32_t FLASH_If_Erase(uint32_t StartSector);extern uint32_t FLASH_If_Write(__IO uint32_t* FlashAddress, uint32_t* Data ,uint32_t DataLength);extern void FLASH_IF_Read(uint32_t ReadAddr, uint32_t *pBuffer, uint32_t NumToRead);//例子：Stm32F407VGT6的Flash//FLASH 扇区的起始地址#define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) //扇区0起始地址, 16 Kbytes#define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) //扇区1起始地址, 16 Kbytes#define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) //扇区2起始地址, 16 Kbytes#define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) //扇区3起始地址, 16 Kbytes#define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) //扇区4起始地址, 64 Kbytes#define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) //扇区5起始地址, 128 Kbytes#define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) //扇区6起始地址, 128 Kbytes#define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) //扇区7起始地址, 128 Kbytes#define ADDR_FLASH_SECTOR_8 ((uint32_t)0x08080000) //扇区8起始地址, 128 Kbytes#define ADDR_FLASH_SECTOR_9 ((uint32_t)0x080A0000) //扇区9起始地址, 128 Kbytes#define ADDR_FLASH_SECTOR_10 ((uint32_t)0x080C0000) //扇区10起始地址,128 Kbytes#define ADDR_FLASH_SECTOR_11 ((uint32_t)0x080E0000) //扇区11起始地址,128 Kbytes/********************************************************************************* 函数名 : GetSector* 功 能 : 获取某个地址所在的flash扇区* 说 明 : Stm32F407VGT6的Flash扇区分配* 入 参 : fu32_Addr：flash地址* 返 回 : 0~11,即addr所在的扇区* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/static uint16_t GetSector(uint32_t fu32_Addr)&#123; if(fu32_Addr&lt;ADDR_FLASH_SECTOR_1)return FLASH_Sector_0; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_2)return FLASH_Sector_1; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_3)return FLASH_Sector_2; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_4)return FLASH_Sector_3; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_5)return FLASH_Sector_4; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_6)return FLASH_Sector_5; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_7)return FLASH_Sector_6; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_8)return FLASH_Sector_7; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_9)return FLASH_Sector_8; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_10)return FLASH_Sector_9; else if(fu32_Addr&lt;ADDR_FLASH_SECTOR_11)return FLASH_Sector_10; return FLASH_Sector_11; &#125;/********************************************************************************* 函数名 : FLASH_If_Init* 功 能 : stm32的内部flash初始化(解锁)* 说 明 : none* 入 参 : none* 返 回 : none* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/void FLASH_If_Init(void)&#123; FLASH_Unlock(); /* Clear pending flags (if any) */ FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);&#125;/********************************************************************************* 函数名 : FLASH_If_Finish* 功 能 : stm32的内部flash关闭(上锁)* 说 明 : none* 入 参 : none* 返 回 : none* 设 计 : Shatang 时 间 : 2020.07.29* 修 改 : none 时 间 : none********************************************************************************/void FLASH_If_Finish(void)&#123; /* Clear pending flags (if any) */ FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR); FLASH_Lock();&#125;/********************************************************************************* 函数名 : FLASH_If_Erase* 功 能 : stm32的内部flash擦除* 说 明 : 只针对APP文件地址的存储内容进行擦除* 入 参 : none* 返 回 : none* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/uint32_t FLASH_If_Erase(uint32_t StartSector)&#123; uint32_t UserStartSector; uint32_t i = 0; /* Get the sector where start the user flash area */ UserStartSector = GetSector(StartSector); for(i = UserStartSector; i &lt;= GetSector(APPLICATION_END_ADDRESS); i += 8) &#123; /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE) &#123; /* Error occurred while page erase */ return (1); &#125; &#125; return (0);&#125;/********************************************************************************* 函数名 : FLASH_If_Write* 功 能 : stm32的内部flash写操作* 说 明 : none* 入 参 : none* 返 回 : none* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/uint32_t FLASH_If_Write(__IO uint32_t* FlashAddress, uint32_t* Data ,uint32_t DataLength)&#123; uint32_t i = 0; for (i = 0; (i &lt; DataLength) &amp;&amp; (*FlashAddress &lt;= (APPLICATION_END_ADDRESS-4)); i++) &#123; /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if (FLASH_ProgramWord(*FlashAddress, *(uint32_t*)(Data+i)) == FLASH_COMPLETE) &#123; /* Check the written value */ if (*(uint32_t*)*FlashAddress != *(uint32_t*)(Data+i)) &#123; /* Flash content doesn't match SRAM content */ return(2); &#125; /* Increment FLASH destination address */ *FlashAddress += 4; &#125; else &#123; /* Error occurred while writing data in Flash memory */ return (1); &#125; &#125; return (0);&#125;/********************************************************************************* 函数名 : STMFLASH_ReadWord* 功 能 : 读取指定地址的半字(16位数据) * 说 明 : none* 入 参 : fu32_Addr：读地址 * 返 回 : 对应数据* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/static uint32_t STMFLASH_ReadWord(uint32_t fu32_Addr)&#123; return *(volatile uint32_t*)fu32_Addr; &#125; /********************************************************************************* 函数名 : STMFLASH_ReadWord* 功 能 : 从指定地址开始读出指定长度的数据* 说 明 : none* 入 参 : ReadAddr：起始地址 pBuffer：数据指针 NumToRead：读的数据个数* 返 回 : 对应数据* 设 计 : Shatang 时 间 : 2020.06.18* 修 改 : none 时 间 : none********************************************************************************/void FLASH_IF_Read(uint32_t ReadAddr, uint32_t *pBuffer, uint32_t NumToRead)&#123; uint32_t i; for(i=0;i&lt;NumToRead;i++) &#123; pBuffer[i] = STMFLASH_ReadWord(ReadAddr);//读取4个字节. ReadAddr+=4;//偏移4个字节. &#125;&#125; 二、详细应用实例&emsp;&emsp;具体实际应用：基于Xmodem协议的IAP升级，可以看这篇文章：IAP升级 &amp; Bootloader制作]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>bootloader</tag>
        <tag>stm32</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRC校验算法原理分析]]></title>
    <url>%2F2020%2F08%2F10%2FCRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里提一下各种通讯协议都经常使用的CRC校验，为后面的知识做铺垫。 一、CRC分析&emsp;&emsp;我只是把网上能搜到的资料根据自己的理解重新写了一遍，本文大部分内容都来自于下面的两位博主: wchonline ， CRC校验算法详解偏执灬 ， CRC校验算法原理分析 1.1 数据校验&emsp;&emsp;数据在传输过程（比如通过网线在两台计算机间传文件）中，由于传输信道的原因，可能会有误码现象（比如说发送数字5但接收方收到的却是6），如何发现误码呢？方法是发送额外的数据让接收方校验是否正确，这就是数据校验。 &emsp;&emsp;最容易想到的校验方法是和校验，就是将传送的数据(按字节方式)加起来计算出数据的总和，并将总和传给接收方，接收方收到数据后也计算总和，并与收到的总和比较看是否相同。如果传输中出现误码，那么总和一般不会相同，从而知道有误码产生，可以让发送方再发送一遍数据。 1.2 CRC校验原理&emsp;&emsp;CRC(Cyclic Redundancy Check)循环冗余校验是常用的数据校验方法。CRC校验码的基本思想是利用线性编码理论， 在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的监督码（既CRC码）r位，并附在信息后边，构成一个新的二进制码序列数共(k+r)位，最后发送出去。在接收端，则根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错，在数据存储和数据通讯领域常用。 1.3 CRC多项式(理解就行)&emsp;&emsp;一般在数据传输之前，发送端与接收端会相互约定好一个除数（也是一个二进制序列，用来进行模2除法）。这个除数就是生成多项式。 Ps： 这个多项式的最高位和最低位必须为1 &emsp;&emsp;生成多项式的选择是 CRC 算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。 &emsp;&emsp;在构建一个新的 CRC 多项式或者改进现有的 CRC 时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。 生成多项式的最高位和最低位必须为1。 当被传送信息（CRC码）任何一位发生错误时，被生成多项式做模2除后，应该使余数不为0。 不同位发生错误时，应该使余数不同。 对余数继续做模2除，应使余数循环。 1.4 CRC校验简单理解(要点)&emsp;&emsp;在数据传输之前，发送方与接收方会相互约定好一个除数（多项式，进行模2算法）。 发送方：生成CRC校验码。CRC校验码就是将数据除以某个固定的数（比如ANSI-CRC16中，这个数是0x18005），所得到的余数就是CRC校验码。 接收方：接收到数据包+CRC校验码。由于CRC校验码是之前发送方求余出来的数据，将数据包+CRC校验码合并后再进行模2除法校验，理论上余数为0。如果是余数不为0，说明了传输的数据错误。 因此，不同协议的CRC校验码基本不一样，因为约定的除数会根据自己协议制定(例如Modbus通讯)。 &emsp;&emsp;如果被除数比除数小，那么余数就是被除数本身，比如说只要传一个字节，那么它的CRC就是它自己，为避免这种情况，在做除法之前先将它移位，使它大于除数，那么移多少位呢？这就与所选的固定除数有关了，左移位数比除数的位数少1。 &emsp;&emsp;关于模2除法中除数的选择，这个可以自己随意选择。但由 1.3 可知，随意选择的除数会导致帧校验的正确率下降，这是不确定的，要看你选择的除数。而我们一般的除数的选择是直接去参照一些专家讲过多次试验下来的一些除数，这些除法能极大的保证帧校验的正确率。 &emsp;&emsp;一般而言，crc8校验的错误率为1/256(最小单元)，crc16校验的错误率为1/65536(最小单元)，crc32校验的错误率为1/2^32(最小单元)。CRC16的错误率已经是非常小了，所以一般在数据不多的情况下用CRC16校验就可以了，而在整个文件的校验中一般用CRC32校验。 下面是常用标准中的除数： 通用CRC多项式 &emsp;&emsp;由1.3上面要求罗列出常用的多项式如下： CRC8-Dallas/Maxim：多项式是X8+X5+X4+1，对应的数字是0x131，左移8位 CRC8-ATM：多项式是 X8+X2+X1+1，对应的数字是0x107（0x07），左移8位 CRC8-CCITT：多项式是 X8+X6+X4+X3+X2+X1，对应的数字是0x15E（0x5E），左移8位 CRC12：多项式是 X12+X11+X3+X2+1，对应的数字是0x180D，左移12位 CRC16-CCITT：多项式是 X16+X12+X5+1，对应的数字是0x11021，左移16位 CRC16-ANSI ：多项式是 X16+X15+X2+1，对应的数字是0x18005，左移16位 CRC32：多项式是X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+1，对应数字是0x104C11DB7，左移32位 因此，在得到字节串对应的数字后，再将数字左移M位（比如ANSI-CRC16是左移16位），就得到了被除数。 Ps： 由于多项式的最高为都为1，但在代码实现的crc计算中，最高位是不使用的；使用的是上面例子中括号内的值 &emsp;&emsp;从上面可以看到，即使是同为CRC8校验，多项式也有多种；因此计算CRC校验要格外注意多项式是否相同。不同的多项式，起检错能力是不同的。例如Modbus协议就规定 0xA001 就是它CRC校验的多项式。 二、代码实现&emsp;&emsp;算术上的除法，计算机当然会做，但因为减法有借位，很耗时间和指令!所以，计算CRC是除法，但是用XOR来代替减法。除法（XOR）的目的是逐步消掉二进制数最高位的1或0！由于过程是XOR的，所以商是没有意义的，我们不要。我们要的是余数。 2.1 顺序异或 &amp; 反序异或&emsp;&emsp;CRC校验算法，就是把需要校验的数据与多项式进行循环异或（XOR），但进行XOR的方式与实际中数据传输时，是高位先传、还是低位先传有关。对于数据高位先传的方式，XOR从数据的高位开始，我们就叫它顺序异或吧；对于数据低位先传的方式，XOR从数据的低位开始，我们就叫它反序异或吧。两种不同的异或方式，即使对应相同的多项式，计算出来的结果也是不一样的。 &emsp;&emsp;比如前面ccitt-crc16的正序是0x1021，如果是反转就是0x8408（就是将0x1021倒过来低位变高位）。数据传输可能是先传低位再传高位（比如串口就是低位在前高位在后）。反转的CRC算法与正序类似，只是需要注意移位的方向相反。 &emsp;&emsp;这个问题一般不是问题。因为如果是自己写的发送方，当然是可以随便写！(开玩笑的)。如果是写接收方，发送方要么会给详细说明，或者有源码，直接搬迁过来就行了。 2.2 代码例子12345678910111213141516171819202122unsigned char cal_table_high_first(unsigned char value)&#123; unsigned char i, crc; crc = value; /* 数据往左移了8位，需要计算8次 */ for (i=8; i&gt;0; --i) &#123; if (crc &amp; 0x80) /* 判断最高位是否为1 */ &#123; /* 最高位为1，不需要异或，往左移一位，然后与0x31异或 */ /* 0x31(多项式：x8+x5+x4+1，100110001)，最高位不需要异或，直接去掉 */ crc = (crc &lt;&lt; 1) ^ 0x31; &#125; else &#123; /* 最高位为0时，不需要异或，整体数据往左移一位 */ crc = (crc &lt;&lt; 1); &#125; &#125; return crc;&#125; 2.3 CRC校验表&emsp;&emsp;2.2的代码计算一个字节的crc结果，如果计算多个字节的结果也是比较简单的，先计算第一个字节的crc结果，然后把第一个字节的crc结果与第二个字节进行异或，异或后的值再进行一次crc计算就可以了，多个字节也是反复这过程就好。 &emsp;&emsp;但是需要的运行量也是不少的，每一个字节都需要进行8次判断、移位、或异或操作。但是其实每个字节异或的结果是一定的，那就可以事先算好的CRC存入数组。采用查表法，大大减少计算量，先计算出 0x00~0xFF 每一个字节的crc校验结果，后面就可以通过表来查出每个字节的crc结果，大大 减少计算量。 下面是一个表生成程序： 123456789101112131415void create_crc_table(void)&#123; unsigned short i; unsigned char j; for (i=0; i&lt;=0xFF; i++) &#123; if (0 == (i%16)) printf("\n"); j = i&amp;0xFF; printf("0x%.2x, ", cal_table_high_first (j)); /*依次计算每个字节的crc校验值*/ &#125; &#125; 得到的表整理如下： 12345678910111213141516171819static const unsigned char crc_table[] =&#123; 0x00,0x31,0x62,0x53,0xc4,0xf5,0xa6,0x97,0xb9,0x88,0xdb,0xea,0x7d,0x4c,0x1f,0x2e, 0x43,0x72,0x21,0x10,0x87,0xb6,0xe5,0xd4,0xfa,0xcb,0x98,0xa9,0x3e,0x0f,0x5c,0x6d, 0x86,0xb7,0xe4,0xd5,0x42,0x73,0x20,0x11,0x3f,0x0e,0x5d,0x6c,0xfb,0xca,0x99,0xa8, 0xc5,0xf4,0xa7,0x96,0x01,0x30,0x63,0x52,0x7c,0x4d,0x1e,0x2f,0xb8,0x89,0xda,0xeb, 0x3d,0x0c,0x5f,0x6e,0xf9,0xc8,0x9b,0xaa,0x84,0xb5,0xe6,0xd7,0x40,0x71,0x22,0x13, 0x7e,0x4f,0x1c,0x2d,0xba,0x8b,0xd8,0xe9,0xc7,0xf6,0xa5,0x94,0x03,0x32,0x61,0x50, 0xbb,0x8a,0xd9,0xe8,0x7f,0x4e,0x1d,0x2c,0x02,0x33,0x60,0x51,0xc6,0xf7,0xa4,0x95, 0xf8,0xc9,0x9a,0xab,0x3c,0x0d,0x5e,0x6f,0x41,0x70,0x23,0x12,0x85,0xb4,0xe7,0xd6, 0x7a,0x4b,0x18,0x29,0xbe,0x8f,0xdc,0xed,0xc3,0xf2,0xa1,0x90,0x07,0x36,0x65,0x54, 0x39,0x08,0x5b,0x6a,0xfd,0xcc,0x9f,0xae,0x80,0xb1,0xe2,0xd3,0x44,0x75,0x26,0x17, 0xfc,0xcd,0x9e,0xaf,0x38,0x09,0x5a,0x6b,0x45,0x74,0x27,0x16,0x81,0xb0,0xe3,0xd2, 0xbf,0x8e,0xdd,0xec,0x7b,0x4a,0x19,0x28,0x06,0x37,0x64,0x55,0xc2,0xf3,0xa0,0x91, 0x47,0x76,0x25,0x14,0x83,0xb2,0xe1,0xd0,0xfe,0xcf,0x9c,0xad,0x3a,0x0b,0x58,0x69, 0x04,0x35,0x66,0x57,0xc0,0xf1,0xa2,0x93,0xbd,0x8c,0xdf,0xee,0x79,0x48,0x1b,0x2a, 0xc1,0xf0,0xa3,0x92,0x05,0x34,0x67,0x56,0x78,0x49,0x1a,0x2b,0xbc,0x8d,0xde,0xef, 0x82,0xb3,0xe0,0xd1,0x46,0x77,0x24,0x15,0x3b,0x0a,0x59,0x68,0xff,0xce,0x9d,0xac&#125;； 采用查表法计算crc代码如下： 12345678910unsigned char cal_crc_table(unsigned char *ptr, unsigned char len) &#123; unsigned char crc = 0x00; while (len--) &#123; crc = crc_table[crc ^ *ptr++]; &#125; return (crc);&#125; 2.4 反序异或计算的代码&emsp;&emsp;反序异或与顺序异或差异在数据先判断最低位，并且数据是向右移的，并且多项式数据位需要高低位反转一下。还是以多项式：x8+x5+x4+1（二进制为：100110001）为例：则计算一个字节的crc校验代码如下： 12345678910111213141516171819unsigned char cal_table_low_first(unsigned char value)&#123; unsigned char i, crc; crc = value; /* 同样需要计算8次 */ for (i=8; i&gt;0; --i) &#123; if (crc &amp; 0x01) /* 反序异或变成判断最低位是否为1 */ /* 数据变成往右移位了 */ /* 计算的多项式从0x31（0011 0001）变成了0x8C (1000 1100) */ /* 多项式值，原来的最高位变成了最低位，原来的最低位变成最高位，8位数据高低位交换一下位置 */ crc = (crc &gt;&gt; 1) ^ 0x8C; else crc = (crc &gt;&gt; 1); &#125; return crc;&#125; 三、例程：Modbus的CRC16校验&emsp;&emsp;代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static const UCHAR aucCRCHi[] = &#123; 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40&#125;;static const UCHAR aucCRCLo[] = &#123; 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40&#125;;USHORTusMBCRC16( UCHAR * pucFrame, USHORT usLen )&#123; UCHAR ucCRCHi = 0xFF; UCHAR ucCRCLo = 0xFF; int iIndex; while( usLen-- ) &#123; iIndex = ucCRCLo ^ *( pucFrame++ ); ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] ); ucCRCHi = aucCRCLo[iIndex]; &#125; return ( USHORT )( ucCRCHi &lt;&lt; 8 | ucCRCLo );&#125;]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[128个字符的ASCII码表]]></title>
    <url>%2F2020%2F06%2F28%2F128%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84ASCII%E7%A0%81%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里复习、细讲ASCII码表，为后面的知识做铺垫。 一、128个字符的ASCII码表&emsp;&emsp;重新认识一下128字符的ASCII码表。基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。 Dec Hex 缩写/字符 解释 0 00 NUL(null) 空字符 1 01 SOH(start of headline) 标题开始 2 02 STX (start of text) 正文开始 3 03 ETX (end of text) 正文结束 4 04 EOT (end of transmission) 传输结束 5 05 ENQ (enquiry) 请求 6 06 ACK (acknowledge) 收到通知 7 07 BEL (bell) 响铃 8 08 BS (backspace) 退格 9 09 HT (horizontal tab) 水平制表符 10 0A LF (NL line feed, new line) 换行键 11 0B VT (vertical tab) 垂直制表符 12 0C FF (NP form feed, new page) 换页键 13 0D CR (carriage return) 回车键 14 0E SO (shift out) 不用切换 15 0F SI (shift in) 启用切换 16 10 DLE (data link escape) 数据链路转义 17 11 DC1 (device control 1) 设备控制1 18 12 DC2 (device control 2) 设备控制2 19 13 DC3 (device control 3) 设备控制3 20 14 DC4 (device control 4) 设备控制4 21 15 NAK (negative acknowledge) 拒绝接收 22 16 SYN (synchronous idle) 同步空闲 23 17 ETB (end of trans. block) 传输块结束 24 18 CAN (cancel) 取消 25 19 EM (end of medium) 介质中断 26 1A SUB (substitute) 替补 27 1B ESC (escape) 换码(溢出) 28 1C FS (file separator) 文件分割符 29 1D GS (group separator) 分组符 30 1E RS (record separator) 记录分离符 31 1F US (unit separator) 单元分隔符 32 20 (space) 空格 33 21 ! 34 22 “ 35 23 # 36 24 $ 37 25 % 38 26 &amp; 39 27 ‘ 40 28 ( 41 29 ) 42 2A * 43 2B + 44 2C , 45 2D - 46 2E . 47 2F / 48 30 0 49 31 1 50 32 2 51 33 3 52 34 4 53 35 5 54 36 6 55 37 7 56 38 8 57 39 9 58 3A : 59 3B ; 60 3C &lt; 61 3D = 62 3E &gt; 63 3F ? 64 40 @ 65 41 A 66 42 B 67 43 C 68 44 D 69 45 E 70 46 F 71 47 G 72 48 H 73 49 I 74 4A J 75 4B K 76 4C L 77 4D M 78 4E N 79 4F O 80 50 P 81 51 Q 82 52 R 83 53 S 84 54 T 85 55 U 86 56 V 87 57 W 88 58 X 89 59 Y 90 5A Z 91 5B [ 92 5C \ 93 5D ] 94 5E ^ 95 5F _ 96 60 ` 97 61 a 98 62 b 99 63 c 100 64 d 101 65 e 102 66 f 103 67 g 104 68 h 105 69 i 106 6A j 107 6B k 108 6C l 109 6D m 110 6E n 111 6F o 112 70 p 113 71 q 114 72 r 115 73 s 116 74 t 117 75 u 118 76 v 119 77 w 120 78 x 121 79 y 122 7A z 123 7B { 124 7C | 125 7D } 126 7E ~ 127 7F DEL (delete) 删除 二、ASCII码表带来的现象2.1 Modbus协议模式选择&emsp;&emsp;在Modbus通讯协议中，分为RTU &amp; ASCII 模式。在底层的串口配置中，RTU模式只能配置 8-e-1，8-o-1,8-n-1的8位数据位；而ASCII模式不仅可以配置以上的模式，还可以配置7-e-1，7-o-1，7-n-1。 这里的原因，就是因为ASCII基本码就是128个，完全(刚好)能用7个bit来表示。而RTU发送十六进制的数据，则需要8个bit(0xff)，被去掉了一位，因为是不支持7位的数据位发送。 &emsp;&emsp;这里又暗示了串口的一个理解上的误区。串口发送的最小单位和数据帧的最小单位。假如串口模式是7位的数据位，你发的是数据基本单位是0xff(8bit)；例如你发 0xff 0x12 0x34 ，此时串口会截取掉高位，只发每个数据单元的7bit。不会说这先发这个数据的7bit，多出来的 1bit 下次再填进去补给你(下次一定)。 2.2 中文字符乱码&emsp;&emsp;从上面延伸出来的串口发送知识误区，得到一种 中文字符乱码 的现象。假如一个产品，有中英文，可以通过串口打印出数据；你会发现一旦串口配置为7位数据位，英文版本打印正常，而中文版本打印异常。 这就是因为汉字是双字的，拆分出来两个8bit(0xff)，假如串口使用7位的数据位，就会截取掉高位；而英文是ASCII，只需要7bit，因此英文显示正常。 2.3 对字符的解析&emsp;&emsp;常见于几种情况，举例如下： 制作裸机不带enwin的嵌入式led驱动 与GSM模块等通讯 通讯协议的数据包的识别区分(例如X-modem协议) &emsp;&emsp;led驱动的字符显示驱动，把要显示的字符串，截取成逐个的字符，做显示；显示会做判断两种情况，: *s &lt; 128 , 显示ASCII码库的字符 *s &gt; 128 , 显示自己写的(汉字)库的字符(汉字双字节 0xffff 明显超过 0x7f) &emsp;&emsp;与GSM模块进行通讯配置的时候，而且这种通讯是字符的。 12345if((uint32_t)cmd&lt;=0XFF) &#123; while((USART3-&gt;SR&amp;0X40)==0);//等待上一次数据发送完成 USART3-&gt;DR=(u32)cmd; &#125;else u3_printf("%s\r\n",cmd);//发送命令 如果是有写过类似GSM模块通讯的，应该都看过类似上面语句。主控发给模块的指令，先分解逐个字符；再根据是否小于0xff，是直接发还是用字符串打印函数。 &emsp;&emsp;如果是小于0xff，当然是可以用串口8位的数据位进行发送；但是什么时候才会大于0xff，就是该 cmd 非ASCII的时候(而是字符串)，例如汉字。 &emsp;&emsp;X-modem协议的数据包的识别区分。当利用Xmodem协议进行传输文本文件，因为数据包的结束符 CTRL-Z(0x1A) 不是前128个ascii码中的通用可见字母字符( 0x1A 对应 SUB[替补]，非文本文件的字符 )。]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据割韭菜法]]></title>
    <url>%2F2020%2F06%2F25%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%89%B2%E9%9F%AD%E8%8F%9C%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在的大数据杀熟是一件常见的事，更有一些大佬们呕心沥血的算法加持下；我觉得只要数据足够多，那么它就能做到很多匪夷所思、神奇的事情。但是巧妇难为无米之炊，那些数据到底是哪里来的呢？ &emsp;&emsp;以前根据自己的分析，怀疑是输入法、浏览记录导致信息泄漏，进而看见那些广告推送。直到看半佛老师的：你的手机是如何监控你的，开拓了我不少眼界，例如唤醒监控、推送SDK同家公司等，也让我对其更深的理解。 一、半佛老师的视频笔记总结1.1 信息泄漏基本不会来源于录音，但是会识别关键词 信息泄漏基本不会来源于(手机)录音：效率低，利润低，误差率高，成本高 (某APP)持续录音，会对手机内存的占用；现象：发热，卡，且容易被杀掉进程和检测出来 录下来的音频存放点。存放本地存储，长时间占用太大；将其使用流量上传，但流量并非免费 将其录下来的音频转换成文字保存或直接上传，则会遇到下面问题：语音识别误差率大 语音识别误差率大，分辨不出是谁在讲话，而且语音不标准(即口音)。还有语义问题，不同场景，同一句湖就是不同意思 不做录音。但是真的有时候就是没有浏览只是日常讲话提及，随之会出现在广告推送。 通过特定的关键词唤醒监控。 常见的唤醒方案：小爱，siri。所以有些app要求录音权限 ，可用于唤醒监控 只做关键词，无论是直接上传还是识别度都是操作相对简单很多 Ps： 注意手机的App，对其录音的权限是否关闭 1.2 输入法 输入法，只要打字，就离不开输入法。 纯文本的语意分析，那可是相对成熟的技术。 另外所有的输入法都是越用月好用，越用越懂你。 那么，到底是怎么懂你的呢？当你在触摸方便之门的时候，方便也在触摸着你 Ps： 建议关闭输入法用户体验计划？最好禁用其联网 1.3 推送类sdk 现在各种手机推送大都是专门有公司做成sdk嵌入到各大app里面的，然后专门做推送。 做推送的，往往对于各类手机和应用的适配做得比较好；比App自己开发要好用很多。 所以很多app都是使用外采推送sdk的，不然市面上这么多的手机型号，自己还要一个一个去适配，还要去实验规则。 假如你手机上有30个app，它可能背后都归属于同一家或者是多家公司提供的推送sdk(推送类SDK核心威力所在) &emsp;&emsp;常见的信息泄漏，最基础的就是：App请求获取你的应用列表。它可以根据你装的App来分析你到底是什么用户；而且有没有同行App之类在里面，再根据结果推荐不同的推荐策略。 &emsp;&emsp;但是对于推送SDK公司而言，它甚至可以不需要获取你的应用列表，因为你装的App很多都加载了它的推送SDK。你的手机信息是可以被获取的，而且很显然会知道一台手机到底装了哪些app；用户常用那些app，甚至用户对于手机的应用轨迹和应用行为。 1.4 App的信息收集&emsp;&emsp;手机app的信息收集，例如上面的获取手机Applist。举例如下： Applist 有 x多多，该用户为价格敏感性 Applist 有 x哩x哩，可能是个年轻二次元用户 通过读取applist，该用户有多个同行App，就发大额优惠券拉拢用户；反之垄断则考虑割韭菜 读取地理位置信息，对应的推荐策略 Ps： 建议尽可能禁掉获取Applist的权限，只留一些基本App 1.5 浏览记录，搜索记录&emsp;&emsp;最表层的，你在pc和手机端app搜索记录。大家都在收集这些记录，而且很热衷，都是用来相互交易，明码标价；而且app是绑定手机号的，你的每次搜索记录都会转换成市面的数据包进行交易。 Ps： 无痕浏览只是不保存记录在本地上，网络上是有你的搜索记录的 1.6 数据糅合推送&emsp;&emsp;即使是你尽可能谨慎，少泄漏信息；但是有时候你就是能收到贴心的广告推送。这个推荐策略，并非来自你的信息泄漏，而是周边人信息的泄漏。只要你周边的信息足够多，就能够反推出对你的推荐策略。 &emsp;&emsp;例如你是小明，那么你的广告推送有部分决策来源于，小明朋友的相关数据、小明小红父母的相关数据。例如小红怀孕，搜索母婴用品；自然小明那边就可能推送母婴用品等的广告。 二、我的经历和看法2.1 看法&emsp;&emsp;尽可能上面看起来比较骇人听闻，把每个人的生活经历、决策、不确定性的未来都划出一块一块的数据，但是大家也不要太过担心。毕竟大数据就是大数据，会尽可能把数据抽象、封装，不会完全针对个人；不会说专门从大数据中，抽取具体个人所有的信息并呈现出来，成本太高，普通人是不会有多少问题，还是能平平凡凡渡过一生。 大数据的获取和处理还是有一定限制(阻力)的，不然现在贪污腐败都能够分析处理完的。 大数据的数据并非是一块完整区域，而是很多大的信息孤岛 大的 手机厂商、App，假如它有获取你信息的方法，它基本也不会贩卖给市场；毕竟这是自己一手的资源，不需要贪图点小钱，而是为后面市场(垄断)开拓做准备 信息孤岛，则对你的影响力就不是特别特别大；毕竟数据糅合多起来，对你的理解不是加法，是乘法 2.2 观察到的现象&emsp;&emsp;现在目前的情况，感觉输入法泄漏比较多。不过我也有些疑惑和观察一些现象： 跟人x信聊天，聊到一句话夹杂：”养猫”，没说过对应的话；一两分钟后，广告推送前两条是猫了！才逐渐推出来输入法有信息泄漏的问题(x信不会要这点小钱，数据应该是留给自己用) 有时候不解，广告推送老是推 switch 给我，我一开始以为是哪位亲朋好友的记录，想到上面养猫的输入法泄漏，以及敲C代码用到的 switch语句，一切就豁然开朗了 举个常见例子，你手机链接朋友手机开热点，搜索东西；后面朋友就会收到近似的广告推送嘛；这很正常，就锁定IP嘛 但是你在PC端，公司局域网，和自己家里私有网络，两台PC的广告推送竟然是一模一样的；那么也就是说，广告推送识别出来这两台电脑的用户都是我；要知道局域网，是只有一个真实IP的，里面都是虚拟IP，也就是说它能整出局域网虚拟IP里面的人到底是谁 在公司的不同电脑，查询广告推送，每个人都是有各自的特点；也就是反过来验证了，广告推送能越过 真实IP 查出 虚拟IP 的用户本人 如果是注意观察广告推送，要么不智能像傻子一样，一直推广固定几样；如果是智能的，那么推广给你的，大致相同； 也就是说背后的(智能)广告推送，基本可能是来源于同一、两家； 或者是数据被一个信息市场公开贩卖，但是可能性不大，因为你一搜索就会及时更新广告推送(所以广告大致相同，但不会完全一样) 我觉得应该是一两家，数量大于 1 则可能公司之间存在(韭菜)信息共享 &emsp;&emsp;到现在，我都不知道它怎么知道虚拟IP的用户是谁。很有可能是通过某些能过识别用户的进程，反过来知道用户；而且这个用户注册是要用手机等(映射出身份证号)，例如x信 2.3 经历：你见过的大数据处理够早的应用是什么时候呢？&emsp;&emsp;讲一个真实发生的故事。那你见过的大数据处理够早的应用是什么时候呢？我见过的大数据处理，是我高三的时候，应该是2015年吧？ &emsp;&emsp;那个时候，x信有流行小黄鸡，一个聊天的机器人，而且很多层次不齐的版本。有些版本则是上面会有一条广告推送，那时候我有个同学在玩(我没手机)，一条广告推送大黄鸡，也是聊天机器人，但号称更了解你(还能充VIP好像)，加了后是一个公众号。 &emsp;&emsp;小黄鸡回复消息很快，但是你懂得，就是弱智AI；但是那个大黄鸡不一样，你问它一句话，它保底等待30s，甚至好几分钟才能回答你的问题。你可以问它，问题如下： 你是谁。它能够回答出来你的名字！ xx人怎么样。它能回答出中间夹杂 xx的(qq空间活跃过的)经历的答案 xx是谁。它回复是上一次统考她的成绩排名 每次问它问题，它都会回复当前具体的询问它问题的在线人数，然后再提示要等多久(文字表达是：稍等几分钟，耐心等待) &emsp;&emsp;还有好多问题(忘了)，它竟然都能回答有模有样，比搜索引擎夸张多了。现在回头想想，其实你的信息早就在很早的时期已经被挖差不多了= = ；那时候应该是爬虫抓的数据？？？但是也至少有了大数据处理的雏形(或者是已经有进入消费领域的能力)？ &emsp;&emsp;那时候就玩了3-4天，那个大黄鸡公众号就被封了。再搜类似的也没有一样的效果的公众号，回去蹲那个小黄鸡的广告推送，也再没看到了；就这样成了回忆。 2.4 反推 苦中作乐，当你收到广告的时候，你甚至可以去尝试分析到底是哪个卖了你； 当你想了解一个人，甚至不需要查历史记录，还是有没有隐藏文件；打开他的电脑，找个有推送广告的网站简单瞄一眼，你就能获取到关于他、关于他周边人的一些大数据；然后反推来源、原因，就能掌握他一些动态，相当于你对数据又进行一遍加工处理(当然我只是提提，不建议大家这样搞；也不建议电脑给别人用) &emsp;&emsp;我还是比较喜欢半佛老师在视频讲的一句话，在结尾，用它来收尾吧：当一个产品本身不需要你做任何东西，甚至还能占点便宜的时候；只有一种可能，你自己就是商品本身。]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客都快成日记了?]]></title>
    <url>%2F2020%2F06%2F14%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%83%BD%E5%BF%AB%E6%88%90%E6%97%A5%E8%AE%B0%E4%BA%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近思考了一下自己博客的写法。每次写博客总是想着，写全写细，多写写自己对xx知识的看法、偏重点。 &emsp;&emsp;但是有时候写总有点小烂尾，或者回过头来感觉还是写缺了点啥；后面补完，又因为感觉修改完篇幅太大，要分成上和下。把旧博删了，然后又纠结上和下怎么分= = &emsp;&emsp;关键是就算分了上下，可能后面还是要修改，可能还要再删旧博，感觉头就很大。 &emsp;&emsp;然后又因为想要写(总结)得比较全，然后其中有个小地方、某一块可能还没做(实践)，整篇博客就被拖后腿，发不了。有一种跨步太大扯到蛋的感觉。 缺点总结： 旧博客感觉不太好拓展更新 博客重新更新时，有可能要删除旧博再更新 博客要写全时，被某个知识点拖累，写不全，发不出来 上传、浏览要翻墙才会快点 以上原因打击了我用这个工具写博客的动力(而且还加成 懒 的debuff) &emsp;&emsp;所以，以后的话，我打算有哪些知识点想写、想总结，我就直接写完上传；可能是不大的知识点，但是会在需要这个知识点的地方，相互附上文章链接，加深知识点应用。这样的话，每个知识点更新就很方便，拓展性也会好多了。 &emsp;&emsp;以后的日子，还是多多请教。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil制作自己的lib]]></title>
    <url>%2F2020%2F05%2F30%2FKeil%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84lib%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇介绍如何制作自己的LIB(Keil平台)。 为什么要做成lib库？ 不想将自己写的源代码公开，但是同时库文件又需要让别人能够正常调用，那封装成lib的格式就是一个方法。 当功能成熟时，防止他人改动功能、并减少工程编译时间。 如上所说，防止他人改动功能内容。 编译某些工程文件时非常耗时，像ST官方的库时，由于文件众多，编译一次可能得1两分钟。假如这个这时可以打包成库，节省不少的时间。但同时也不能用右键go to Definition ‘XXX’来直接找到源文件定义了。 项目基本不需要再改动，局部单文件需要频繁改动。即单个功能模块需要频繁改动，可以把该功能模块封装成静态库，导入功能。如果要改功能，只要更换库就行了。 LIB的制作方法一 首先将之前的工程项目文件进行一次复制粘贴备份，备份完成后，打开工程文件进入 Manage-&gt;project Items ,移除不需要的文件，仅保留需要打包为库文件的文件，如下图： 在Output选项中选择生成库的选项，如下图 在OBJ文件夹中找出tcp.lib的文件，从新命名你想要的名字即可，至此库封装完毕。 将生成的库文件拷贝回之前的项目中，添加到项目中，删除之前的源文件即可使用。 lib的调用，keil不能直接调用lib文件，需要将lib和.h文件 同时放到工程中去！！！ LIB的制作方法二 右键点击工程，假设为a，选Add Group，假设为b，再将想生成lib的文件加入b group，假设文件是cc.c，必须要有cc.h。 右键依次点击其他的group，按KEIL官网资料所说的，将Options for Group-&gt;Properties下的Include in Target Build前的对勾去掉，这样生成LIB时就不会被编译了 Project-&gt;Options for Target-&gt;Output下，选择Create Library，改输出文件名为cc，点OK 编译，这样就能在工程文件夹下的OBJ找到生成的cc.lib了 总结：不要另开工程！！！库文件的配置要求很高，例如芯片选型、等等一系列微配置。重新建工程容易出现link错误，建议直接复制原有工程进行删减。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式总线_基本概念&比较]]></title>
    <url>%2F2020%2F05%2F30%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。 一、部分总线概念(可跳着看)1.1 UART&emsp;&emsp;UART是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。在嵌入式设计中，UART用于主机与辅助设备通信，如汽车音响与外接AP之间的通信，与PC机通信包括与监控调试器和其它器件，如EEPROM通信。 1.1.1 接口&emsp;&emsp;在单片机中UART可以说是一种最基本的配置，很多与电脑进行通信的设备都采用到它，按计算机最常规的说法就是串行通信。 TX - 数据发送接口 RX - 数据接受接口 &emsp;&emsp;两个设备间将TX与RX相连，RX与TX相连即可正常工作。最常用到的就是我们电脑上的USB那就是个最典型的UART接口。 1.1.2 工作原理 发送接收 &emsp;&emsp;发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。 波特率产生 &emsp;&emsp;波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。 数据收发 &emsp;&emsp;发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。 中断控制 出现以下情况时，可使UART 产生中断： FIFO 溢出错误 线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内） 奇偶校验错误 帧错误（停止位不为1） 接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来） 发送 接收 &emsp;&emsp;由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。 1.2 I2C&emsp;&emsp;I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。 &emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。 1.2.1 接口 SCL - 串行时钟线 SDA - 串行数据线接口 &emsp;&emsp;SDA（串行数据线）和SCL（串行时钟线）都是双向I/O线，接口电路为开漏输出．需通过上拉电阻接电源VCC。 当总线空闲时．两根线都是高电平，连接总线的外同器件都是CMOS器件，输出级也是开漏电路．在总线上消耗的电流很小，因此，总线上扩展的器件数量主要由电容负载来决定，因为每个器件的总线接口都有一定的等效电容．而线路中电容会影响总线传输速度．当电容过大时，有可能造成传输错误．所以，其负载能力为400pF，因此可以估算出总线允许长度和所接器件数量。 &emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。 1.2.2 特点I2C总线特点可以概括如下： 在硬件上，I2C总线只需要一根数据线和一根时钟线两根线，总线接口已经集成在芯片内部，不需要特殊的接口电路，而且片上接口电路的滤波器可以滤去总线数据上的毛刺．因此I2C总线简化了硬件电路PCB布线，降低了系统成本，提高了系统可靠性。因为I2C芯片除了这两根线和少量中断线，与系统再没有连接的线，用户常用IC可以很容易形成标准化和模块化，便于重复利用。 I2C总线是一个真正的多主机总线，如果两个或多个主机同时初始化数据传输，可以通过冲突检测和仲裁防止数据破坏，每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机。数据传输和地址设定由软件设定，非常灵活。总线上的器件增加和删除不影响其他器件正常工作。 I2C总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也利于标准化和模块化，缩短开发时问。 连接到相同总线上的IC数量只受总线最大电容的限制，串行的8位双向数据传输位速率在标准模式下可达100Kbit/s，快速模式下可达400Kbit/s，高速模式下可达3．4Mbit/s。 总线具有极低的电流消耗．抗高噪声干扰，增加总线驱动器可以使总线电容扩大10倍，传输距离达到15m；兼容不同电压等级的器件，工作温度范围宽。 1.2.3 数据传输方式 字节格式 &emsp;&emsp;发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。 应答响应 &emsp;&emsp; 数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。在响应的时钟脉冲期间，接收器必须将SDA线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。通常被寻址的接收器在接收到的每个字节后，除了用CBUS 地址开头的数据，必须产生一个响应。当从机不能响应从机地址时（例如它正在执行一些实时函数不能接收或发送），从机必须使数据线保持高电平，主机然后产生一个停止条件终止传输或者产生重复起始条件开始新的传输。 &emsp;&emsp;如果从机接收器响应了从机地址，但是在传输了一段时间后不能接收更多数据字节，主机必须再一次终止传输。这个情况用从机在第一个字节后没有产生响应来表示。从机使数据线保持高电平，主机产生一个停止或重复起始条件。如果传输中有主机接收器，它必须通过在从机发出的最后一个字节时产生一个响应，向从机发送器通知数据结束。从机发送器必须释放数据线，允许主机产生一个停止或重复起始条件。 时钟同步 &emsp;&emsp;所有主机在SCL线上产生它们自己的时钟来传输I2C总线上的报文。数据只在时钟的高电平周期有效，因此需要一个确定的时钟进行逐位仲裁。 &emsp;&emsp;时钟同步通过线与连接I2C 接口到SCL 线来执行。这就是说SCL 线的高到低切换会使器件开始数它们的低电平周期，而且一旦器件的时钟变低电平，它会使SCL 线保持这种状态直到到达时钟的高电平。但是如果另一个时钟仍处于低电平周期，这个时钟的低到高切换不会改变SCL 线的状态。因此SCL 线被有最长低电平周期的器件保持低电平。此时低电平周期短的器件会进入高电平的等待状态。 &emsp;&emsp;当所有有关的器件数完了它们的低电平周期后，时钟线被释放并变成高电平。之后，器件时钟和SCL线的状态没有差别，而且所有器件会开始数它们的高电平周期。首先完成高电平周期的器件会再次将SCL线拉低。这样产生的同步SCL 时钟的低电平周期由低电平时钟周期最长的器件决定，而高电平周期由高电平时钟周期最短的器件决定。 1.3 SPI&emsp;&emsp;SPI接口的全称是”Serial Peripheral Interface”，意为串行外围接口,是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在EEPROM、FLASH、实时时钟、AD转换器，还有数字信号处理器和数字信号解码器之间。SPI接口是在CPU和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几Mbps。 1.3.1 接口 MOSI – 主器件数据输出，从器件数据输入 MISO – 主器件数据输入，从器件数据输出 SCLK –时钟信号，由主器件产生,最大为fPCLK/2，从模式频率最大为fCPU/2 NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select) &emsp;&emsp;在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。在多个从器件的系统中，每个从器件需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。 SPI接口在内部硬件实际上是两个简单的移位寄存器，传输的数据为8位，在主器件产生的从器件使能信号和移位脉冲下，按位传输，高位在前，低位在后。 1.3.2 优缺点 协议简单，相对数据速率高。 占用的Pin口较多 没有指定的流控制，没有应答机制确认是否接收到数据。 二、速率对比 UART： 无限制，常用9600、115200bps等保证双方通信速度相同。 IIC：通讯速率400Kbps CAN：一般为1Mbps SPI：通信速率为 fosc/4；其理论传输速度可达几Mb/s(其速率可以通过限制其SPI的时钟来实现限制速率) 缺点：抗干扰能力差。SPI采用的是单端非平衡的传输方式，即传输的数据位的电压电平是以公共地作为参考的。在这种传输方式中对于已进入信号中的干扰是无法消除和减弱的。而信号在传输过程中总会受到干扰，而且距离越长干扰越严重，以致于信号传输产生错误。在这种条件下，信号传输就变得毫无意义了。另外，由于单端非平衡传输方式以公共地作为参考点，地线作为信号回流线，因此也存在信号电流。当传输线两端的系统之间存在交流电位差时，这个电位差将直接窜到信号中，形成噪声干扰。所以，为了解决抗干扰问题，通常采用平衡传输(balanced transmission)方式，这里采用比较常见的RS-422。 应用：读写flash（存有字库，图片等等）芯片，与触摸屏控制器通信，还有就是读写sd卡了，你手机里的sd卡就是通过spi和处理器传数据的，目前高速都用SDIO了。 SDIO： 10M及已上 SDRAM：（非总线）16位的，100m频率就是1.6Gbit读写 PCI：（网卡）传输速率高最大数据传输率为132MB/s（工作在33MHz 频率之下），当数据宽度升级到64位，数据传输率可达264MB/s。这是其他总线难以比拟的。它大大缓解了数据I/O瓶颈，使高性能CPU的功能得以充分发挥，适应高速设备数据传输的需要。 PCI Express 2.0 ： 理论值 10Gbps，实际大于100MB USB2.0 ： 一般30~40MB Ethenet ：一般70~80MB 三、常见通讯总线疑问3.1 USART &amp; UART USART：通用同步和异步收发器 UART：通用异步收发器 &emsp;&emsp;当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 同步是阻塞模式，异步是非阻塞模式。 Ps：其中SPI 、IIC为同步通信，Uart为异步通信, Usart为同步&amp;异步通信。 3.2 单工、半双工、全双工 单工数据传输只支持数据在一个方向上传输； 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输；它实际上是一种切换方向的单工通信； 全双工数据通信允许数据同时在两个方向上传输；因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 Ps：I2C是半双工，SPI的全双工，Usart是全双工；串口232是全双工 ，串口485是半双工。 3.3 波特率 计算 发送速率 B = byte表示“字节” b = bit表示“比特” bps就是比特每秒 1 Kb=1024 bit，1 KB=1024 byte，1 byte=8 bit 举例，115200bps就是每秒传输115200比特(115200bit)，所以115200bps=每秒112.5kb=每秒14.0625kB。 举例计算速率 波特率115200 ＝ 115200 (位/秒) 根据常规串口发送协议,一个起始位,8个数据位,0个校验位,1个停止位,共计10位二进制数 如果没有校验位，就应该除以 10，得到的是每秒字节数： 波特率115200 ＝ 115200 (位/秒) ＝ 11520 (字节/秒) 再除以 1024，就是每秒 KB 数 波特率115200 ＝ 115200 (位/秒) ＝ 11.25 (KB/秒) 如果有一位奇偶校验位，就应该除以 11，得到的是每秒字节数。 最后：波特率115200 ＝ 115200 (位/秒) ＝ 10.27 (KB/秒) 3.4 RS485 &amp; Modbus RS485 ：是一个物理接口，简单的说是硬件。 MODBUS ：是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；所谓协议，也可以理解为上面有人说的“语言”吧，简单的说是软件。 RS485属于有线传输，所以就要硬件传输媒介，实际就是两根线就可以了，在这两根线上传输的实际是同一个信号，只是发送端把这个信号一分为二，不过在接收端会把它还原为原来的信号，这样做的好处还要得和RS232来比较；RS232也需要两根线，更多的时候还要加上地线，所以是三根线，地线咱不管它，其余的两根只有一根线传输的数据信号，而另一根传输的时钟，也就是信号原来什么样发送端就怎样发送出来，同样接收端也做同样的处理。所以485的接收端可以把信号在传输过程中引入的干扰就可以抵消掉，而232的接收端不能，所以485的抗干扰能力强可以传输信号上千米，而232只能传输十几米。 MODBUS只是通信协议的一种，就像汉语和英语一样，就是一种交流的语言，一种机器之间交流的语言。那么在交流之前肯定要有沟通的桥梁吧，那就是传输媒介485或232或其他电气规则，同一种协议可以用不同的传输媒介方式，如485或232；但是同一传输线路上不能同时存在两种协议。 &emsp;&emsp;一般情况下，两台设备通过MODBUS协议传输数据：最早是用RS232C作为硬件接口(也就是普通电脑上的串行通讯口(串口))；也有用RS422的；也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。 3.5 RS485 &amp; CAN&emsp;&emsp;为什么会有这个的比较？ 其实，RS485和CAN是很相似的： 均为差分信号，抗干扰强；(即，都为半双工) 均为双线连接 均可挂多个子设备 CAN总线特点： 国际标准的工业级现场总线，传输可靠，实时性高； 传输距离远（最远10Km），传输速率快（最高1MHz bps）； 单条总线最多可接110个节点，并可方便的扩充节点数； 多主结构，各节点的地位平等，方便区域组网，总线利用率高； 实时性高，非破坏总线仲裁技术，优先级高的节点无延时； 出错的CAN节点会自动关闭并切断和总线的联系，不影响总线的通讯； 报文为短帧结构并有硬件CRC校验，受干扰概率小，数据出错率极低； 自动检测报文发送成功与否，可硬件自动重发，传输可靠性很高； 硬件报文滤波功能，只接收必要信息，减轻cpu负担，简化软件编制； 通讯介质可用普通的双绞线，同轴电缆或光纤等； CAN总线系统结构简单，有极高的性价比。 RS485接口标准特点： RS-485的电气特性：逻辑”1”以两线间的电压差为+（2-6）V表示；逻辑”0”以两线间的电压差为-（2-6）V表示。接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL 电路连接。 RS-485的数据最高传输速率为10Mbps RS-485接口是采用平衡驱动器和差分接收器的组合，抗共模干能力增强，即抗噪声干扰性好。 RS-485接口的最大传输距离标准值为4000英尺，实际上可达 3000米，另外RS-232-C接口在总线上只允许连接1个收发器，即单站能力。而RS-485接口在总线上是允许连接多达128个收发器。即具有多站能力,这样用户可以利用单一的RS-485接口方便地建立起设备网络。但RS-485总线上任何时候只能有一发送器发送。 因RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等上述优点就使其成为首选的串行接口。 因为RS485接口组成的半双工网络，一般只需二根连线，所以RS485接口均采用屏蔽双绞线传输。 CAN总线与RS485的比较： 速度与距离：CAN与RS485以1Mbit/S的高速率传输的距离都不超过100M，可谓高速上的距离差不多。但是在低速时CAN以5Kbit/S时，距离可达10KM，而485再低的速率也只能到1219米左右（都无中继）。可见CAN在长距离的传输上拥有绝对的优势。 总线利用率：RS485是单主从结构，就是一个总线上只能有一台主机，通讯都由它发起的，它没有下命令，下面的节点不能发送，而且要发完即答，受到答复后，主机才向下一个节点询问，这样是为了防止多个节点向总线发送数据，而造成数据错乱。而CAN－bus是多主从结构，每个节点都有CAN控制器，多个节点发送时，以发送的ID号自动进行仲裁，这样就可以实现总线数据不错乱，而且一个节点发完，另一个节点可以探测到总线空闲，而马上发送，这样省去了主机的询问，提高了总线利用率，增强了快速性。所以在汽车等实性要求高的系统，都是用CAN总线，或者其他类似的总线。 错误检测机制：RS485只规定了物理层，而没有数据链路层，所以它对错误是无法识别的，除非一些短路等物理错误。这样容易造成一个节点破坏了，拼命向总线发数据（一直发1），这样造成整个总线瘫痪。所以RS485一旦坏一个节点，这个总线网络都挂。而CAN总线有CAN控制器，可以对总线任何错误进行检测，如果自身错误超过128个，就自动闭锁。保护总线。如果检测到其他节点错误或者自身错误，都会向总线发送错误帧，来提示其他节点，这个数据是错误的。大家小心。这样CAN总线一旦有一个节点CPU程序跑飞了，它的控制器自动闭锁。保护总线。所以在安全性要求高的网路，CAN是很强的。 价格与培训成本：CAN器件的价格大约是485的2倍这样，485的通讯从软件上是很方便的，只要懂串行通讯，就可以编程，而CAN需要底层工程师了解CAN复杂的层，编写上位机软件也要了解CAN的协议。可谓培训成本较高。 CAN总线通过CAN控制器接口芯片82C250的两个输出端CANH和CANL与物理总线相连，而CANH端的状态只能是高电平或悬浮状态，CANL端只能是低电平或悬浮状态。这就保证不会出现象在RS-485网络中，当系统有错误，出现多节点同时向总线发送数据时，导致总线呈现短路，从而损坏某些节点的现象。而且CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响，从而保证不会出现象在网络中，因个别节点出现问题，使得总线处于“死锁”状态。 CAN具有完善的通信协议，可由CAN控制器芯片及其接口芯片来实现，从而大大降低了系统的开发难度，缩短了开发周期，这些是只仅仅有电气协议的RS-485所无法比拟的。 特性 RS-485 CAN-bus 单点成本 低廉 稍高 系统成本 高 较低 总线利用率 低 高 网络特性 单主网络 多主网络 数据传输率 低 高 容错机制 无 可靠的错误处理和检错机制 通讯失败率 高 极低 节点错误的影响 导致整个网络的瘫痪 无任何影响 通讯距离 &lt;1.5km 可达10km（5kbps） 网络调试 困难 非常容易 开发难度 标准Modbus协议 标准CAN-bus协议 后期维护成本 高 低]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>嵌入式总线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微库 & 断言 & (Keil)代码优化]]></title>
    <url>%2F2020%2F05%2F30%2F%E5%BE%AE%E5%BA%93-%E6%96%AD%E8%A8%80-Keil-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。 一、MicroLIB&emsp;&emsp;大多人一般之所以使用 Use MicroLIB，是因为使能后能够直接调用printf()等函数。 1.1 Use MicroLIB &amp; printf&emsp;&emsp;printf()之类的库函数，是一些很骚的东西；使用printf、 fopen等库函数库函数调用，会让软件进入半主机模式。但是printf()库函数本身 不需要半主机模式(关掉,当然也能用printf)。 使用C标准库(stdio.h)中的函数，例如printf()之类的函数，会进入半主机模式，发生软件异常，会导致程序无法运行，以下是解决方法 : 方法 1.使用微库，因为使用微库的话 ,不会使用半主机模式。MDK 勾选 Use MicroLIB这样以后就可以使用 printf ，sprintf 函数了 方法 2.仍然使用标准库，在主程序添加下面代码 :12345678910111213//此段代码可以在正点原子例程Uart处找到#pragma import(__use_no_semihosting) //确保没有从 C 库链接使用半主机的函数_sys_exit(int x) //定义 _sys_exit() 以避免使用半主机模式&#123;x = x;&#125;struct __FILE // 标准库需要的支持函数&#123;int handle;&#125;;FILE __stdout; &emsp;&emsp;选上Use MicroLIB，例如你用printf()函数的时候，就会从串口1输出字符串，直接默认定向到串口1。 法1可实现串口1数据输出，但要定向到串口2，串口3，microLIB就不合用了； 法2虽然能够映射其他串口，但是如果同时涉及到多串口也是有问题。 &emsp;&emsp;总而言之，实际上 法1 &amp; 法2 都不推荐用于实际项目，顶多就用于快速搭建Demo 或 做测试用。 1.2 半主机 &amp; printf&emsp;&emsp;半主机模式是这么一种机制：它使得在ARM目标上跑的代码，如果主机电脑运行了调试器，那么该代码可以使用该主机电脑的输入输出设备。这点非常重要，因为开发初期，可能开发者根本不知道该ARM器件上有什么输入输出设备，而半主机机制使得你不用知道ARM器件的外设，利用主机电脑的外设就可以实现输入输出调试。 &emsp;&emsp;所以，如果不用主机电脑的外设就可以实现输入输出调试，而是要利用目标ARM器件的输入输出设备，首先要关掉半主机机制。然后再将输入输出重定向到ARM器件上，如printf和scanf，你需要重写fputc和fgetc函数(原有的输入输出，标准库函数的默认输出设备是显示器)。 1.3 MicroLIB的代码优化&emsp;&emsp;之所以在代码优化提及到MicroLIB，是因为微库本身就是一个精简库，进而有精简代码的效果，因此它可以用来压缩代码量。 MicroLIB 与 缺省C库 之间的主要差异是： microlib 不符合 ISO C 库标准。 不支持某些 ISO 特性，并且其他特性具有的功能也较少。 microlib 不符合 IEEE 754 二进制浮点算法标准。 microlib 进行了高度优化以使代码变得很小。 &emsp;&emsp;还有更多细节上的差异就不罗列出来了，直接网上一查一大把。但是，也正是这些零零碎碎的差异，可能就导致你做项目时疯狂翻车，所以一般不建议使用 MicroLIB (还有其他原因等等，尤其是项目刚开发时真不建议使用)。 以下是我对该库的总结： MicroLIB库 虽然能够进行代码大小优化。 但是实际测试的效果真的是杯水车薪，可以忽略不计；还不如自己去优化代码 or 提高优化等级。如果是其他方式都用了后，只能通过MicroLIB库优化代码，建议直接换硬件(真的是优化没多少的)。 由于microlib中进行了优化，以尽量减少代码大小，一些功能将会比ARM编译工具提供了标准C库函数更慢执行；例如，memcpy()。效率换空间，在项目大部分是 空间换效率，这当然是不建议的。 MicroLIB库 不支持浮点数运算。 ST除了F4xx系列，其他是没有FPU单元，都是采用软件模拟运算。 故在F4xx系列，选 Use MicroLIB，开了FPU就会死机(或其他情况) MicroLIB库 不支持半主机模式，进而支持printf()函数。但是实际用起来不太好用(只能固定映射串口1) Ps： 一般来讲，最好不要加。它和标准库有很多繁琐区别；如果是会迁移平台、项目代码时，用它对代码的维护性不好。 &emsp;&emsp;例如，当旧的项目工程要换新的硬件平台，迁移的时候发现Bug，但是检查应用层代码和底层驱动代码正常。建议查看一下旧项目工程是否采用了微库，而新项目工程没采用微库；然后查看旧代码是不是调用了printf等之类的C库函数。如果调用，先调用Use MicroLIB 或者 想办法关闭半主机模式(+重定向)，分析一下问题的来源。 二、assert&emsp;&emsp;assert() 不仅仅是个(字面意义上)报错函数！对于在开发过程中的程序员来说，加断言是个好习惯，可以帮助调试。 程序在假设条件下，能够正常良好的运作，那assert()其实就相当于一个 if 语句： 12345678if(假设成立)&#123; 程序正常运行；&#125;else&#123; 报错&amp;&amp;终止程序！（避免由程序运行引起更大的错误） &#125; &emsp;&emsp;可能有人说，断言的功能可以用if语句对异常情况进行处理来代替。以下列举 断言 的好处： 实现效果最后不会增加代码量 if是实的，真正的增加代码量，降低执行效率； 断言是虚的，在Debug的时候可以帮助调试，在Release的时候并不存在。 断言，实际上也是一种文档。断言设定了，函数的入口条件。增加了代码的可读性。 断言用于在开发阶段监测BUG，进行调试。 断言其存在的意义在于检测代码在开发过程中是否出现了问题。 而”if… “,更准确的说是错误处理，是在你的release版本中也实实在在应该有的，处理程序运行过程中产生的错误并进行处理，以提高程序的健壮性。 &emsp;&emsp;如果是看过Stm32的库函数实现方式的话，肯定会看到assert_param(expr) ((void)0)。这也是断言，不过是ST官方自己写的断言函数；而且有个宏定义用来是否失活该断言函数。当你打开一份Stm32的例程，进去库函数就会发现这些assert_param(expr) ((void)0)是失活的。 Ps：MicroLIB 库并不支持assert()函数，两者同时用产生报错。 &emsp;&emsp;microlib是一个比ARM标准C库小的独立库。为了节省大小，arm microlib c库不支持或实现几乎所有与操作系统交互的函数，例如abort（）、exit（）或assert（）。 &emsp;&emsp;如何在Release版本去掉assert？ 方法一：常见任何平台处理 &emsp;&emsp;在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下： 123#include &lt;stdio.h&gt;#define NDEBUG#include &lt;assert.h&gt; 方法二：在Keil平台上 &emsp;&emsp;在工程参数设置一栏，在“Preprocessor Symbols”的“Define”栏输入“NDEBUG”。等同于在代码中添加宏定义“#define NDEBUG”。实际为上面方法。 方法三：在Keil平台上 &emsp;&emsp;提高代码优化等级至2。在代码优化Level 0时，断言是占用空间可执行的；当代码优化提升为Level 2。这个时候就能够去掉assert()函数处理 三、Keil的代码优化等级3.1 代码优化等级&emsp;&emsp;C/C++的优化等级会对程序产生 不定性的影响，至于选择哪种优化等级必须从 现有的程序分析才行！ Level 0 (-O0)：关闭大部分优化，除了一些简单的转换，生成的代码具有最佳的调试视图。 Level 1 (-O1)：应用受限优化。比如：删除未使用的内联函数和静态函数，删除冗余代码和重新排序指令等。生成的代码经过合理优化，具有良好的调试视图。 Level 2 (-O2): 高度优化，目标代码到源代码的映射并不一定对应，因此，不利于调试。 Level 3 (-O3)：最大级别优化。级别3与时间优化相结合可能生成比级别2更多的代码。 &emsp;&emsp;经实际测试，Level 2升Level 3并不能节省很多的空间；相反，Level 3更高几率造成程序运行问题。从 Level 0升Level 2，相当于20%时间获取80%成果；从 Level 2升Level 3，相当于80%时间获取20%成果。如果对程序没有太过严苛的要求，建议程序整体在Level 2即可。 3.2 优化随之带来的Bug代码优化产生的Bug情况： 有更新的变量被优化而没有重新读取值，导致错误 优化后，代码段被跳过(不执行) Keil软件自带的软件Bug 小心一些驱动，尤其是涉及到文件管理，因为该底层驱动极有可能里面用了C库函数实现了某些功能；而C库函数有些一旦提高优化等级就会出问题(例如，SD卡文件系统)。 例子1 &emsp;&emsp;楼主编写一个stm32F10x系列的SPI库函数驱动。程序未优化前(LEVEL 0)，MISO能正常接收信息，优化后(Level 2)，MISO接收的信息都是错误的。 &emsp;&emsp;IAP平台之前也出现这个问题，现在貌似被修复了；但是Keil平台看起来还有。 例子2 &emsp;&emsp;近日在移植LPC1788的lwip驱动和SD卡（带文件系统）驱动时，遇到单独移植每个驱动都正常，移植到一起就一直出现HardFault_Handler错误。单步调试后发现编译器优化导致部分代码被跳过的情况。 &emsp;&emsp;仔细检查后发现官网例程中的LWIP驱动使用的是最高级（LEVEL3）优化等级，而SD卡驱动使用LEVEL0等级的优化。移植后统一修改为LEVEL3导致初始化SD卡f_open文件失败。 网上查找资料后，处理此类问题有下面几种方法： 单步调试，找到被优化的代码段，看是否有更新的变量被优化而没有重新读取值，导致错误。若有，加入valotile关键字。 通过options of file”…”将被优化文件的优化等级调成特定等级。 3.3 小总结 不建议小白直接上Level 2及Level 3搭建新工程！ 代码优化等级方面，我建议新建项目时，最好采用Level 0 搭建工程。等到项目比较完善的时候，再提升优化等级至Level 2，再根据优化等级出现的问题，进行逐步调试。 建议项目整体基本优化等级为Level 2，不需要升为Level 3。 有些底层驱动确实是不好提高代码优化等级(尤其涉及到文件系统)。 &emsp;&emsp;努力提高优化等级并不是厉害！在能力有限的情况下，费时费力；尤其是硬件Flash资源明显不够用时，虽然通过最高优化等级能应用，但是会对后面的升级更新、bug检查造成很大的麻烦： 仿真无法查看，优化等级太高 一旦降低优化等级，硬件编译报错，Flash存储不够 唯一的途径，就是把程序其他代码删除，留下所需的代码进行仿真调试局部(无法调试整体) 建议还是更换有更大Flash的MCU，或者自己优化一下程序代码 Ps： 最极端的代码压缩方法，即采用较高的Level2或Level3进行代码优化，然后再选用MicroLIB对代码量再进行压缩一下(最后一步再勾选微库，方便找出微库造成的问题)。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>Assert</tag>
        <tag>MicroLIB</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态机]]></title>
    <url>%2F2020%2F05%2F30%2F%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机 一、什么是状态机？&emsp;&emsp;可能有些编写嵌入式程序的人，听过别人吹他已经用状态机方法写好了代码。听起来逼格贼高，但是实际上，即使你没了解过状态机，但我们在编写嵌入式程序，尤其是驱动编写，都会有意无意以(类似)状态机思想来编写程序，只不过写得时候不知道这个叫状态机。 二、状态机&emsp;&emsp;状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型，一种思想。重复一下：状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。 2.1 状态机的四大概念 State ，状态 一个状态机至少要包含两个状态。例如bool类型，有 true 和 false 两个状态。 Event ，事件 事件就是执行某个操作的触发条件或者口令。不同状态对应产生各自事件。 Action ，动作 事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。 Transition ，变换 通过多种动作满足一定条件，开始切换状态 &emsp;&emsp;主要概念还是状态，后三者往往在代码实现的时候糅合在一起比较模糊。 2.2 举例应用&emsp;&emsp;状态机，是(快速)写(驱动)程序的好帮手。 街上的自动售货机中明显能看到状态机逻辑；我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。 初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。 状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种。 到达“已足额付款”状态，还要进行余额清零和弹出汽水操作。然后重新进入初始化状态 所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。 2.3 实际代码实现&emsp;&emsp;实际从C的代码层面，更容易看到状态机的影子。最经典的就是 switch 和 enum 的搭配了。 switch 罗列出状态机的所有可能状态。enum 产生对应的各种状态。代码如下： 1234567891011121314151617typedef enum&#123; DISCONNECT, CONNECT, RECONNECT,&#125;_enumGPRSState;void Func(_enumGPRSState GPRSState)&#123; switch(GPRSState) &#123; case DISCONNECT:break; //执行对应的事件、动作 case CONNECT:break; //执行对应的事件、动作 case RECONNECT:break; //执行对应的事件、动作 default:break;//特殊处理 &#125;&#125; 这样就是很常见、很普通的状态机写法，很适用于快速开发底层驱动。当然，这是一个很简单的例子。还有更复杂的状态机，甚至多状态机相互影响切换其他状态机的状态。状态机也只是一种思想而已。 &emsp;&emsp;可以去看FreeModbus的通讯库。它就是一个很经典的状态机写法，但是涉及到多状态机。它的状态机有：(轮询)事件，串口发送中断，串口接收中断，其中还有个定时器能够变换 串口接收中断 状态机。 2.4 FreeModbus库讲解(RTU模式为例) Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态 串口接收中断 在初始化状态下，打开定时器 等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将eMBPoll的 事件状态机 置为 初始化。 以上就是初始化完成，接下来就是数据收发的流程了 串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。 每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。 当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态 由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。 eMBPoll的 事件状态机 为Frame received接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功 核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 MB_EIO的错误。 经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为Execute function 执行数据函数(事件)。开始对数据进行处理。 这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。 如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 功能码|0x80 + 错误代码。 举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。 在处理完后会返回一个enum状态值。如果状态 不为MB_ENOERR，即内部使用的错误代码，根据内部使用的enum错误代码，switch生成 对外的错误代码 返回的CRC会在发送前先把CRC校验完成。 发送前，检查能不能数据接收，能接收则报硬件错误MB_EIO，因为协议规定只能单向收发 发送一个字节数据，然后开启发送中断，一直发送，直到完成 发送完成后，将 eMBPoll的 事件状态机 置为 发送完成 事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲 &emsp;&emsp;以上就是FreeModbus库实现Modbus RTU通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。写的很好，这份源码还是很推荐看的。]]></content>
      <categories>
        <category>计算机基础概念 &amp; 算法</category>
      </categories>
      <tags>
        <tag>计算机概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式IIC总线]]></title>
    <url>%2F2020%2F05%2F30%2F%E5%B5%8C%E5%85%A5%E5%BC%8FIIC%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。 一、IIC总线讲解&emsp;&emsp;IIC的硬件管脚为 VCC，GND，SDA，SCL。IIC的主要构成只有两个双向的信号线，一个是数据线SDA,一个是时钟线SCL。IIC总线有主从之分。 &emsp;&emsp;IIC总线实现的方式分为两种：硬件IIC &amp; 软件模拟IIC。硬件IIC有主从之分；当然，软件I2C也是标准的I2C协议，当然有分主从，但一般情况下，软件IIC为主机模式，即发送请求接收响应信息。为什么要写从机呢？mcu 对 mcu ？)。由于每种MCU的硬件IIC总线配置各不相同，且有些芯片的IIC有Bug(Stm32)，故接下来只讲 软件IIC。 由于实际应用上，IIC总线通讯速率本身就不高，因此，硬件IIC总线 &amp; 软件IIC总线本身速率方面就没多差大差距，不需要考虑IIC总线切换为软、硬件实现方式会给程序带来隐患。 无论是 硬件IIC 还是 软件IIC ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应IIC从器件的datasheet。IIC总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。 二、 (软件)IIC总线2.1 基本知识&emsp;&emsp;软件IIC，也能更好让我们了解IIC总线协议的实现方式。 &emsp;&emsp;I2C总线通过上拉电阻接正电源。即当总线空闲时，两根线均为高电平。如此，连在总线上的任一器件输出的低电平，都可以使得总线的信号变低，也就是说各器件的SDA和SCL都是线”与”关系。 数据位(1\0)有效性规定：I2C总线进行数据传送时，时钟信号为高电平期间，SDA线上的数据必须保持稳定；只有在SCL线的信号为低电平器件，SDA线的才可进行高低电平状态变化。 起始信号、终止信号、应答信号 起始信号：SCL线为高电平期间，SDA线由高电平向低电平跳变(下降沿)—-是一种电平跳变时序信号 终止信号：SCL线为高电平期间，SDA线由低电平向高电平跳变(上升沿)—-是一种电平跳变的时序信号 应答信号：在接收数据的IC(接收器)在接收到8bit数据后，向发送数据的IC(发送器)发出特定的低电平脉冲，表示已收到数据。即发送器在时钟脉冲9期间释放数据线，这样接收器就可以反馈一个应答信号。ACK(低电平)—-规定为有效应答位，NACK(高电平)，规定为非应答位，表示接收器接收该字节咩有成功。 2.2 软件模拟IIC驱动程序函数编写&emsp;&emsp;在IIC程序设计中，都是以8bit为基础进行数据的传输 IO管教初始化 发出起始信号 发出终止信号 发出应答ACK 功能要求：由于IIC为双向数据通信，当从机发送完数据，主机也需要发送应答信号来说我接收到你的信息了，此时从机才可变为接收状态，接收来自主机的数据。 发出应答NACK 功能要求：当IIC程序运行到主机读取从机数据完成，需要停止此次数据传输时，主机发送一个发出主无应答信号，从机接收到后就停止发送数据，并释放SDA线；之后主机才可发送终止信号，停止此次数据的传输。 发送一个字节数据 基本思路：SCL在为0时，可以进行SDA数据的配置，当SCL为1时，SDA数据一定要锁定。其次为数据的移位，将待发送数据与0x80进行与运算，获得最高位的数据，通过8次循环完成1byte的数据发送。 读取一个字节，并发送ACK或NACK(发送NACK基通知从机发送器结束数据发送，释放SDA线(SDA接口置1) 功能要求：发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号(故读取完需要发送 ACK 或 NACK ) 等待ACK应答 功能要求：当IIC主机进行获取数值时，主机需要等待从机的应答信号，以此来判断从机是否完成了数据的接收。从主机方看，为IIC等待ASK函数。 基本思路：通过 延时等待从机的ACK是否发送出来，如果发送出来，则函数返回0，主机可继续发送数据，如果返回1，则从机没有应答，此时需要停止IIC数据传输。防止出现错误数据。 2.3 从具体I2C器件中读写数据 主机写(发送)从机数据 主机读(接收)从机数据 Ps：IIC器件往往是 器件地址+0 为写数据 ，器件地址+1 为读数据 主机读从机的情况分为两种： 读操作之前，都是需要进行一次写操作(写入读地址)，表明你要读的是哪个地址的数据，然后在进行一次读操作(故有两个器件地址)；(这是一般情况) 直接进行读操作，截取所需数据段 &emsp;&emsp;因为有些IIC器件(从机)，例如24C02，当你需要读取它的数据，你要跟它说读取哪个地址数据，故先进行写操作；有些IIC器件，例如SD2403，它的时间日期地址是固定的（寄存器地址：00H-06H），因此读取该器件数据时，直接进行读操作，然后读出来7个数据，截取00H-06H的数据后，停止读取(这是特殊情况) DEVICEADDRESS(器件地址) &emsp;&emsp;器件地址的8位地址信息因器件而异； 三、软件IIC实例3.1 EEPROM_24C02通信基础——IIC协议&emsp;&emsp;24C02是一个可储存 256(8bit)字节数据的EEPROM，因此他的Word Address为8bit(单字节)；而他的器件地址如下： 据2.3.1图所示，主机对从机写操作如下： 12345678910111213141516void AT24CXX_WriteOneByte(u16 WriteAddr, u8 DataToWrite)&#123; IIC_Starts(); //发出起始信号 IIC_Send_Byte(0xA0); //写器件地址+写操作 IIC_Wait_Ack(); //IIC_Send_Byte(WriteAddr&gt;&gt;8); //发送高地址，适用于更高容量的EEPROM //IIC_Wait_Ack(); IIC_Send_Byte(WriteAddr%256); //发送低地址 IIC_Wait_Ack(); IIC_Send_Byte(DataToWrite); IIC_Wait_Ack(); IIC_Stop(); delay_ms(10); //等AT24C02写数据&#125; 据2.3.1图所示，主机对从机读操作如下： 12345678910111213141516171819u8 AT24CXX_ReadOneByte(u16 ReadAddr)&#123; u8 temp=0; IIC_Start(); IIC_Send_Byte(0XA0); //发送器件地址0XA0,写操作 IIC_Wait_Ack(); //IIC_Send_Byte(ReadAddr/256); //发送高地址，适用于更高容量的EEPROM //IIC_Wait_Ack(); IIC_Send_Byte(ReadAddr%256); //发送低地址 IIC_Wait_Ack(); IIC_Start(); IIC_Send_Byte(0XA1); //进入接收模式 IIC_Wait_Ack(); temp=IIC_Read_Byte(0); //读一个字节数据完成，并发出No_Ack(输入参数：0) IIC_Stop(); return temp;&#125; 3.2 24C02程序拓展——datasheet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//在AT24CXX里面的指定地址开始写入长度为Len的数据//该函数用于写入16bit或者32bit的数据.//WriteAddr :开始写入的地址 //DataToWrite:数据数组首地址//Len :要写入数据的长度2,4void AT24CXX_WriteLenByte(u16 WriteAddr,u32 DataToWrite,u8 Len)&#123; u8 t; for(t=0;t&lt;Len;t++) &#123; AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite&gt;&gt;(8*t))&amp;0xff); &#125; &#125;//在AT24CXX里面的指定地址开始读出长度为Len的数据//该函数用于读出16bit或者32bit的数据.//ReadAddr :开始读出的地址 //返回值 :数据//Len :要读出数据的长度2,4u32 AT24CXX_ReadLenByte(u16 ReadAddr,u8 Len)&#123; u8 t; u32 temp=0; for(t=0;t&lt;Len;t++) &#123; temp&lt;&lt;=8; temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t-1); &#125; return temp; &#125;//检查AT24CXX是否正常//这里用了24XX的最后一个地址(255)来存储标志字.//如果用其他24C系列,这个地址要修改//返回1:检测失败//返回0:检测成功u8 AT24CXX_Check(void)&#123; u8 temp; temp=AT24CXX_ReadOneByte(255);//避免每次开机都写AT24CXX if(temp==0X55)return 0; else//排除第一次初始化的情况 &#123; AT24CXX_WriteOneByte(255,0X55); temp=AT24CXX_ReadOneByte(255); if(temp==0X55)return 0; &#125; return 1; &#125;//在AT24CXX里面的指定地址开始读出指定个数的数据//ReadAddr :开始读出的地址 对24c02为0~255//pBuffer :数据数组首地址//NumToRead:要读出数据的个数void AT24CXX_Read(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)&#123; while(NumToRead) &#123; *pBuffer++=AT24CXX_ReadOneByte(ReadAddr++); NumToRead--; &#125;&#125; //在AT24CXX里面的指定地址开始写入指定个数的数据//WriteAddr :开始写入的地址 对24c02为0~255//pBuffer :数据数组首地址//NumToWrite:要写入数据的个数void AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)&#123; while(NumToWrite--) &#123; AT24CXX_WriteOneByte(WriteAddr,*pBuffer); WriteAddr++; pBuffer++; &#125;&#125; 3.3 实时时钟_SD2403——IIC总线&emsp;&emsp;SD2403是一个实时时钟，他的Word Address为8bit(单字节)；而他的器件地址如下： 据2.3图所示，主机对从机写操作如下： 123456789101112static uint8_t SD2403_WriteOneByte(uint8_t addr,uint8_t data)&#123; if(!SD2403_start())return(false); SD2403_SendByte(0x64); SD2403_WaitAck(); SD2403_SendByte(addr); SD2403_WaitAck(); SD2403_SendByte(data); SD2403_WaitAck(); SD2403_stop(); return(true);&#125; 据2.3图所示，主机对从机读操作如下： 12345678910111213141516171819202122uint8_t SD2403_ReakOneByte(uint8_t addr)&#123; uint8_t res=0; //先写入要读取的寄存器 if(!SD2403_start()) return false; SD2403_SendByte(0x64); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return false; &#125; SD2403_SendByte(addr); SD2403_WaitAck(); //再读取的寄存器数据 SD2403_start(); SD2403_SendByte(0x65); SD2403_WaitAck(); res=SD2403_ReceiveByte(0); SD2403_stop(); return res;&#125; 3.4 SD2403程序拓展——datasheet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869uint8_t SD2403_ReadTimeDate(_strTimeDate *pstrTimeDate)&#123; uint8_t i,dat[7]; if(!SD2403_start()) return false; SD2403_SendByte(0x65); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return(false); &#125; for(i=0; i&lt;7; i++) &#123; dat[i]=SD2403_ReceiveByte(); if(i==2) dat[2]=BCDTODEC(dat[2]&amp;0x7F);//24小时舍弃最高位(区分12/24小时制) else dat[i]=BCDTODEC(dat[i]); *(&amp;pstrTimeDate-&gt;ucSec +i)=dat[i]; if (i!=6) //最后一个数据不应答 &#123; SD2403_ACK();////ACK 低 &#125; &#125; SD2403_No_ACK();//ACK 高结束 SD2403_stop(); return(true);&#125;uint8_t SD2403_WriteTimeDate(uint8_t *pstrTimeDate)&#123; uint8_t *set_time,i; set_time=pstrTimeDate; SD2403_WriteTimeOn(); if(!SD2403_start())return(false); SD2403_SendByte(0x64); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return(false); &#125; SD2403_SendByte(0x00);//设置写起始地址 SD2403_WaitAck(); for(i=0; i&lt;7; i++) &#123; if(i==2) SD2403_SendByte(0x80|DECTOBCD(*set_time));//最高位区分12/24小时制(1为24小时制) else SD2403_SendByte(DECTOBCD(*set_time)); SD2403_WaitAck(); set_time++; &#125; SD2403_stop(); SD2403_WriteTimeOff(); return(true);&#125;/******写SD2403允许程序******/static uint8_t SD2403_WriteTimeOn(void)&#123; if(!SD2403_WriteOneByte(0x10,0x80))return(false); SD2403_WriteOneByte(0x0f,0x84); return(true);&#125;/******写SD2403禁止程序******/static uint8_t SD2403_WriteTimeOff(void)&#123; if(!SD2403_WriteOneByte(0x0f,0))return(false); SD2403_WriteOneByte(0x10,0); return(true);&#125; 四、拓展——软件IIC从机&emsp;&emsp;要实现IIC从机功能，最核心的部分就是如何精确的抓住IIC_SCL，也就是IIC主机发出来的时钟信号。只有抓住精确的时钟SCL，才能正确的读取到SDA的数据，才能真正模拟出IIC时序。 &emsp;&emsp;但是要抓住SCL信号可不容易，IIC最高速度有400K，最小有效脉宽达到1.4us(数字0/1)，最小脉冲是0.8us(应答和STOP信号产生的尖刺)，采用中断来识别SCL是不可能的做到的，因为即使在最高主频72MHZ情况下，STM32最小指令周期是1/72(us)，从SCL中断发生到STM32进入中断响应，至少要要40个指令周期，也就是40/72(us)，加上堆栈操作及变量，很可能已经错过了SCL信号。 因此根据IIC主机的速度，从机实现方法分为两种： 采用中断方式识别SCL(适用于总线速度较慢) 采用查询方式识别SCL(适用于总线速度较快) &emsp;&emsp;反过来言之，当你做成一个(从机)模块，实现软件模拟IIC，实际上还会因为IIC主机的因素来决定你这个模块的实际使用效果。如果是做模块化，还是推荐使用硬件IIC的方式实现。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>IIC</tag>
        <tag>嵌入式总线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式SPI总线]]></title>
    <url>%2F2020%2F05%2F30%2F%E5%B5%8C%E5%85%A5%E5%BC%8FSPI%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。 一、SPI总线讲解&emsp;&emsp;SPI的主要构成有三根线，一个是数据输出线MOSI,一个是数据输入线MISO，一个是时钟线SCLK。 &emsp;&emsp;SPI总线实现的方式分为两种：硬件IIC &amp; 软件模拟SPI。硬件SPI有主从之分；当然，软件SPI也是标准的SPI协议，当然有分主从，但一般情况下，(MCU)软件SPI为主机模式，即发送请求接收从机的响应信息。 &emsp;&emsp;可能大家不知道为什么我这MCU就是SPI主机，凭啥？你可以反过来想一下，MCU通讯的其他器件实质上都是从机，MCU要你的数据才会去找你；如果你MCU也是从机模式，从机与从机怎么通信？由于每种MCU的硬件SPI总线配置各不相同，故接下来主要讲 软件SPI。 SPI通信是串行同步全双工(同时收发) IIC通信是串行同步半双工(单收或单发) 无论是 硬件SPI 还是 软件SPI ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应SPI从器件的datasheet。SPI总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。 Ps：硬件SPI总线 &amp; 软件SPI总线 速率方面是有点差距的。具体没有实测，但是既然是用了软件SPI总线，就不要纠结速度问题了。但是硬件SPI总线的速度也不是无上限的，而且还要根据主、从机的配置。 &emsp;&emsp;以W5500为例，该芯片的SPI总线速率最高达到80Mhz。如果主控采用stm32f103,主频为72Mhz，SPI时钟最大为18Mhz。因此stm32f103无法发挥W5500完全的性能。 &emsp;&emsp;而如果使用STM40x处理器，SPI时钟使用42Mhz，使用DMA方式，可以达到回环测试17Mbps的速率（收+发），单独发送可以达到13Mbps的速率。 &emsp;&emsp;也就是说，SPI的速率本身就受器件限制。如果从机SPI时钟较低，主机被限制；主机时钟较低，从机性能被限制。编写硬件SPI驱动的时候，要多注意 主控芯片、从机器件 的datasheet。 二、(主机)软件SPI总线&emsp;&emsp;硬件上为4根线： MISO ：主设备数据输入，从设备数据输出。 MOSI ：主设备数据输出，从设备数据输入。 SCLK ：时钟信号，由主设备产生。 CS ：从设备片选信号，由主设备控制。 Ps：外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。 &emsp;&emsp;由上图的(硬件)SPI通信协议可知，时钟信号的相位和极性，决定了获取数据的方式；2*2=4，于是有四种模式； CPOL决定时钟空闲状态(1为空闲高电平，0为空闲低电平) CPHA决定获取数据的时钟相位(1为延迟一个相位，第二次SCLK突变为空闲状态获取数据；0为直接相位，SCLK空闲状态突变时，直接获取数据) &emsp;&emsp;以上就是软件SPI的要点；实现具体的软件SPI，需要对器件的datasheet进行查阅，看是哪种模式。 模式 CPOL CPHA MODE0 0 0 MODE1 0 1 MODE2 1 0 MODE3 1 1 下面简单列一个 CPOL=1，CPHA=1的SPI写操作 1234567891011121314151617181920212223/************************************************** 函数：SOFT_SPI_RW() 描述: 根据SPI协议，写一字节数据到从机，同时从从机 读出一字节**************************************************/ u8 SOFT_SPI_RW(u8 byte) &#123; u8 i,Temp=0; for(i=0;i&lt;8;i++) // 循环8次 &#123; SPI1_SCK = 0 //拉低时钟 if(byte&amp;0x80) SPI1_MOSI = 1;//若最到位为高，则输出高 else SPI1_MOSI = 0;//若最到位为低，则输出低 byte &lt;&lt;= 1; //低一位移位到最高位 SPI1_SCK = 1; //拉高时钟 Temp &lt;&lt;= 1; //数据左移 if(SPI1_MISO) Temp++; //若从从机接收到高电平，数据自加一 SPI1_SCK = 0; //拉低时钟 &#125; return (Temp); //返回数据 &#125; 2.1 FRAM_FM25L256为例——软件SPI&emsp;&emsp;FM25L256支持SPI模式的0和3，下面为CPOL=1，CPHA=1。基本的字节读写操作如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************** * 函数名 : FRAM_Write8bits* 功 能 : 向存储器中写入一个字节**************************************************/ static void FRAM_Write8bits(uint8_t u8Data)&#123; uint8_t i; for(i = 0; i &lt; 8; i++) &#123; FRAM_SCLK_L; if(u8Data &amp; 0x80) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u8Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Read8bits* 功 能 : 从存储器中读出一个字节的数据**************************************************/ static uint8_t FRAM_Read8bits(void)&#123; uint8_t i; uint8_t u8Data=0; for(i = 0; i &lt; 8; i++) &#123; FRAM_SCLK_L; u8Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; if(FRAM_SDO_READ) u8Data |= 0x01; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L; return u8Data;&#125; 2.2 FRAM_FM25L256程序扩展——datasheet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/************************************************** * 函数名 : FRAM_Write16bits* 功 能 : 发送16位数据**************************************************/ static void FRAM_Write16bits(uint16_t u16Data)&#123; uint32_t i; for(i = 0; i &lt; 16; i++) &#123; FRAM_SCLK_L; if(u16Data &amp; 0x8000) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u16Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Write32bits* 返 回 : 写入的32位数据**************************************************/ static void FRAM_Write32bits(uint32_t u32Data)&#123; uint32_t i; for(i = 0; i &lt; 32; i++) &#123; FRAM_SCLK_L; if(u32Data &amp; 0x80000000) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u32Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Read4Bytes* 功 能 : 读取指定地址的4字节数据* 入 参 : address : 读取数据的首地址* 返 回 : uint32_t : 读出的32位数据**************************************************/ uint32_t FRAM_Read4Bytes(uint32_t address)&#123; uint32_t i = 0; uint32_t temp = 0; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_READ); FRAM_Write16bits((uint16_t)(address)); for(i = 0; i &lt; 4; i++) &#123; temp = temp &lt;&lt; 8; temp |= FRAM_Read8bits(); &#125; FRAM_SCLK_L; FRAM_CS_H; return temp;&#125;/************************************************** * 函数名 : FRAM_Write4Bytes* 功 能 : 写入指定地址的4字节数据* 入 参 : address : 写入数据的首地址* FramData : 写入的32位数据**************************************************/ void FRAM_Write4Bytes(uint32_t address, uint32_t FramData)&#123; uint8_t u8Temp = 0; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_WREN); FRAM_SCLK_L; FRAM_CS_H; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_WRITE); FRAM_Write16bits((uint16_t)(address)); FRAM_Write32bits(FramData); FRAM_SCLK_L; FRAM_CS_H; while(1) &#123; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_RDSR); //读取状态寄存器 u8Temp = FRAM_Read8bits(); FRAM_SCLK_L; FRAM_CS_H; //该位表示写入启用状态(为0时，WPEN和 /WP 寄存器标志位不起作用) //防止软件误改动铁电芯片寄存器配置 if(!(u8Temp &amp; 0x02)) &#123; break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>嵌入式总线</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式存储器]]></title>
    <url>%2F2020%2F05%2F30%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备的存储器科普。 一、存储器科普&emsp;&emsp;RAM、SRAM、SDRAM、ROM、EPROM、EEPROM、Flash存储器可以分为很多种类;其中根据掉电数据是否丢失可以分为RAM（随机存取存储器）和ROM（只读存储器），其中RAM的访问速度比较快，但掉电后数据会丢失，而ROM掉电后数据不会丢失。 1.1 常见存储器&emsp;&emsp;在嵌入式开发过程中，往往会涉及到存储器(掉电存储等功能)；其中的 Flash，EEPROM，SRAM耳熟能详。 Flash，适用于速度要求高，容量要求大，掉电时要求数据不丢失的场合 EEPROM，适用于速度不高，容量不大，掉电时要求数据不丢失的场合 SRAM，一般就相当于计算机的内存，断电不保存，读写速度比flash, eeprom快N倍 &emsp;&emsp;在单片机中，往往RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据。 FLASH:单片机运行的程序存储的地方 SRAM：存储单片机运行过程中产生的了临时数据 EEPROM：视用户的需要而定，一般用来存储系统的一些参数，这些参数可能需要修改，也可能不会修改。 1.2 EEPPROM 和 Flash 混淆来由&emsp;&emsp;EEPROM的全称是“电可擦除可编程只读存储器”，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。 狭义的EEPROM：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。 Flash：属于广义的EEPROM，因为它也是电擦除的ROM。但是为了区别于一般的按字节为单位的擦写的EEPROM，我们都叫它Flash。 &emsp;&emsp;FLASH按扇区操作，EEPROM则按字节操作；二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。当然用FLASH做数据存储器也行，但操作比EEPROM麻烦的多；所以更“人性化”(成本)的MCU设计会集成FLASH和EEPROM两种非易失性存储器，而廉价型设计往往只有 FLASH，早期可电擦写型MCU则都是EEPRoM结构，现在已基本上停产了。 &emsp;&emsp;EEPROM：电可擦除可编程只读存储器，Flash的操作特性完全符合EEPROM的定义，属EEPROM无疑，首款Flash推出时其数据手册上也清楚的标明是EEPROM，现在的多数Flash手册上也是这么标明的，二者的关系是“白马”和“马”。至于为什么业界要区分二者，主要的原因是 Flash EEPROM的操作方法和传统EEPROM截然不同，次要的原因是为了语言的简练，非正式文件和口语中Flash EEPROM就简称为Flash，这里要强调的是白马的“白”属性而非其“马”属性以区别Flash和传统EEPROM。 &emsp;&emsp;Flash的特点是结构简单，同样工艺和同样晶元面积下可以得到更高容量且大数据量下的操作速度更快，但Flash缺点是操作过程麻烦，特别是在小数据量反复重写时，所以在MCU中的Flash结构适于不需频繁改写的程序存储器。 &emsp;&emsp;很多应用中，需要频繁的改写某些小量数据且需掉电非易失，传统结构的EEPROM在此非常适合。所以很多MCU内部设计了两种EEPROM结构，FLASH的和传统的以期获得成本和功能的均衡，这极大的方便了使用者。随着ISP、IAP的流行，特别是在程序存储地址空间和数据存储地址空间重叠的MCU系中，现在越来越多的MCU生产商用支持IAP的程序存储器来模拟EEPROM对应的数据存储器，这是低成本下实现非易失数据存储器的一种变通方法。为在商业宣传上取得和双EEPROM工艺的“等效”性，不少采用Flash程序存储器“模拟”（注意，技术概念上并非真正的模拟）EEPROM数据存储器的厂家纷纷宣称其产品是带EEPROM的，严格说，这是非常不严谨的，但商人有商人的目的和方法，用Flash“模拟”EEPROM可以获取更大商业利益，所以在事实上，技术概念混淆的始作俑者正是他们。 1.3 Flash的粗分&emsp;&emsp;目前Flash主要有两种，NOR Flash和NAND Flash。 NOR Flash：NOR Flash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本。 NAND Flash：NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。 Ps ：用户不能直接运行NAND Flash上的代码，因此很多使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码 &emsp;&emsp;一般小容量的用NOR Flash，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用NAND FLASH，最常见的NAND FLASH应用是嵌入式系统采用的DOC（Disk On Chip）和我们通常用的“闪盘”，可以在线擦除。目前市面上的FLASH 主要来自Intel，AMD，Fujitsu和Toshiba，而生产NAND Flash的主要厂家有Samsung和Toshib 二、Flash的前世今生2.1 Flash起源&emsp;&emsp;Nand Flash 和 Nor Flash是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出NOR Flash 技术，彻底改变了原先由EPROM（Electrically Programmable Read-Only-Memory电可编程序只读存储器）和EEPROM（电可擦只读存储器Electrically Erasable Programmable Read - Only Memory）一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。NOR Flash 的特点是芯片内执行（XIP ，eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统RAM。 注：片内执行不是说程序在存储器内执行，CPU的基本功能就是取指、译码和执行。Nor Flash能在芯片内执行，就是指CPU的取指模块能够直接从NorFlash中把指令取出来，供后面的译码和执行模块使用。 2.2 Flash的差异&emsp;&emsp;由于Nor Flash的接口与RAM完全相同，可以随机访问任意地址的数据。因此，Nor Flash进行读操作的效率非常高，但是擦除和写操作的效率很低，另外，Nor Flash的容量一般比较小。 &emsp;&emsp;而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得Nor Flash适合于运行程序，而NAND Flash更适合于存储数据。 &emsp;&emsp;容量相同的情况下，NAND Flash的体积更小。市场上Nor Flash的容量通常为1MB4MB(也有32MB的Nor Flash)，NAND Flash的容量为8MB512MB。对于空间有严格要求的系统，NAND Flash可以节省更多空间。容量的差别也使得Nor Flash多用于存储程序，NAND Flash多用于存储数据。 &emsp;&emsp;对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于Flash固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误（这种概率很低），而NAND Flash出现的概率远大于Nor Flash，当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可：如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率史高，推荐使用EDC/ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。 &emsp;&emsp;NAND Flash每块的可擦除次数通常在100000次左右，是Nor Flash的10倍。另外，因为NAND Flash的块大小通常是Nor Flash的1/8，单块的擦除需求更少，所以NAND Flash的寿命远远超过Nor Flash。 - Nor NAND XIP(代码可以直接运行) Yes No 性能(擦除) 块大，非常慢(5s) 块小，快(3ms) 性能(写) 慢 快 性能(读) 快 快 可靠性 较高，位反转的比例小于NAND Flash的10% 比较低，位反转比较常见，必须有校验措施。且比如TNR必须有坏块管理措施 可擦除次数 10000 ~ 100000 100000 ~ 1000000 生命周期 低于NAND Flash的10% 是Nor Flash的10倍以上 接口 与RAM接口相同 I/O接口 易用性 容易 复杂 主要用途 常用于保存代码和关键数 用于保存数据 价格 高 低 三、 Nand Flash&emsp;&emsp;由于Nand Flash的可靠性(位反转、坏块)，在比较低端的嵌入式设备并不采用Nand Flash，其容量大、擦写次数多在低端嵌入式设备中体现不出优势。Nand Flash会被采用于 嵌入式Linux设备，常见于使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码。在linux上很多现成、高级的驱动，因此这里就不多讲Nand Flash。 &emsp;&emsp;我们写Nand Flash驱动，是写Nand Flash 控制器的驱动，而不是Nand Flash 芯片的驱动，因为独立的Nand Flash芯片，一般来说，是很少直接拿来用的，多数都是硬件上有对应的硬件的Nand Flash的控制器，去操作和控制Nand Flash，包括提供时钟信号，提供硬件ECC校验等等功能，我们所写的驱动软件，是去操作Nand Flash的控制器，然后由控制器去操作Nand Flash芯片，实现我们所要的功能。 四、Nor Flash&emsp;&emsp;Nand Flash需要高级(算法处理)驱动，对低端嵌入式设备是一种考验。由于低端嵌入式设备往往对数据量要求不大，且对可靠性要求较高，往往采用Nor Flash。常见的用法是用于存储设备的历史记录，常见芯片有W25Qx系列的Nor Flash。 4.1 Flash的擦除&emsp;&emsp;像EEPROM等其他储存芯片是没有擦除这一说的。例如，iic接口的AT24Cx芯片，想要写入的数据直接覆盖在对应地址的数据上。 &emsp;&emsp;Nor Flash的物理特性是，写入之前需要先进行擦除。擦除从0变1，写入从1变0。擦除后数据为全0xFF，此时写入操作，实际上是将数据从1改成0。 &emsp;&emsp;一般先擦后写(常见于W25Qx驱动)，但实际上擦除后每个位置是可以写入多次的，只要每次写入都是让某些bit从1变0即可。 &emsp;&emsp;例如，在擦除后数据为0xFF，此时写入0x0F，可读出0x0F，再写入0x01，可读出0x01，再写入0x00，可读出0x00。而对于0x00，就无法再改写成任何值了，因为此时每个bit都是0，想要改写就必须先擦除，让其恢复到0xFF，再进行写入改成目标值。 4.2 “块，扇，页”的区别&emsp;&emsp;从上面的擦除概念，引申出(硬件)磁盘的最小擦除单位(Sector)。这里的单位概念有：块(Block)，扇(Sector)，页。 从底层驱动层面上看，Sector是最小存储单位(而且从驱动层面看并没有block的概念) 从软件(OS、文件系统)层面上看，Block才是文件存取的最小单位 &emsp;&emsp;OS、文件系统不是一个扇区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，Block才是文件存取的最小单位)。 Block由一个或多个Sector组成； Block是软件(OS、文件系统)中最小的操作单位 Sector是 底层驱动的最小操作单位(擦写) Block值一般与sector值是不相等的 &emsp;&emsp;因此，在其他地方看到块为最小单位、扇为最小单位时，就可以知道他是以什么层面来看待存储的。 Block是文件系统上的概念，一般文件系统block大小为4K(可以灵活设置块的大小) Sector是磁介质硬盘最小单元，一般为512字节(现在有4K的了) 至于页，是为了驱动方便擦写、检测扇内部的写入情况，提出来的一个概念；实际上并没有多大关系。如果进行擦除，还是会以Sector做为最小单位进行擦除操作 4.3 坏块 &amp; 写平衡&emsp;&emsp;这里先讲 坏块 这个概念。由于刚接触Flash底层的人，然后又经常听谁谁谁的移动硬盘坏块很多，或者是建议买硬盘后先做个坏块检测之类的事情。 真正意义的 “坏块” &emsp;&emsp;闪存内的坏块处理，是指生产出的闪存并不是完美的，总会有某些比特或者某些区域不可使用，这时候就要对闪存进行坏块处理。 &emsp;&emsp;一开始生产的时候，发现到这个问题，想处理这些坏块。但是呢，由于处理起来成本太高(即，良品率太低)，索性就让他坏块，出厂前做下坏块处理，检测一下坏块数量不多就出厂了。 &emsp;&emsp;Nand Flash是存在挺多坏块的。我们那些移动硬盘，那么大容量，当然是采用Nand Flash做成的。至于遇到所谓的黑心商家，就是把坏块率高的(或者寿命较短，因为用过的)移动硬盘(Nand Flash)卖给你。 &emsp;&emsp;Nor Flash没有坏块(你可以认为)。实际上 Nor Flash 是存在坏块的，只不过是在内对坏块进行了处理。 另类的 “坏块” &emsp;&emsp;另类的坏块，即寿命到了产生的不可写区域。一般人会混淆，认为不能用就是坏块(其实也算)。寿命到了不一定就不能用，只不过是容易产生”坏块”。尤其是嵌入式设备的Flash，由于对数据量要求不高，且对稳定性有高要求，往往采用的是Nor Flash做数据存储。 &emsp;&emsp;但是Nor Flash的擦写寿命相对较短，寿命将至闪存可能会工作异常(产生”坏块”)。写平衡(又名 磨损平衡、负载平衡)便应运而生。 &emsp;&emsp;由于Nor Flash的Sector(block)，都是有一定寿命限制的，所以如果你每次都往同一个Sector(block)擦除然后写入数据，稍微长时间，那么那个Sector(block)就很容易被用坏了。所以我们要去管理一下，将这么多次的对同一个Sector(block)的操作，平均分布到其他一些Sector(block)上面，使得在Sector(block)的使用上，相对较平均，这样相对来说，可以更能充分利用Nor Flash。 &emsp;&emsp;只进行一次大规模的擦除，后续的操作只需要进行写和读；写过的区域不再重写，读取的数据根据自己的需求算法，查出在Nor Flash的位置地址，读取想要的数据。当整个Nor Flash接近写满时，重新大规模擦除前，需要注意先擦除小部分区域，把所需的数据先读取出来，再重写入新擦除区域保存。 写平衡，将空闲的Sector(Block)运用起来，进而将Nor Flash的寿命变相翻倍。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Flash</tag>
        <tag>ROM</tag>
        <tag>SRAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP通讯_宏观]]></title>
    <url>%2F2020%2F05%2F30%2FTCP%E9%80%9A%E8%AE%AF-%E5%AE%8F%E8%A7%82%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍宏观层面的TCP/IP协议 一、TCP/IP 协议的层次结构(宏观)&emsp;&emsp;TCP/IP参考模型分为四个层次：应用层、传输层、网络(互连)层和主机到网络层(数据链路层) 1.1 应用层&emsp;&emsp;应用层面向不同的网络应用引入了不同的应用层协议。 传输层采用TCP协议的有： HTTP：超文本传输协议（Hyper Text Transfer Protocol） HTTPS:超文本传输安全协议（Hyper Text Transfer Protocol Secure） FTP：文件传输协议（File Transfer Protocol）它定义了本地登录用户与远程服务器之间的交互过程。 SFTP：文件加密传输协议（Secure File Transfer Protocol） TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. 传输层采用UDP协议的有：（一次性传输的数据需求很少） TFTP：简单文件传输协议（Trivial File Transfer Protocol）FTP的简化版本 SNMP：简单网络管理协议（Simple Network Management Protocol）该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等. NTP：网络时间协议（Network Time Protocol） 传输层同时采用TCP和UDP协议的有： DNS(域名系统)：该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. Ps：HTTP是面向网页（文本信息）的，而FTP是面向文件的 1.2 传输层TCP：传输控制协议（transmission control protocol）UDP：用户数据报协议（user datagram protocol） TCP与UDP的区别： 基于连接与无连接; 对系统资源的要求（TCP较多，UDP少）; UDP程序结构较简单; 流模式与数据报模式; TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证. TCP 与 UDP 的主要区别： &emsp;&emsp;UDP具有TCP所望尘莫及的速度优势，但在于UDP不一定提供可靠的数据传输。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。 Ps：许多程序将使用单独的TCP连接和单独的UDP连接;重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。 1.3 网络层（网络互连层） &emsp;&emsp;网络互连层定义了分组格式和协议。 &emsp;&emsp;网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。 IP：Internet 协议（Internet Protocol） ICMP：Internet控制信息协议 ARP：地址解析协议 RARP：反向地址解析协议 1.4 网络访问层（主机到网络层） &emsp;&emsp;网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接。 二、常见术语、疑问 介绍&emsp;&emsp;TCP/IP协议：是一组网络协议。在这些协议中，最重要、最著名的就是TCP和IP因此，大部分网络管理员称整个协议族为“TCP/IP”。包括：TCP，IP，UDP，ARP等，这些被称为子协议。 2.1 TCP与IP的区别&emsp;&emsp;由第一章的TCP/IP 协议的层次结构可知，TCP 和 IP 是在不同层的，因此两者本来就天差地别。 TCP：位于传输层，是一种面向连接的、端对端的、可靠的、基于IP的传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。 IP：位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交办法和路由选择。 总结： 整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层——TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。 TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。 2.2 Telnet的衍生（SSH等）&emsp;&emsp;TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能;听起来很陌生，但实际上我们是经常使用远程登录的功能，即使用Telnet的衍生; &emsp;&emsp;Telnet用来訪问远程计算机的TCP/IP协议以控制你的网络设备，是明码传输，缺乏安全性。因此诞生了远程登录的加密传输，如下： SSH：Secure Shell（包括SSH1和SSH2）Telnet/SSL： Secure Socket Layer。Telnet/SSL是带有SSL的Telnet。Rlogin：Rlogin和Telnet功能使用方法相似，可是简单非常多。Serial：串行指每次一个事件，它通常跟并行即一次发生多个事件相反，例如键盘和鼠标仅仅须要串行接口和线路TAPI：telephone Application Programming Interface （它能够使用户在电脑上通过电话或视频电话与电话还有一端的人进行交谈）电话应用编程接口RAW：大多数打印设备的默认协议 2.3 VPN和SS、SSR&emsp;&emsp;这里讲一下大家常见到的VPN和SSR的来头。 2.3.1 什么是VPN&emsp;&emsp;vpn在很多人心目中就是用来科学上网的工具，其实不是。vpn最主要的功能，并不是用来科学上网，只是它可以达到科学上网的目的。vpn–虚拟专用网络，它的功能是：在公用网络上建立专用网络，进行加密通讯。 2.3.2 什么是ss/ssrss：ss作者是clowwindy，大约两年前，他自己为了科学上网写了shadowsocks，简称ss或者叫影梭，后来他觉得这个东西非常好用，速度快，而且不会被封锁，他就把源码共享在了github上，然后就火了，但是后来作者被请去喝茶，删了代码，并且保证不再参与维护更新。现在这个好像是一个国外的大兄弟在维护。 ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，然后ss用户和ssr用户自然分成了两个派别，互相撕逼，直到前阵子，破娃被人肉出来，无奈之下删除了ssr的代码，并且解散了所有相关群组。 ss和ssr它的原理都是一样的，就是socks5代理。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了科学上网。 2.4 DNS&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的。 举例 ，例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。 &emsp;&emsp;这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置DNS的话，是无法正常访问网页的。 &emsp;&emsp;注意！是无法正常访问网页，还是能够上网的。如果没有填写DNS，可以直接使用形如 http://192.168.2.10 IP地址的形式来进行 网页访问。 2.5 Socket 和 端口号&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。 2.5.1 端口号来源&emsp;&emsp;当两台机器通过IP链接通讯，当如果其中一台机器还想和别的机器搞事情呢？例如你浏览多个网页，那怎么办？现在都讲究多进程、多线程，那多进程怎么区分了链接，就衍生出端口号。同个IP，开放多个port(端口号)，多个进程执行数据交互。 Ps：端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。 &emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。 2.5.2 SocketSocket：就是 传输层TCP协议 到 应用层HTTP、HTTPS、FTP的基石。中文：套接字。指代承载这种通讯的TCP系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号)。 &emsp;&emsp;无论是什么模块进行连接网络通信，最终都会进行应用层的数据交互(除了裸流)。但是传输层和应用层的TCP连接是有基石的，那就是Socket。 &emsp;&emsp;由于往往是听过应用层协议连接，而Socket是作为应用层基石。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。 &emsp;&emsp;Socket虽然是 传输层TCP协议&amp;应用层的基石。但是也可以不需要应用层，也就是裸流连接。常见于菜鸟的服务器，即没有任何通信协议，就像是用串口调试助手直接连一样。外面的人常直接称呼 TCP通信。 Ps：这种Socket连接方式，常见于嵌入式物联网、简单物联设备等。 &emsp;&emsp;Socket如果是严格区分的话，它带有的资源应该是：本地端口号、远地IP地址、远地端口号。因为本地IP定义下来后就不会再更改，实现多Socket链接通信，其实需要的就是多个 本地端口号、远地IP地址、远地端口号，组合成多Socket通信。 2.6 内网穿透&emsp;&emsp;内网穿透概念往往用于 大学、公司内部。 &emsp;&emsp;简单来说内网就是我们常说的局域网（LAN），而外网则是指广域网（WAN）。比如大学、医院、或者政府机构这些单位中，给每一个人分配一个IP地址，这显然是不现实的：一方面是因为这些单位的人员数量庞大，另一方面是因为人员数量也是变动的。为了解决这个问题，就出现了内网。 &emsp;&emsp;也就是说分配真实的IP，实际上只分配给广域网。局域网则是由网络管理员给的虚拟IP。 内网和外网的区别 以大学的校园网为例： 一个大学的校园网至少有一个真实的IP地址，这个真实IP地址会作为整个校园网的出口，而其他的IP地址被称为假IP地址，假的IP地址发送的网络请求会通过真实的IP地址发送到因特网上，并将获得的资源再通过这个真实的IP地址返回过来。就这样完成了网络通讯的过程。 你连学校内网，登上你的百度账号，下载百度文库的文件，会显示你是xx学校的，然后免费下载，就是因为你的网络请求实际上是从 学校真实的IP 发出去的。因此百度才会知道你是xx学校的。 假IP地址的特点：它能够访问外网IP地址，但外网IP地址却无法找这个假的IP地址。 &emsp;&emsp;因此如果想要从外网IP地址找到该虚拟IP地址，这台内网电脑就要实现内网穿透，常见的有花生壳。 2.7 现实的网络插口&emsp;&emsp;在现实生活中的网络插口，则是有两个灯，一绿一橙。 绿灯表示物理连接线正常，即网线有插好 橙灯表示网络通讯，如果在闪烁，说明在通讯；接近常亮，就说明通讯频率高 如果两个灯都正常，而网络异常；就要考虑是不是外部网络出现问题，例如DNS之类的。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP通讯_微观]]></title>
    <url>%2F2020%2F05%2F30%2FTCP%E9%80%9A%E8%AE%AF-%E5%BE%AE%E8%A7%82%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发 一、基础知识&emsp;&emsp;这里将会连续引申出微观TCP/IP协议的一些概念。嵌入式的TCP通讯最重要的一个概念，就是IP地址。 1.1 IP地址1.1.1 概念&emsp;&emsp;IP地址，英文名为IP Address，是internet protocol address的缩写，译为互联网协议地址，又译为网际协议地址。它是IP协议（internet protocol ）提供的一种统一的地址格式，分配给使用IP协议的设备的数字标签。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。更通俗的来说，IP地址给网上的每个通信设备分配了一个编号，每台联网的主机都需要有这个编号来通信。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。 1.1.2 表示通常所说的IP地址，是指IPv4。IP地址是一个32位的二进制数，例如： 100000000111111110000000011111111 通常被分割为4个8位二进制数，例如上面这个IP地址，可以分割为如下形式： 100000000 11111111 00000000 11111111 再使用十进制数来表示每个8位二进制数，十进制数之间使用点号分隔，IP地址最终表示成如下形式： 1a.b.c.d 因为一个8位二进制数表示的范围00000000 ~ 11111111正好对应十进制数0 ~ 255，所以a、b、c和d都是0 ~ 255的十进制整数。例如上面IP地址，可以表示为0.255.0.255.（1）冒分十六进制表示法 1X:X:X:X:X:X:X:X &emsp;&emsp;其中每个X表示地址中的16b，以十六进制表示，例如： 1ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 &emsp;&emsp;这种表示法中，每个X的前导0是可以省略的，例如： 12001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A （2）0位压缩表示法&emsp;&emsp;在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如： 123FF01:0:0:0:0:0:0:1101 → FF01::11010:0:0:0:0:0:0:1 → ::10:0:0:0:0:0:0:0 → :: （3）内嵌IPv4地址表示法为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为： 1X:X:X:X:X:X:d.d.d.d 前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如: 1::192.168.0.1与::FFFF:192.168.0.1 就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。 1.1.3 IPv4地址分类网络号或网络地址（NetID）：用于识别主机所在的网络；主机号或主机地址（HostID）：用于识别该网络中的主机；&emsp;&emsp;为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。私有地址：所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址。 类别 用途 网络号和主机号 最高位 地址范围 私有地址和保留地址 子网掩码 A 保留给政府机构 第一段表示网络地址，剩下三段表示主机地址 0 0.0.0.0——127.255.255.255 ①10.X.X.X是私有地址 ②127.X.X.X是保留地址 255.0.0.0 B 分配给中等规模的公司 前两段表示网络地址，后两段表示主机地址 10 128.0.0.0——191.255.255.255 ①172.16.0.0—172.31.255.255是私有地址②169.254.X.X是保留地址；191.255.255.255是广播地址，不能分配。 255.255.0.0 C 分配给任何需要的人 前三段表示网络地址，剩下一段表示主机地址 110 192.0.0.0——223.255.255.255 192.168.X.X是私有地址 255.255.255.0 D 用于组播 不分网络地址和主机地址 1110 224.0.0.0——239.255.255.255 E 用于实验 不分网络地址和主机地址 11110 240.0.0.0——255.255.255.254 如图： &emsp;&emsp;这里就不再详细介绍IP地址中的一些特殊地址了；我们目前主要用的是C类别，也就是192.168.X.X的私有地址 1.2 子网掩码&emsp;&emsp;IP地址填完后，网段不同，是并不能够直接通讯的；(平常)路由器连接的是不同的网络，网桥连接的是不同网段，这里的网络和网段有什么区别呢？ 1.2.1 网段&emsp;&emsp;路由器连接的是不同的网络，这里的网络就是网段不同的网段和不同的网络是同一个概念；专业点就说网段，通俗一点就说网络，其实就是一个意思。 那什么是同一网段？同一网段指的是IP地址和子网掩码相与得到相同的网络地址；想在同一网段，必需做到网络标识相同；各类IP的网络标识算法都是不一样的，需要根据子网掩码的位数来判断。 那什么是掩码？ 想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？ 1.2.2 掩码&emsp;&emsp;掩码，是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。用途：将源码与掩码经过按位运算或逻辑运算得出新的操作数。其中要用到按位运算如OR运算和AND运算。用于如将ASCII码中大写字母改作小写字母。 举例：如A的ASCII码值为65= (01000001)2，a的ASCII码值为97=(01100001)2，要想把大写字母A转化为小写字母只需要将A的ASCII码与(00100000)2进行或运算就可以得到小写字母a。&emsp;&emsp;子网掩码，即就是用来算网络标识的掩码. 1.2.3 网络标识 算法只要把IP和子网掩码的每位数AND就可以了。 AND方法：0&amp;1=0 0&amp;0=0 1&amp;1=1 如：And 192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位 123IP 11000000.10101000.00000000.00000001子网掩码 11111111.11111111.11111111.00000000得出AND结果 11000000.10101000.00000000.00000000 转换为十进制192.168.0.0，这就是网络标识， 再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP AND 得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1；这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。 这里介绍最常用的两种子网掩码，它们分别是“255.255.255.0”和“255.255.0.0”。 1.3 网关地址&emsp;&emsp;如果网段不同，就实现不了通信，但现实生活中那么多设备肯定不在同个网段；那么不同网段确能够通信，就需要 网关 了.&emsp;&emsp;网关（gateway）是一个网络连接到另一个网络的“关口”，网关地址实质上是一个网络通向其他网络的IP地址，主要用于不同网络间数据传输。网关在网段内的可用ip中选一个，一般选择是第一个或最后一个。 举例:比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1 ~ 192. 168.1.254”，子网掩码是255.255.255.0；如果需要与其他网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其他的一个IP地址。网络B的IP地址范围是“192.168.2.1 ~ 192.168.2.254”，子网掩码255.255.255.0。如果需要与其他网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。 网关是如何实现通信？&emsp;&emsp;在没有路由器的情况下，不同的网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的的主机不再本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。所以说，设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。 网关设置方式有哪些？ 手动设置：手动设置适用于电脑数量比较少、TCP/IP参数基本不变的情况，比如只有几台到十几台电脑。因为这种方法需要在联入网络的每台电脑上设置“默认网关”，非常费劲，一旦因为迁移等原因导致必须修改默认网关的IP地址，就会给网管带来很大的麻烦，所以不推荐使用。 自动设置：利用DHCP服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。 1.4 MAC地址&emsp;&emsp;媒体访问控制（media access control，MAC）是物理地址、硬件地址，用来定义网络设备的位置。 ip是虚拟地址；mac是网卡地址全世界只有一种没重复的。MAC是网络中用来识别网卡设备的唯一网络地址；由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的 1.5 DNS&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的； 举例 ，例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。 这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置的话，是无法正常访问网页的。 1.6 Socket 和 端口号&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。 这里引入 端口号 的概念：一个计算机上可以有多个进程作为(多个)服务器 or 客户端 ，但是 ip 每个机器只有一个，所以通过不同的 port 数字加以区分。 Ps：端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。 &emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。 Socket ： 就是指代承载这种通讯的系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号) Ps：Socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。 二、基于W5500的TCP通讯&emsp;&emsp;等待更新中。。。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modbus协议_具体实现]]></title>
    <url>%2F2020%2F05%2F30%2FModbus%E5%8D%8F%E8%AE%AE-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式 一、搭建环境&amp;简介 采用的是stm32f103RBT6为例 从机实现采用 FreeModbus库 Modbus TCP通讯是基于 W5500 实现的 &emsp;&emsp;这里主要讲解的是Modbus从机(Server)的实现。因为实际产品常用于采集数据或做动作处理，一般是作为从设备，接入Plc(Modbus主机)。 二、Modbus主机(Master)&emsp;&emsp;Modbus主机一般很少用到。主要用途，一般用于：实际产品分为前后台，后台做所有的数据处理，作为Modbus从机；而前台主要用于做界面显示，即作为Modbus主机，界面数据修改通过串口Modbus通讯。 &emsp;&emsp;由于是前后台的内置通讯，常用的Modbus主机 当然是采用方便、可靠的 Modbus RTU通讯。 &emsp;&emsp;当然由于前后台通讯占用一个硬件串口Modbus通讯。因此，常见的Modbus从机，往往是具有多串口Modbus通讯，共享一套地址处理数据(当然，可能前后台内置通讯在实际产品说明书中被隐藏)。 &emsp;&emsp;Modbus主机，在网上是没有开源，只有收费版本的。其实只要根据Modbus协议，很容易就能写一个Modbus主机。 唯一需要注意的点：每个数据帧发送之间的间隔为 3.5T；防止从机接收到的数据黏合。 &emsp;&emsp;但是由于Modbus主机一般要处理其他事宜，往往本身每个数据帧发送之间的间隔都 &gt; 3.5T。因此实际上，写得不标准也能用；当然严谨一点的话，写一个定时器，发送就开启定时器，定时器溢出置标志位才能再次发送也是可以的。 三、Modbus从机(Slave)&emsp;&emsp;这里的Modbus从机是基于 FreeModbus库 实现的。 &emsp;&emsp;Freemodbus库的代码是写得很好的，如果C语言学得好，且对Modbus协议了解的话，建议直接看源码，多看多观察可以提高自己的代码水平。 3.1 FreeModbus移植(RTU模式)&emsp;&emsp;FreeModbus详细移植方法可以参照以下博主： FreeModbus在STM32上移植 STM32上移植FreeModbus详细过程 3.2 如何计算RTU模式的 3.5T 超时时间？波特率：每秒钟通过信道传输的信息量称为位传输速率，也就是每秒钟传送的二进制位数,简称比特率。 比特率：表示有效数据的传输速率，用b/s 、bit/s、比特/秒，读作：比特每秒。 通常的串口桢格式为10位：开始位1bit + 数据位8bit + 停止位1bit &emsp;&emsp;如9600b/s：指总线上每秒可以传输9600个bit；也就是说：在9600的波特率下，每秒可以传输出的桢数为：9600 / (1 + 8 + 1) = 960桢/秒，即960字节/秒(实际数据速率)； 反推：一帧或一字节数据需要的时间是多少呢？ 1s / 960 = 1.4ms 而ModBus协议中超时时间定为：3.5个帧长度为超时时间； 超时时间 = 3.5 * 1 / BaudRate / 10 秒 = 3.5 * 10 / BaudRate 秒 = 3.5 * 10 * 2 / BaudRate * 2 秒 = 70 / BaudRate * 2 秒 FreeModBus是这样实现的： 12345678910111213141516171819/* If baudrate &gt; 19200 then we should use the fixed timer values* t35 = 1750us. Otherwise t35 must be 3.5 times the character time.*/if( ulBaudRate &gt; 19200 )&#123; usTimerT35_50us = 35; /* 1800us. */&#125;else&#123; /* The timer reload value for a character is given by: * * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 ) * = 11 * Ticks_per_1s / Baudrate * = 220000 / Baudrate * The reload for t3.5 is 1.5 times this value and similary * for t3.5. */ usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );&#125; 波特率大于19200使用定值：1800us &emsp;&emsp;由于将usTimerT35_50us = 35;直接带入，在定时器驱动初始化实际代入的计算值为 (35 = 36-1)，因此实际的定时时间为：36 * 50(基值) = 1800 us。 波特率小于19200使用定值：1usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate ); 解析：由于Modbus的RTU模式是串口帧格式为11位，故 超时时间 (50us为单位) = 3.5 * 1 / BaudRate / 11 秒 = 3.5 * 11 / BaudRate 秒 = 3.5 * 11 * 2 / BaudRate * 2 秒 = 7 * 11 / BaudRate * 2 秒 = 7 * 11 * 1000000 / 50 / BaudRate * 2 (50us为单位) = 7 * 220000 / BaudRate * 2 (50us为单位) &emsp;&emsp;这usTimerT35_50us一个单位为50uS，将这个超时时间计算结果用于定时器驱动初始化。每中断一次为50us * usTimerT35_50us 微秒；且每次更改Modbus通信的波特率，Modbus的定时器驱动初始化都要更新一次，更新定时器计数溢出值。 四、 FreeModbus库源码&emsp;&emsp;3.1所提到的移植，是把RTU模式通讯的底层给移植好，报文中的具体数据单元处理功能函数还是得自己继续写。 &emsp;&emsp;但暂先不讲具体的数据单元处理功能函数写法，先讲解整个FreeModbus源码的实现过程，使其后面更清晰如何写数据单元处理功能函数，甚至可以自己移植、扩展改动(ASCII、TCP模式)。 4.1 实现的核心原理&emsp;&emsp;每一帧的数据区分是采用3.5T的方法。那么MCU具体的实现方法思路如下： &emsp;&emsp;使能串口接收中断，一但接收到数据(触发串口接收中断)，就开启定时器，每一次重新触发串口接收中断，就会重启定时器&amp;重新计数；直到不触发串口接收中断，导致定时器溢出，此时视为接收一帧完整数据，开始解析数据。再根据自己喜好响应主机的信息。 &emsp;&emsp;以上就是整体思路，你甚至可以根据这个思路自己实现Modbus通讯的从机部分。接下来就是FreeModbus同样思路实现方式的讲解 4.2 FreeModbus库通讯实现讲解(RTU模式为例) Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态 串口接收中断 在初始化状态下，打开定时器 等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将eMBPoll的 事件状态机 置为 初始化。 以上就是初始化完成，接下来就是数据收发的流程了 串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。 每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。 当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态 由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。 eMBPoll的 事件状态机 为Frame received接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功 核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 MB_EIO的错误。 经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为Execute function 执行数据函数(事件)。开始对数据进行处理。 这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。 如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 功能码|0x80 + 错误代码。 举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。 在处理完后会返回一个enum状态值。如果状态 不为MB_ENOERR，即内部使用的错误代码，根据内部使用的enum错误代码，switch生成 对外的错误代码 返回的CRC会在发送前先把CRC校验完成。 发送前，检查能不能数据接收，能接收则报硬件错误MB_EIO，因为协议规定只能单向收发 发送一个字节数据，然后开启发送中断，一直发送，直到完成 发送完成后，将 eMBPoll的 事件状态机 置为 发送完成 事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲 &emsp;&emsp;以上就是FreeModbus库实现Modbus RTU通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。这个库源码写的很好，如果是嵌入式新手，这份源码还是很推荐看的。 &emsp;&emsp;如果顺着程序缕是能看得懂的，这里再留一份函数==笔记==，方便小白初次看时疑惑，可查阅一下。 4.3 数据单元处理功能函数这里的写法思路分为3个部分： 第一部分函数用于对应FreeModbus库编写的处理函数 例如，库里面处理到最后，总是地址+1,；可以在这里去掉 这里用来区分 读、写 第二部分函数用于自己应用层的地址约束 并可以对不同地址块进行不同处理 第三部分函数用于具体地址的详细操作 4.3.1 数据单元初步处理&emsp;&emsp;编写具体如下四个函数对应FreeModbus库的处理： eMBRegCoilsCB eMBRegHoldingCB eMBRegDiscreteCB eMBRegInputCB12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************************************* 函数名 : eMBRegCoilsCB* 功 能 : 线圈回复函数* 说 明 : none* 入 参 : *pucRegBuffer : 要添加到协议中的数据* usAddress : 线圈地址(PLC地址)* usNRegs : 要访问线圈的个数* eMode : 访问类型（MB_REG_READ为读线圈状态，MB_REG_WRITE为写线圈）* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )&#123; eMBErrorCode eStatus = MB_ENOERR; usAddress--;// 由PLC地址转为协议地址 switch ( eMode ) &#123; case MB_REG_READ: eStatus = AppFMD_RdCoils(usNCoils,usAddress,pucRegBuffer);break; case MB_REG_WRITE: eStatus = AppFMD_WrCoils(usNCoils,usAddress,pucRegBuffer);break; default:break; &#125; return eStatus;&#125;/********************************************************************************* 函数名 : eMBRegHoldingCB* 功 能 : 保持寄存器回复函数* 说 明 : none* 入 参 : *pucRegBuffer : 要添加到协议中的数据* usAddress : 寄存器地址* usNRegs : 访问寄存器的个数* eMode : 访问类型（MB_REG_READ为读保持寄存器，MB_REG_WRITE为写保持寄存器）* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )&#123; eMBErrorCode eStatus = MB_ENOERR; usAddress--;// 由PLC地址转为协议地址 if (eMode == MB_REG_READ) eStatus = AppFMD_RdRegs(usNRegs,usAddress,pucRegBuffer); if(eMode == MB_REG_WRITE) eStatus = AppFMD_WrRegs(usNRegs,usAddress,pucRegBuffer); return eStatus; &#125; 4.3.2 线圈和寄存器处理&emsp;&emsp;根据 4.3.1，只编写可读写线圈和寄存器的函数，具体对应函数如下： eMBErrorCode AppFMD_RdCoils(uint32_t si_num, uint32_t uiAddr, uint8_t *puc_txpointer) eMBErrorCode AppFMD_WrCoils(uint32_t si_num, uint32_t uiAddr,uint8_t *puc_txpointer) 最好在这块函数进行总的地址划分1234567891011121314151617181920212223242526272829303132333435363738/********************************************************************************* 函数名 : * 功 能 : * 说 明 : none* 入 参 : si_num : 待读的 线圈|寄存器 个数* uiAddr : 地址索引 从0起始* *puc_txpointer : 输出缓存* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode AppFMD_RdRegs(uint32_t lNum, uint32_t ulAddr,uint8_t *puc_txpointer)&#123; eMBErrorCode eStatus = MB_ENOERR; //内部参数 if(ulAddr&lt;1000) &#123; while(lNum) &#123; puc_txpointer = BuiltReadWord(ulAddr, puc_txpointer); lNum -= 1; ulAddr += 1; &#125; &#125; //用户自定义参数 else if(ulAddr&gt;=1000 &amp;&amp; ulAddr&lt;1400) &#123; while(lNum) &#123; puc_txpointer = BuiltReadWord_Double(ulAddr, puc_txpointer); lNum -= 2; ulAddr += 2; &#125; &#125; else eStatus = MB_ENOREG; return eStatus;&#125; 4.3.3 用户自定义的 线圈 &amp; 寄存器 处理&emsp;&emsp;根据 4.3.2，在对应的函数写具体到某个地址位的操作就行了。 五、通讯报文讲解&emsp;&emsp;这里是方便没接触过Modbus的人，或者是长时间没用急用，直接来查阅Modbus报文的；好清楚是哪里出的问题(主机 or 从机？)。 5.1 报文格式总结&emsp;&emsp;首先，如果从机是返回很短的(报错)报文，直接看功能码位，例如 0x83 ；去掉 &amp; 0x80 的操作，那就是 功能码 0x03 出现错误。 主机的读取数据命令(长度)是固定的：ID + 功能码 + 地址 + 数据长度 + CRC16 从机返回的数据格式不是固定的： 读取长度为1：ID + 功能码 + 数据长度 + 数据1 + CRC16 读取长度为2：ID + 功能码 + 数据长度 + 数据1 + 数据2 + CRC16 主机的写入数据格式不是固定的 从机返回数据格式(长度)是固定的(与上面的相反) 5.2 报文举例功能码0x03，读可读写模拟量寄存器： (主机)发送命令格式： [设备地址] [功能码03] [起始寄存器地址高8位] [低8位] [读取的寄存器数高8位] [低8位] [CRC校验低8位] [CRC校验高8位] 例：[11][03][00][6B][00][03][CRC低][CRC高] 意义如下： 11：设备地址，例子中的地址是11； 03：读模拟量的命令号固定为03，这是Modbus协议规定的。 00、6B：起始地址高8位（00）、低8位（6B）：表示想读取的模拟量的起始地址，比如例子中的起始地址为107。这个006B表示一个完整的地址，注意这里的地址是高8位在前，低8位在后。 00、03：寄存器数高8位（00）、低8位（03）：表示从起始地址开始读多少个模拟量（返回的每一个模拟量是用两个字节表示的）。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节同时这里的地址也是高8位在前，低8位在后。 [CRC低][CRC高]：帧尾的CRC-16校验，尤其需要注意的一点是校验结果的低8位在前，高8位在后，这个顺序不同于起始地址以及读取深度的地址顺序。 (从机)设备响应： [设备地址] [命令号03] [返回的字节个数][数据1][数据2]…[数据n][CRC校验的低8位] [CRC校验的高8位] 例：[11][03][06][02][2B][00][00][00][64][CRC低][CRC高] 意义如下： 11：设备地址（从机地址）； 03：功能码； 06：返回的字节个数（不高扩两字节的校验码）：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。数据1…n：其中[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。 [CRC低][CRC高]：CRC校验同上。 六、基于W5500的Modbus TCP&emsp;&emsp;如果是理解了上面源码的讲解，那么这里将会异常简单。由于W5500芯片，集成了硬件TCP/IP协议，数据接收完成与否的判断，也在W5500内完成；因此，FreeModbus库内的TCP函数大部分都不需要用到(例如，初始化函数)，只需要FreeModbus库的 TCP_Poll事件状态机(初始化要置位事件状态)。 &emsp;&emsp;先根据W5500的数据手册、或者例程，先编写好W5500的通讯驱动；程序中，读取W5500中断，如果有产生接收完成中断，就把TCP_Poll事件状态机置为接收完成，然后接下来就是TCP_Poll自己处理了，沿用同一套的数据单元处理功能函数。这样就完成了！ 七、FreeModbus库_拓展&emsp;&emsp;Freemodbus库虽然写得很好，但是它的思路框架是以1个通讯接口实现的。如果是在 Modbus主机 一节提到的：有多串口Modbus通讯，共享一套地址处理数据。当你多串口RTU通讯，且波特率不相同，定时器的配置也就要变动一下。甚至还有，一个实际产品，它不仅有Modbus 多串口通讯，它还可能要有Modbus TCP通讯，而且也还是共享一套地址处理数据。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Modbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modbus协议_概念讲解]]></title>
    <url>%2F2020%2F05%2F30%2FModbus%E5%8D%8F%E8%AE%AE-%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯 一、基本概念&emsp;&emsp;Modbus协议 是一个请求/应答协议，发起请求的为Master（client），响应请求的为Slave（server）;Modbus协议包括ASCII、RTU、TCP三种报文类型，并没有规定物理层。 &emsp;&emsp;标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。 Master端发出读数据请求消息，Slave端接收到正确消息后，就发送对应数据到Master端以响应请求； Master端发出写数据请求消息，Slave端接收到正确消息后，就修改Slave端的数据； 先发请求，再接收响应，从而实现 主机 对 从机 读/写操作。 二、报文格式_通用部分 (ADU)报文，指的是一串完整的指令数据；一个报文就是一帧数据，一个数据帧就一个报文 (MBAP)报文头，即报文的一部分，用于识别。当然也有些是部分数据在报文尾部，例如CRC数据校验。 (PDU)协议数据单元，这部分就是通信中的数据部分了。 举例如下： &emsp;&emsp;由于报文类型的不同，报文之间也存在一些差异。先讲解通用的 功能码 &amp; 错误代码 部分。 2.1 Modbus部分功能码 功能码（十六进制） 中文名称 位操作/字节操作 操作数量 错误功能码(&amp;0x80) 01 读线圈状态 位操作 单个或多个 0x81 02 读离散状态 位操作 单个或多个 0x82 03 读保持寄存器 字节操作 单个或多个 0x83 04 读输入寄存器 字节操作 单个或多个 0x84 05 写单个线圈 位操作 单个 0x85 06 写单个保持寄存器 字节操作 单个 0x86 0F 写多个线圈 位操作 多个 0x8F 10 写多个保持寄存器 字节操作 多个 0x90 &emsp;&emsp;Modbus协议规定，从机当执行对应功能码处理时发生错误，响应主机时需要将 功能码 & 0x80 将其返回。 2.2 错误代码表 代码 名称 含义 01 非法功能 对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。 02 非法数据地址 对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。 03 非法数据值 对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。 04 从站设备故障 当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。 05 确认 与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。 07 从属设备忙 与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。 08 存储奇偶性差错 与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。 0A 不可用网关路径 与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。 0B 网关目标设备响应失败 与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。 ## 2.3 Modbus 寄存器地址分配 寄存器信息地址(PLC 地址) 适用功能码（十六进制） 寄存器种类 —- — —- 00001-09999 01 05 15 线圈状态 10001-19999 02 (开关)输入状态 30001-39999 04 输入寄存器 40001-49999 03 06 16 保持寄存器 ## 2.4 小总结(心得) &emsp;&emsp;一般情况下，只需要看一下返回的功能码就行了，错误代码可以不用看。Modbus通讯发生错误，往往出现的情况如下: 1. Modbus主机(PLC)读取有问题，例如读的地址写错，读的数据长度写错 2. Modbus从机压根就没写该 功能码 0r 地址 对应的处理，当主机对其操作自然报错。 3. 并不是符合Modbus协议规范的报文就一定通信正确，只能说是通讯成功，因为它返回给你一条报错指令。通讯无响应，说明是主机本身发的数据就有问题；通信有响应(可能返回错误报文)，说明该地址不可用，主机读歪了或者从机压根没写该功能处理。 三、各报文格式_详细解析&emsp;&emsp;每个报文都与其他报文格式有一定区分。在Modbus从机的角度看，讲解一下他们之间的类似之处。 三者功能码是通用的 RTU 和 TCP的报文十分类似。TCP由于是可靠的协议，且通过IP连接，相比RTU就少了 设备ID &amp; CRC数据校验。数据单元部分是完全一样的。 RTU &amp; ASCII 都是通过串口通讯的，因此都是需要 定时器。但是定时器具体用法不相同。 Ps：ASCII模式，国内基本没用到。常用的是 RTU &amp; TCP 模式。 3.1 RTU模式&emsp;&emsp;Modbus RTU协议中没有明显的开始符和结束符，而是通过帧与帧之间的间隔时间来判断的。如果在指定的时间内，没有接收到新的字符数据，那么就认为新的帧接收完毕。接下来就是处理数据。Modbus通过时间来判断帧接收完成，自然需要 MCU 的定时器配合(3.5T)。| 设备地址 | 功能代码 | 数据 | CRC校验 | 结束符(实际报文可没有这个！)| — | —- | — | —- | —| 1个字节 | 1个字节 | n个字节 | 2个字节 | T1-T2-T3-T4 地址码：每个从机都必须有唯一的地址码ID（从1到247，0是广播地址），并且只有符合地址码的从机才能响应回送。当从机回送信息时，相应的地址码表明该信息来自于何处。 功能码：主机发送的功能码告诉从机执行什么任务。ModBus通讯规约定义功能号为1到127。表2-1列出部分常用功能码，以备查询。 数据区：数据区包含需要从机执行什么动作或由从机采集的返送信息。应答包中，数据包括了数据字节长度+数据值，请求包中数据只包含数据值。 校验码：主机或从机可用校验码进行判别接收信息是否出错。 从Modbus主机角度上看 使用RTU模式，消息发送至少要以3.5个字符时间的停顿间隔开始（如上图的T1-T2-T3-T4所示）。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。 一旦连续发送间隔 小于3.5T，就会对从机数据接收造成 数据黏合。 从Modbus从机角度上看 整个消息帧必须作为一连续的流传输，如果在帧完成之前有超过1.5个字符时间的停顿时间则为非法帧；如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为在最后的CRC域的值不可能是正确的。即帧之间的间隔必须大于3.5T，帧内字符的间隔必须小于1.5T。实际应用中1.5T一般不处理，只采用3.5T进行处理（FreeModBus开源代码就是这样)。 FreeModbus库，采用的是3.5T作为判断。只要是超过3.5T，就视为两个数据帧处理。当然，如果主机发送数据异常，让 某条报文中间字符发送相隔时间超过3.5T，那么就会造成 1条正确报文被分割成2条报文，造成 数据裂开。 数据裂开一般不会出现。采用FreeModbus库时，正常情况下，高波特率会对3.5T的值进行限制。如果解开该限制，导致3.5T实际值太小(高波特率转换计算出来)，这时候主机的字符发送间隔慢一点，从机将无法识别到正确的报文(数据被分裂)。 3.2 ASCII模式&emsp;&emsp;除了数据域为ASCII码，其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。消息中字符间发送的时间间隔(MCU 的定时器)最长不能超过1秒，否则接收的设备将认为传输错误。 起始位 设备地址 功能代码 数据 LRC校验 结束符 ： 2个字符 2个字符 n个字符 2个字符 2个字符 &emsp;&emsp;使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH） 3.3 TCP/IP模式&emsp;&emsp;与MODBUS RTU相比，少了校验域和地址码，其中地址码被放到MBAP报文头里面了(即 00 00)，没有校验域是因为TCP本身就有校验所以省略了。 报文头MBAP，长度为7字节，组成如下： 事务处理标识 ：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文(主机要注意的点，从机不对该数据进行识别处理)。 协议标识符 ：00 00表示ModbusTCP协议。 长度 ：表示接下来的数据长度，单位为字节。 单元标识符 ：可以理解为设备地址。 事务处理标识 协议标识 长度 单元标识符 功能代码 数据 2字节 2字节 2字节 1字节 1字节 n字节 四、调试工具 如果你做的是Modbus Master，可以使用modbus slave工具模拟从设备来调试，该工具下载地址：Modbus Slave 如果你做的是Modbus Slave，可以使用modbus poll工具模拟主设备来调试，该工具下载地址：Modbus Poll 以上两个工具的使用方法，可以参考此博客：Modbus测试工具ModbusPoll与Modbus Slave使用方法]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Modbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这段时间的总结]]></title>
    <url>%2F2020%2F05%2F30%2F%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;好久没更新博客了= =？ &emsp;&emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。 &emsp;&emsp;然后偶然，又和高中老同学聊了聊；这回会持续更新，而且要加很多新内容！！！ &emsp;&emsp;继续加油，奥力给！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针]]></title>
    <url>%2F2020%2F03%2F15%2F%E9%87%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、野指针由来1.1 野指针概念(简述)概述：“野指针”不是NULL指针，是指向“垃圾”内存的指针。(内存能不能用另外一回事) (局部)指针变量没有初始化 使用已经释放后的指针 指针所指向的变量在指针之前被销毁 1.2 野指针概念(专业描述) 指针未初始化&emsp;&emsp;指针变量在定义时不会自动初始化成空指针，而是随机的一个值，可能指向任意空间，这就使得该指针成为野指针。因此指针在初始化时要么指向一个合理的地址，要么初始化为NULL。即使不初始化，调用指针前，一定要赋值！ 指针指向的变量被free或delete后没有置为NULL&emsp;&emsp;在调用free或delete释放空间后，指针指向的内容被销毁，空间被释放，但是指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针。因此在调用free或delete之后，应将该指针置为NULL。 指针操作超过所指向变量的生存期&emsp;&emsp;当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针。这种错误很难防范，只有养成良好的编程习惯，才能避免这类情况发生。 1.3 野指针的要点(简单描述) 野指针通常是因为指针变量中保存的值不是一个合法的内存地址而造成的 野指针不是NULL，是一个指向不可用内存的指针 C语言中没有方法可以判断是否为野指针(可替换成NULL指针，NULL指针不容易弄错，可以通过if来判断是否为NULL指针) 1.4 野指针的要点(深度描述) 野指针只能避免而无法判断 &emsp;&emsp;无法判断一个指针是否为野指针，因为野指针本身有值，指向某个内存空间，只是这个值是随机的或错误的。 Ps：空指针并非野指针，它具有特殊性和确定性，可以进行判断；因此要避免在程序中出现野指针，可以做完操作及时将指针指向NULL。 野指针并非立马让系统出事 &emsp;&emsp;指针也是数据，首先如果是局部的，不置空也没关系反正用不到了；如果是全局的，得用的时候释放了可能也会立马再次新赋值，如果不是那肯定需要重置为null，这也是方便你后面的判断是否需要赋值，如果你再次用不到，那么(不重置)就完全不影响程序的健壮性。但是，如果 再调该(野)指针就会可能出现问题！ 有的可能比较复杂不一定开始就初始化，那你在某个地方用的时候会判断是否为空，然后给它赋值。就像很多做逻辑判断的bool，初始也会有值，如果没值，那你就看系统给的初始值，区别就是指针如果没初始化，然后对指针进行操作(调用)，可能会导致崩溃。也就是说，野指针并不是直接让系统出事，而是自己无意识产生野指针但还调用的操作才是让系统出事的真正原因！ 野指针的错误是严重的 指向不可访问的地址&emsp;&emsp;危害：触发段错误。 指向一个可用的，但是没有明确意义的空间&emsp;&emsp;危害：程序可以正确运行，但通常这种情况下，我们就会认为我们的程序是正确的没有问题的，然而事实上就是有问题存在，所以这样就掩盖了我们程序上的错误。 指向一个可用的，而且正在被使用的空间&emsp;&emsp;危害：如果我们对这样一个指针进行解引用，对其所指向的空间内容进行了修改，但是实际上这块空间正在被使用，那么这个时候变量的内容突然被改变，当然就会对程序的运行产生影响，因为我们所使用的变量已经不是我们所想要使用的那个值了。通常这样的程序都会崩溃，或者数据被损坏。 二、未初始化指针的神奇操作&emsp;&emsp;指针未初始化，系统一般会自动分配内存给未初始化的指针，但也有时候指向NULL。由于太过玄学，建议直接初始化置或一个有用的内存。 2.1 非字符串指针未初始化1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件int main()&#123; int a=20,*p; //这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针 printf("%d-&gt;%p\n", a, p); //观察%p是输出一个地址数据 p=NULL; printf("%d-&gt;%p\n", a, p); p=&amp;a; printf("%d-&gt;%p：%d\n", a, p, *p); p=(int *)malloc(sizeof(int)); printf("%d-&gt;%p：%d\n", a, p, *p); *p=30; printf("%d-&gt;%p：%d\n", a, p, *p); return 0;&#125; 程序执行的结果如下： 1234520-&gt;(nil)20-&gt;(nil)20-&gt;0x7ffe4b25dc04：2020-&gt;0xfaa010：020-&gt;0xfaa010：30 2.2 字符串指针未初始化123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件intint main()&#123; char *a="ShaTang"; char *p; //这里定义了一个字符串指针，但没赋初值，这时我们叫这个指针为野指针 printf("%s-&gt;%p\n", a, p); //观察%p是输出一个地址数据 p=NULL; printf("%s-&gt;%p\n", a, p); p=a; printf("%s-&gt;%p：%s\n", a, p, p); p=(char *)malloc(sizeof(char)); printf("%s-&gt;%p：%s\n", a, p, p); p="Zhu"; printf("%s-&gt;%p：%s\n", a, p, p); return 0;&#125; 程序执行的结果如下： 12345ShaTang-&gt;(nil)ShaTang-&gt;(nil)ShaTang-&gt;0x4006d4：ShaTangShaTang-&gt;0x134a010：ShaTang-&gt;0x4006f1：Zhu Ps：观察2.1和2.2，就会发现字符(数组)类型，引用数据和查看地址都是用指针。&emsp;&emsp;编译器此时帮我们把 未初始化指针 指向 NULL。我们对野指针的定义：指针指向垃圾(未知)的内存；在这里，我们就不能称它为野指针。 2.3 例1变形的玄学123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件int main()&#123; int a=20; int *d1,*p;//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针 printf("%d-&gt;%p\n", a, p); //观察%p是输出一个地址数据 printf("%d-&gt;%p\n", a, d1); //观察%p是输出一个地址数据 p=NULL; printf("%d-&gt;%p\n", a, p); printf("%d-&gt;%p\n", a,d1); return 0;&#125; 编译器1，程序执行的结果如下： 123420-&gt;0x7ffde8b16b8020-&gt;0x4004f020-&gt;(nil)20-&gt;0x4004f0 编译器2，程序执行的结果如下： 1234-&gt;0x7fff890b4780-&gt;(nil)-&gt;(nil)-&gt;(nil) &emsp;&emsp;编译器此时分配内存给 未初始化指针，还是玄学分配,有时候置NULL(虚_野指针)，有时候又分配一块内存(真_野指针)。因此需要注意 要指针的初始化，或者调用时一定要(检查)赋值，带来不可估量的Bug。&emsp;&emsp;编译器1和编译器2对 例2.1 编译的结果都是一样的，但是对 例2.3 的编译结果却各不相同。但是反过来，只是简单变动，编译器就能玄学分配，这是很恐怖的事情。 三、野指针概念案例&emsp;&emsp;按照野指针的概念，举如下例子 例1：指针变量没有初始化12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Zhu"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针// strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 编译器1，程序执行的结果如下： 120x7fffea4889f0 编译器2，程序执行的结果如下： 111 Segmentation fault &emsp;&emsp;这里不采用strcpy举例说明 指针变量没有初始化 的问题，后面单独一节再讲解原因。&emsp;&emsp;这里很明显，在编译器2上，printf打印 未初始化的指针，出现段错误(实际指针 指向NULL)。而编译器1，则是通过了，并得知编译器1给 未初始化的指针 赋了一块随机内存。你的代码在不同的编译器上，有的报错，有的通过，这也是野指针带来的危害。 例2：使用已经释放后的指针(释放后没改指向NULL)123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void func(char* p)&#123; printf("%s\n", p); free(p);&#125;int main()&#123; char* s = (char*)malloc(sizeof(char)); printf("%p\n", s); strcpy(s, "Delphi Tang"); func(s); printf("%s\n", s); //OOPS! printf("%p\n", s); return 0;&#125; 程序执行的结果如下： 12340x1f0e010Delphi Tang0x1f0e010 &emsp;&emsp;程序是可以正常执行的。但是在执行结果第三行：打印野指针指向的内存为空白。首先我们先重新明确上面的概念：“野指针”不是NULL指针，是指向“垃圾”内存的指针。内存的申请释放和指针没有太大关系，内存释放后，printf能正常打印出指针指向的地址，但是地址所在的内存内容就有问题了(为下次调用埋雷)。 例3：指针所指向的变量在指针之前被销毁123456789101112#include &lt;stdio.h&gt;char* func()&#123; char p[] = "Delphi Tang"; return p;&#125;int main()&#123; char* s = func(); printf("%s\n", s); //OOPS! return 0;&#125; &emsp;&emsp;在我测试用的多个编译器，结果都不相同；局部变量在函数执行完，内存是已经释放的，还调用指向该内存的指针，即野指针调用；造成的结果在每个编译器都不太相同。 四、strcpy引发的段错误&emsp;&emsp;很多人讲解 未初始化的指针 导致的 野指针的时候，很多实例代码都是用到strcpy来讲解 指针未初始化 的问题。这是很不严谨的，从上面的案例分析，稍微改下代码，系统就能分配一块内存 或者 置NULL。 4.1 错误的例子112345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Shatang"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 编译器1，程序执行的结果如下： 12Shatang0x7ffc79832540 编译器2，程序执行的结果如下： 111 Segmentation fault 在编译器2环境下，注释strcpy(s1 , s2);和printf("%s\n", s1);，程序执行的结果如下： 1(nil) &emsp;&emsp;也就说，用strcpy来举例 未初始化指针 的问题是有问题的。当编译器给 未初始化指针 置NULL时，这时候已经不算是野指针了，反而会出现段错误；当随机分配内存，编译却通过了，说明这个问题跟野指针无关，这是由strcpy引发的段错误。 4.2 strcpy语法strcpy的语法如下： 1strcpy(char* dest, const char *src); 被覆盖的 dest首先是个变量，变量就必须有内存存放；而一个指向NULL的指针没有指向任何内存。没有内存，怎么存储覆盖过来的值？ &emsp;&emsp;或者来个更直接的： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1=NULL; //不初始化，此时指向NULL char *s2="Shatang"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 所有的编译器程序执行的结果如下： 112 Segmentation fault 4.3 错误的例子212345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char *s1="Shatang"; char *s2="Zhu"; strcpy(s1 , s2); // OOPS! printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; &emsp;&emsp;注意：这里我们将字符串指针初始化，指向一块明确内存(不是野指针了)；但程序执行还会报 理所应当的 Segmentation fault的错误。strcpy函数的dest是一个变量，不能指向字符串常量；字符串常量存放在内存位置的字符常量区(详情看内存知识)， 字符串指针指向这个区域，而且这个区域是一个const 属性的不可修改的；因此 再进行拷贝覆盖的时候会出现段错误。 4.4 正确的例子112345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char s1[10]="Shatang"; char *s2="Zhu"; strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 程序执行的结果如下： 12Zhu0x7ffff41e089e 4.5 正确的例子212345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Zhu"; s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 程序执行的结果如下： 12Zhu0x144e010 &emsp;&emsp;由此可见strcpy引发的段错误，并非是野指针引起的；而是编程人对strcpy的用法不了解导致的。 4.6 得出来的结论&emsp;&emsp;只要调用该指针前，先把指针赋值指向对应的内存，就不会影响到系统的健壮性。如果严谨一点，还是把对指针进行 初始化赋值 或 置为NULL吧！ (抽风编译器牛逼!) 五、经典野指针错误&emsp;&emsp;野指针犯错方式是花式的、神奇的。随着编译器的不同，野指针造成的结果也不相同；甚至在同一个编译器下，你定义变量的数量不同，多一个或少一个，系统就可能让 未初始化的指针 置NULL或者是分配随机内存。野指针，强就强在，随机神秘翻车！不仅如此，还是编译通过的后续翻车(关键点)！！！ &emsp;&emsp;因此，大家也不要对野指针编译的结果不同太诧异。具体的错误例子可以看 内存分配方式 一节内容。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配方式]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;重新编写内容，并附带了相关链接~ 一、内存分配方式&emsp;&emsp;一个由C/C++编译的程序占用的内存分为以下几个部分： 栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） ： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 全局区(静态区)(static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 文字(字符)常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放 程序代码区 ：存放函数体的二进制代码。 二、例子程序123456789101112131415161718192021222324int a = 0; //全局初始化区char *p1; //全局未初始化区main()&#123; int b; //栈 char s[] = "abc"; //栈 char *p2; //栈 char *p3 = "123456";//123456在常量区，p3在栈上 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //申请分配得来的10和20字节的区域就在堆区 strcpy(p1, "123456"); //123456放在常量区 //编译器可能会将它与p3所指向的"123456"优化成一个地方&#125; 三、堆和栈的理论知识3.1 申请方式 stack：由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 heap：需要程序员自己申请，并指明大小(在c中为，malloc函数) 例如，p1 = (char *)malloc(10); Ps： 但是要注意p1本身是在栈中的。 3.2 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 3.3 申请大小的限制栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 3.4 申请效率的比较栈由系统自动分配，速度较快。但程序员是无法控制的。 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. &emsp;&emsp;另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 3.5 堆和栈的存储内容栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 &emsp;&emsp;当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 3.6 存取效率的比较12char s1[] = "aaaaaaaaaaaaaaa";char *s2 = "bbbbbbbbbbbbbbbbb"; aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的； 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。比如： 1234567891011121314#include &lt;stdio.h&gt;void main()&#123; char a = 1; char c[] = "1234567890"; char *p ="1234567890"; a = c[1]; a = p[1]; return;&#125; 对应的汇编代码： 1234567891011121310: a = c[1];00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]0040106A 88 4D FC mov byte ptr [ebp-4],cl11: a = p[1];0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]00401070 8A 42 01 mov al,byte ptr [edx+1]00401073 88 45 FC mov byte ptr [ebp-4],al &emsp;&emsp;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 3.7 小结堆和栈的区别可以用如下的比喻来看出： &emsp;&emsp;使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 &emsp;&emsp;使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 内存分配方面： 堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。 栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 申请方式方面： 堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 系统响应方面： 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 大小限制方面： 堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 效率方面： 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 栈：由系统自动分配，速度较快。但程序员是无法控制的。 存放内容方面： 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 存取效率方面： 堆：是在编译时就确定的； 栈：是在运行时赋值的； char *s1 = "Hello Word"; char s1[] = "Hello Word"; &emsp;&emsp;用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。 四、C++的内存分配方式&emsp;&emsp;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多） 五、内存分配方式引发的概念区别(C)5.1 只读变量和常量下面的例子用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？ 12const int n = 5;int a[n]; 答案与分析: 1）这个问题讨论的是“常量”与“只读变量”的区别。常量肯定是只读的，例如 5， “abc”，等，肯定是只读的，因为程序中根本没有地方存放它的值，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时维度必须是“常量”，“只读变量”也是不可以的。 2）注意：在ANSI C中，这种写法是错误的，因为数组的大小应该是个常量，而const int n,n只是一个变量（常量 != 不可变的变量，但在标准C++中，这样定义的是一个常量，这种写法是对的），实际上，根据编译过程及内存分配来看，这种用法本来就应该是合理的，只是 ANSI C对数组的规定限制了它。 3）那么，在 ANSI C 语言中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。 5.2 指针 和 字符串常量请问下面的代码有什么问题？ 123char *p = "i'm hungry!";p[0]= 'I'; 答案与分析： &emsp;&emsp;上面的代码会造成内存的非法写操作。分析如下， “i’m hungry”实质上是字符串常量，而字符串常量被编译器放在只读的字符常量区内，不可写。指针p初始化，指向这个只读的内存区，是不能修改其中元素值(即存放值)；而p[0] = 'I';则企图修改内存存放值，编译器当然不会答应。 123char *p = "i'm hungry!";p = "I'm hungry!";printf("%s\n",p); &emsp;&emsp;虽说字符串常量(字符常量区)内容不可修改，但指针是变量，可以修改指针p指向的内存位置；即实际上又找了一个新的字符串常量(新申请在字符常量区)。 5.3 字符串数组 和 字符串常量12345char a[15] = "i'm hungry!";char *p = &amp;a;p[0]= 'I';printf("%s\n",p); 答案与分析： &emsp;&emsp;相比较与5.2，由于字符串数组是存放在 栈 或 堆 ，该区是可以修改的，因此对字符串(数组,这里并非常量)的元素可以修改。 5.4 指针 &amp; 内存&emsp;&emsp;往往别人在教指针知识的时候，往往强调指针存放着地址，并举出类似下面的例子： 123int *p;p = (int*)0x12ff7c;printf("%x\n",p); 程序结果如下： 112ff7c &emsp;&emsp;的确是能够打印出来，0x12ff7c是在前面随便打印一个int类型变量的地址获取的。但是如果给这个内存进行赋值操作的话，就会出现 段错误。 12345int *p;p = (int*)0x12ff7c;printf("%x\n",p);*p = 100; &emsp;&emsp;地址和内存是两回事！！！每段内存都有自己的地址，地址映射可以通过指针操作；但是，你无权更改内存存放的值，除非这段内存是 栈 或 堆 分配给你的。需要注意：有地址，没空间(字符常量区也是这样)。 Ps： 如果有地址就能合法操作对应内存空间，那还要什么(手动)内存分配。 六、内存知识的重新总结一个程序分为： 栈区（stack） –编译器自动分配释放，主要存放函数的参数值，局部变量值等； 堆区（heap） –由程序员分配释放； 全局(静态)区 –存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区(.data)和全局未初始化区(.bss)； 字符常量区(.rodata) –常量字符串放与此，程序结束时由系统释放； 程序代码区(.text) 栈 ：(后进先出)栈在程序中用于维护函数的调用上下文；栈保存了一个函数调用所需要的维护信息。 1231)函数参数，函数返回地址2)局部变量3)函数调用上下文 堆：(堆内存需要主动申请)为什么有了栈还需要堆？ 1231)栈上的数据在函数返回后就会被释放掉，无法传递到函数外部，如局部变量(关键原因)2)堆是程序中一块巨大的内存空间，可由程序自由支配3)堆中被程序申请使用的内存在程序主动释放前将一直有效 (全局)静态存储区： 12341)程序的静态存储区随着程序的运行而分配空间，直到程序运行结束2)在程序编译期间静态存储区的大小就已经确定3)程序的静态存储区主要用于保存程序中的全局变量和静态变量4)与栈和堆不同，静态存储区的信息最终会保存在可执行程序中 七、 非法内存操作分析7.1 指针没有初始化进行内存操作12345678910111213141516#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; int* d1; int i=0; for(i=0;i&lt;10;i++)//问题1：不能直接赋值，因为并没有分配内存，也没有初始化。 &#123; d1[i]=i+1; &#125; printf("%d-&gt;%p\n", *(d1+6), d1); return 0;&#125; 编译器1，程序执行的结果如下： 17-&gt;0x7ffeaaf62970 编译器2，程序执行的结果如下： 111 Segmentation fault &emsp;&emsp;这里理所应当地出现两种情况： 出现段错误，则是编译器自动将指针置NULL 编译通过的，则是 野指针 7.2 没有给指针分配足够的内存123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; int *d2; int i=0; d2=(int *)calloc(5,sizeof(int)); for(i=0;i&lt;10;i++)//问题2：只分配了5个空间，却用了10个。 &#123; d2[i]=i+1; &#125; printf("%d-&gt;%p\n", *(d2+6), d2); free(d2); printf("%d-&gt;%p\n", *(d2+6), d2); return 0;&#125; 编译器1，程序执行的结果如下： 127-&gt;0x1b3d010*** Error in `./a.out': free(): invalid next size (fast): 0x0000000001b3d010 *** 编译器2，程序执行的结果如下： 127-&gt;0x16020104113-&gt;0x1602010 &emsp;&emsp;这里会出现free()操作 非法(没有分配)的内存；还有个编译器神奇通过(野指针的恐怖之处)。 7.3 内存分配成功但是没有初始化1234567891011121314#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; char* s=(char*)malloc(5); s[0]='A'; //s[1]='\0'; s[2]='B'; printf("%s\n",s); printf("%p\n",s); free(s); return 0;&#125; 编译器程序执行的结果如下： 12A0x14e5010 &emsp;&emsp;需要注意的是，上面虽然编译通过但是是有问题的。犯这个错误往往是由于没有初始化的概念或者是以为内存分配好之后其缺省初值自然为0。未初始化指针变量也许看起来不那么严重，但是它确确实实是个非常严重的问题，而且往往出现这种错误很难找到原因。(尤其在字库驱动) &emsp;&emsp;内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，但这点在不同的编译器上会有不同的实现。所以好的做法，是手动给数组赋上初值。 &emsp;&emsp;当你只分配内存给字符(串)型指针，并没有缺省初值，严格意义上来讲是不算初始化；有些编译器自然里面都是'\0'，printf打印时，打印出来的数据自然会被其中字符的'\0'截胡。不然可以把上述例子的注释去掉再测试一遍。 也许这种严重的问题并不多见，但是也绝不能掉以轻心。所以在定义一个变量时，第一件事就是初始化。你可以把它初始化为一个有效的值。 7.4 内存(数组)越界数组有两个特性，影响作用在数组上的函数： 不能复制数组； 使用数组名时， 数组名会自动指向其第一个元素的指针。 因为不能复制，所以无法编写使用数组类型的形参，数组会自动转化为指针。123456789101112131415void f(int a[10])//这里面的[10]仅表示我们希望数组是多大；实际没有用处，传入是指针&#123; int i=0; for(i=0;i&lt;10;i++) &#123; a[i]=i; printf("%d\n",a[i]); &#125;&#125;int main()&#123; int a[5]; f(a); return 0;&#125; 编译器程序执行的结果如下： 123456789100123456789 数组作为形参时的一个陷阱：在数组当形参的函数中，使用sizeof来计算传入的实参数组的大小，这种方法是错误的！！！ 因为当数组作为形参的时候，其退化为一个指针，如果sizeof其数组名将计算的是一个指针的大小！ 7.5 内存泄漏1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(unsigned int size)&#123; int* p = (int*)malloc(size*sizeof(int)); int i = 0; if( size % 2 != 0 ) &#123; return; //奇数个size的情况直接跳转，但申请的内存没有free掉；内存泄漏 &#125; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; free(p);&#125;int main()&#123; f(9); f(10); return 0;&#125; 解决方法：当函数申请了内存：采用单入口，单出口程序 1234567891011121314void f(unsigned int size)&#123; int* p = (int*)malloc(size*sizeof(int)); int i = 0; if( size % 2 == 0 ) &#123; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; &#125; free(p);&#125; 7.6 多次释放指针1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(int* p, int size)&#123; int i = 0; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; free(p); //第1次&#125;int main()&#123; int* p = (int*)malloc(5 * sizeof(int)); f(p, 5); free(p); //第2次 return 0;&#125; 多次释放内存的后果，就是强退出 Ps：分配多次完全可以，既然是变量那就是可变的！但是多次释放就是自杀！ 7.7 使用已经释放的内存1234567891011121314151617181920212223//这个和前面的例子有点类似#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(int* p, int size)&#123; int i = 0; for(i=0; i&lt;size; i++) &#123; printf("%d\n", p[i]); &#125; free(p);&#125;int main()&#123; int* p = (int*)malloc(5 * sizeof(int)); int i = 0; f(p, 5); for(i=0; i&lt;5; i++) &#123; p[i] = i; // OOPS! &#125; return 0;&#125; 八、C语言有关内存的规则8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针12345int *p=(int *)malloc(5*sizeof(int));if(p!=NULL)&#123;&#125;free(p); 8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组1234567891011121314typedef struct _soft_array&#123; int len; int array[];&#125;SoftArray;int i=0;SoftArray* sa=(SoftArray*)mallo(sizeof(SoftArray)+sizeof(int)*10);sa-&gt;len=10;for(i=0;i&lt;sa-&gt;len;i++)&#123; sa-&gt;array[i]= i + 1;&#125; 8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放 Ps：可以用if…else…来确定是否释放 123456789101112131415void f()&#123; int *p= (int*)malloc(sizeof(int)); free(p);&#125;int main()&#123; int *p= (int*)malloc(sizeof(int)); f(); free(p); return 0;&#125; 8.4 free指针之后必须赋值为NULL12345678910111213141516int *p=(int*)(malloc(sizeof(int));free(p);p=NULL;//···//······//·········//············if(p!=NULL)&#123; int i=0; for(i=0;i&lt;5;i++) &#123; p[i]=i; &#125;&#125; 九、嵌入式的内存分配&emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用。 &emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做！一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的malloc 与free的使用容易造成内存碎片。当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。 关于更多嵌入式内存分配的知识，可以看这篇博文：Stm32的内存管理(Code,RO-data,RW-data,ZI-data) Ps: 通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>堆栈</tag>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小端和联合体]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、大小端1.1 大小端含义&emsp;&emsp;大端小端的含义可以看这位博主的：轻松记住大端小端的含义(附对大端和小端的解释) 1.2 大端小端哪里用到？&emsp;&emsp;当涉及到数据拆解(例如一个32位数据拆分成两个16位数据来用) 的时候，就需要注意大小端。因为我们一般存数据和取数据都是一个一个或着一组一组，不会涉及到拆分数据，这样就不涉及大小端。 &emsp;&emsp;举个例子，当你有一个int类型的数据，你不是把数据直接取出来，而是把int变量中的一个字节数据提取出来，想做一些类似位操作的操作。当一个数据拆解取出来的时候，就会设计到数据的存储顺序，即大小端。 &emsp;&emsp;但是，由于一般现在所用的cpu基本上是采用的小端模式。基本上，平常撸代码都不会被涉及(影响到)到，因此简单了解一下其概念就行。以下的情况才有可能是被大小端模式影响到： 在(不熟悉的)平台撸代码，用到union之类的语法。发现读写数据出现异常 正常稳定的代码，迁移新的平台。发现读写数据出现异常 二、联合体联合体：使几个不同类型的变量共占一段内存(相互覆盖)。所占内存长度是各最长的成员占的内存长度。结构体：把不同类型的数据组合成一个整体。所占内存长度是各成员占的内存长度的总和。 &emsp;&emsp;由于嵌入式C基本都是用小端模式：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。小端就是我们(平常逻辑)认知的顺序，因此后面(默认小端)不再提及大小端对联合体的影响。 寄存器(联合体和结构体的妙用) 先声明一个结构体 12345678910//结构体中的冒号表示位域//位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节//同时也是为了节省存储空间和方便处理。typedef struct&#123; uint16_t Mode1:1; //Mode1配置占1位 uint16_t Mode2:3; //Mode2配置占3位 uint16_t Mode3:4; uint16_t Mode4:2; //写满16位&#125;Ctl_Bits; 再声明一个联合体 12345union TBCTL_REG&#123; uint16_t all; Ctl_Bits bit;&#125; 可以再申明一个寄存器结构体： 12345typedef struct&#123; union TBCTL_REG TBCTL1; union TBCTL_REG TBCTL2;&#125;PWM_REGS; 这样的话，我就写了一个关于PWM配置的寄存器，例如我现在想改PWM的Mode1为模式1；如下： 123456PWM_REGS PWM1;//整体赋值PWM1.TBCTL1.all |= 0x01;//位赋值PWM1.TBCTL1.bit.Mode1 = 0x01； &emsp;&emsp;理解了这个方法后，再来看样例对寄存器的操作是不是就很轻松了？掌握这个方法以后，你也可以设计一个带全局或者位操作的结构体来完成自己的程序数据的应用了。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>联合体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2020%2F03%2F15%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、关于c语言的结构体&emsp;&emsp;首先我们为什么要用到结构体，我们都已经学了很多int、 char…等类型，还学到了同类型元素构成的数组；以及取上述类型的指针，在一些小应用可以灵活使用。然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。 二、结构体小知识 只有结构体变量才分配地址，而结构体的声明是不分配空间的； 结构体声明，包括了结构体中各成员的声明，因此也不分配空间； c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换 相同类型的成员是可以声明在同一类型下的1234567struct Student&#123; int number,age；//int型学号和年龄 char name[20],sex;//char类型姓名和性别 float score;&#125;；//最后的分号不要忘了 总结：声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。 结构体类型的变量的本质：结构体类型的变量，本质上是一个变形的数组。 不同点：结构体不要求元素类型一样，要用的时候，不是以数组下标，而是特定指向(.或->)该成员来 处理（例如赋值）； 相同点： 结构体和数组在定义的时候不进行初始化赋初值，则后面就不能全部赋初值，需逐个赋值； 进行 数组、结构体变量 初始化的时候，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋初值前面几个； 进行 数组、结构体变量 初始化的时候，对于未初始化(后半段)的数据：如果是数值型，则会自动赋值为 0 ；如果是字符型，会自动赋初值为 NULL ，即\0 ；即不足的元素补以默认值； 函数的传入参数(形参)是结构体、数组，均采用指针传递的方式123456789typedef struct &#123; char name[20]; char sex; int number;&#125;Student；Student stu1=&#123;"zhaozixuan",'M'&#125;;int str[10]=&#123;1&#125;;//这里只是把str的第一个元素赋值为1，其他元素默认为0 &emsp;&emsp;这里要强调的一点是， “变量赋值” 和 “变量初始化(赋初值)”不是一回事！给(全局)变量初始化，定义时后跟等号，等号后面是初始化值。赋初值只会在定义的时候进行赋初始化值，其余地方都是赋值。 赋初值 和 赋值 的区别 赋值运算，函数体外是不允许的；而赋初值没有该要求，可在函数体外定义赋初值。 赋初值，可以初始化所有成员；赋值，只能对逐个成员进行赋值，无法一次性对全体成员进行赋值。(举例：数组、结构体) 三、结构体变量的定义和引用3.1 结构体类型的变量&emsp;&emsp;在编译时，结构体的声明并不分配存储空间；声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样；只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。 123456789 struct Book &#123; char title[20];//一个字符串表示的titile 题目 char author[20];//一个字符串表示的author作者 float value;//价格表示 &#125;;//这里只是声明 结构体类型struct Book book1,book2;//结构体变量的定义 分配空间book1.value;//引用结构体变量 &emsp;&emsp;定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。 3.2 结构体空洞&emsp;&emsp;用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍；比方说我们上面求得的为44 为 float(4个字节)的整数倍，但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48(4的整数倍)。 这就涉及到结构体的存储： 结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍； 结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍(一般是int,4字节)，如果不是编译器会自动补齐； &emsp;&emsp;在结构体分配空间时，如果结构体中出现4个字节(32位)及以上的变量时，给每个变量分配空间时都是按字对齐分配的(就是按4个字节，4个字节来分配)；如果结构体中没有出现4个字节以上变量，则按半字对齐(按 2个字节，2个字节。。来分配)。&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储(字对齐或双字对齐等)。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。&emsp;&emsp;看来鱼与熊掌还是不能兼得啊。既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单地(手动计算)相加。因为他们中间存在空洞。 关于偏移量，简单介绍下： 结构体偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小；第一个成员的偏移量为0。 123456struct S1&#123; char a; int b; double c;&#125;; 这里 char a 偏移量为 1 之后为 int b 因为偏移量 1 不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为 8 是int(4)的整数倍，所以不用自动补齐，最后求得结构体得大小为 16。 四、结构体变量的初始化&emsp;&emsp;结构体的初始化有很多需要注意的地方，这里我们说明下，首先是几种初始化的方法。 Ps： 在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对于后面未赋值的变量，如果是数值型，则会自动赋值为0；对于字符型，会自动赋初值为 NULL ，即 \0 。 4.1 定义时直接赋值(变量初始化)1234567891011121314struct Student&#123; char name[20]; char sex; int number;&#125;stu1=&#123;"zhaozixuan",'M',12345&#125;;//或者struct Student&#123; char name[20]; char sex; int number;&#125;；struct Student stu1=&#123;"zhaozixuan",'M',12345&#125;; 注意： 字符为 ' ' ，字符串为 " " 4.2 定义结构体之后逐个赋值1234567//赋值操作均在函数内操作stu1.name="王伟"；stu1.sex='M';stu1.number=12305;//也可用strcpy函数进行赋值strcpy(stu1.name,"王伟"); 4.3 定义之后任意赋值12345struct Student stu1=&#123; .name="Wang", .number=12345, .sex='W', &#125;;//可以对任意变量赋值 &emsp;&emsp;这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值。&emsp;&emsp;需要注意的是，如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了。(数组性质) 4.4 typedef 说明结构体类型&emsp;&emsp;typedef 为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。 12345typedef struct tagMyStruct //这里也可以不写tagMyStruct&#123; int iNum; long lLength;&#125;MyStruct; &emsp;&emsp;上面的tagMyStruct是标识符，MyStruct是变量类型(相当于 int , char 等)。 这语句实际上完成两个操作： 定义一个新的结构类型 12345struct tagMyStruct&#123; int iNum; long lLength; &#125;; 分析：tagMyStruct 称为“tag”，即“标签”，实际上是一个临时名字，不论是否有 typedef struct 这个关键字 和 tagMyStruct 一起，构成了这个结构类型，这个结构都存在。我们可以用 tagMyStruct varName 来定义变量；但要注意，使用 tagMyStruct varName 来定义变量是不对的，因为 struct 和 tagMyStruct 合在一起才能表示一个结构类型。 typedef为这个新的结构起了一个名字，叫MyStruct。 1typedef struct tagMyStruct MyStruct; &emsp;&emsp;因此，MyStruct实际上相当于 struct tagMyStruct ，我们可以使用 MyStruct varName 来定义变量。 12345typedef struct tagMyStruct&#123; int iNum; long lLength;&#125;MyStruct; 在C中，这个申明后申请结构变量的方法有两种：(1) struct tagMyStruct 变量名(typedef声明时可省略tagMyStruct，省略后则无法使用该方法定义结构变量)(2) MyStruct 变量名(一般采用该方法) 五、结构体变量的引用(结构体成员) 结构体类型 声明定义的是 普通变量，普通变量 访问成员时就用 . 结构体类型 声明定义的是 指针 ，指针 访问成员时就用 -> Ps： 若使用指针对结构体成员进行访问，格式为：指针-&gt;成员名 等价于 (*指针).成员名 但是有几点需要注意：(1) .是运算符，在所有运算符优先级中最高(2)如果结构体的成员本身是一个结构体，则需要继续用.运算符，直到最低一级的成员。 12345678910111213141516typedef struct &#123; char name[20]; char sex; int number; struct Date &#123; int year; int month; int day; &#125;birthday;&#125;Student;Student Stu1;//定义结构体变量printf("%d",stu1.birthday);//这样子是错误的，因为birthday也是一个结构体变量scanf("%d",&amp;stu1.birthday.month);//正确 六、结构体数组及其初始化(重点)&emsp;&emsp;这里我们简单说下，具有相同类型的结构体变量组成数组就是结构体数组。反而言之，是指数组中的每个元素都是一个结构体。在实际应用中，结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。 123456789101112struct Student&#123; char name[20]; char sex; int number;&#125;stu1[5]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;, &#123;"wangwei",'M',14679&#125;, &#123;"yulongjiao",'W',17857&#125;&#125;; 当对结构体数组中全部元素赋值时，也可不给出数组长度，例如： 123456789101112struct Student&#123; char *name;//指针类型指向字符串 char sex; int number;&#125;stu1[]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;, &#123;"wangwei",'M',14679&#125;, &#123;"yulongjiao",'W',17857&#125;&#125;; Ps：在上面的Tip提到，结构体是一个变形的数组；结构体数组，其实就是变形的二元数组；数组的性质同样也是存在：结构体数组要在定义时就直接初始化赋值，不然后面再全部赋值是错误的。 1234567891011121314//错误的示例struct Student stu1；stu1[3]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;&#125;; //正确的示例 struct Student stu1[]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;&#125;; 数组初始化 1234567891011//错误示范char str[20];str="I love you"; //这样会修改数组的地址，原因如下//数组初始化后，地址分配是固定的，数组名是(符号)地址常量；常量没有(可写的)内存空间存你要赋的值//因此数组名不能作为左值//所以我们可以把str[i]当左值，而无法把str当左值。//正确示范char *str;str="I love you"; &emsp;&emsp;在第一条语句中 str 就已经被定义成数组，而在C99标准中不允许将字符串(实际上是一个指针变量)赋值给数组(左值)，所以如果我们直接赋值是错误的。 注意区分声明时的初始化和普通的赋值语句！！！ 赋值运算 &emsp;&emsp;赋值运算，分为左值和右值。 左值：可以出现在赋值语句的左边或右边，它不光有值，还有一个存储地址； 右值：只能出现在赋值语句的右边，认为它只有一个值的大小，没有存储地址，只关心它的值(字符串常量则是存在字符常量区，只可读不可写)。 数组名不可能作为左值！数组名不是指针！ &emsp;&emsp;那么数组名应该如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。 &emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。 &emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！ 这里提供数组赋(字符串)值的3种方法： 定义数组时直接定义 1char str[20] = "I love you"; 用strcpy进行复制 12char str[20];strcpy(str,“I love you”); 用memset进行复制 123//memset&lt;/code&gt;语法介绍void *memset(void *s,int c,size_t n)//作用：将已开辟内存空间s的首n个字节的值设为值c。 3.1 如果是字符类型数组的话，memset可以随便用，如下所示： 12char str[20];memset(str,'a',20); 3.2 但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错，如下所示： 12int str[10];memset(str,1,sizeof(str));//这样是错误的 3.3 错误分析 - &lt;code&gt;memset&lt;/code&gt;在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节； - 对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40； - 用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作；**把0x00000000赋值4次0x01操作变为&lt;code&gt;0x01010101&lt;/code&gt;**(错误主要原因)； - 相当于给 “(所有)10个int” 进行了赋值&lt;code&gt;0x01010101&lt;/code&gt;的操作 对应十进制的16843009，所以会出很大的错误。 用指针（注意内存分配方式） 12char *str；str = "I love you"; &emsp;&emsp;这两句话的本质是， 在内存中开辟一段内存空间(字符常量区)，把"I love you"放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量(栈 或 堆)，所以给它赋值(地址，指向的内容)是合法的。 memset用法总结：如果是清零一个数组用memset还是很方便的；简单赋字符串值，用strcmp函数(或memset)就行。 七、结构体与指针&emsp;&emsp;指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素。 7.1 指向结构体变量的指针12345678struct Student&#123; char cName[20]; int number; char csex; &#125;student1;struct Student *p;p=&amp;student1; 简单来说以下三种形式是等价的 123p-&gt;cName //可以进行正常的运算(*p).cName //这里的括号不能少，.运算符优先级最高student1.cName &emsp;&emsp;这里需要注意的是，结构体访问成员方式和数组访问成员方式有些差别。 即使*p访问到了结构对象的第一个成员变量a，也不能保证*(p+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 (用sizeof作为偏移量访问下一个成员要注意一下结构体空洞吖！) 7.2 指向结构体数组的指针&emsp;&emsp;在我们想要用指针访问结构体数组的第n个数据时可以用 12345678910struct Student&#123; char cName[20]; int number; char csex; &#125;;struct Student stu1[5];struct Student*p;p=stu[n];(++p).number//是指向了结构体数组下一个元素的地址 7.3 结构体成员是指针类型变量123456struct Student&#123; char* Name;//这样防止名字长短不一造成空间的浪费 int number; char csex; &#125;student1; 在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的(野指针)，但是Name会被分配到任意的一地址，指针为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险。 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu，*stu；stu.name=(char*)malloc(sizeof(char));//内存初始化 所对应的指针类型结构体成员要相应初始化分配内存 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu,*stu;stu = (struct student*)malloc(sizeof(struct student));./*结构体指针初始化*/stu-&gt;name = (char*)malloc(sizeof(char));/*结构体指针的成员指针同样需要初始化*/ &emsp;&emsp;实际上，结构体指针、结构体成员指针就是指针，没有区别；只不过结构体成员指针容易被忽略初始化。而指针的初始化是很重要的，详情可以看 野指针一章的内容。 7.4 结构体嵌套的问题结构体的自引用(self reference)，就是在结构体内部，包含指向自身类型结构体的指针。结构体的相互引用（mutual reference），就是说在多个结构体中，都包含指向其他结构体的指针。 7.4.1 自引用 结构体 不使用 typedef 错误的方式：1234struct tag_1&#123; struct tag_1 A; int value;&#125;; &emsp;&emsp;这种声明是错误的，因为这种声明实际上是一个无限循环，成员A是一个结构体，A的内部还会有成员是结构体，依次下去，类似于永无出口的递归调用。在分配内存的时候，由于无限嵌套，也无法确定这个结构体的长度，所以这种方式是非法的。 正确的方式：(使用指针)1234struct tag_1&#123; struct tag_1 *A; int value;&#125;; &emsp;&emsp;由于指针的长度是确定的（在32位机器上指针长度为4），所以编译器能够确定该结构体的长度。 Ps：这个指针看似指向自身，其实不是，而是指向同一类型的不同结构。链表和树的数据结构就都使用到此技巧。自身的结构体指针指向下一节点或者下一子树的地址。 使用 typedef 错误的方式：1234typedef struct &#123; int value; NODE *link; &#125;NODE; &emsp;&emsp;这里的目的是使用typedef为结构体创建一个别名NODE。但是这里是错误的，因为此时还没定义完类型名，而在结构体内部引用了结构类型名，是非法的。 正确的方式：(使用不完全声明)有三种，差别不大，使用哪种都可以123456789101112131415161718typedef struct tag_1&#123; int value; struct tag_1 *link; &#125; NODE;//虽然 C 语言编译器完全支持这种做法，但不推荐使用以下的第2种typedef struct tag_2 NODE;struct tag_2&#123; int value; NODE *link; &#125;;//建议使用以下的第3种struct tag_3&#123; int value; struct tag_3 *link; &#125;;typedef struct tag_3 NODE; 7.4.2 相互引用 结构体 错误的方式：123456789typedef struct tag_a&#123; int value; B *bp; &#125;A;typedef struct tag_b&#123; int value; A *ap;&#125;B; &emsp;&emsp;错误的原因和上面一样，这里类型B在定义之前 就被使用。 正确的方式：(使用不完全声明)1234567891011121314151617181920212223242526//推荐使用第一种struct tag_a&#123; struct tag_b *bp; int value;&#125;;struct tag_b&#123; struct tag_a *ap; int value;&#125;;typedef struct tag_a A;typedef struct tag_b B;struct tag_a; struct tag_b;typedef struct tag_a A;typedef struct tag_b B;struct tag_a&#123; struct tag_b *bp; int value;&#125;;struct tag_b&#123; struct tag_a *ap; int value;&#125;; 7.5 结构体作为函数参数(形参)将结构体传递给函数的方式有如下3种： 用结构体的单个成员作为函数参数，向函数传递结构体的单个成员（属于传值调用，不会影响相应的实参结构体的值） 用结构体变量做函数参数，向函数传递结构体完整结构（属于传值调用，不会影响相应的实参结构体的值） 用结构体指针或结构体数组作函数参数属于模拟按引用调用，会影响相应的实参结构体的值,向函数传递结构体地址，因为仅复制结构体首地址一个值给被调函数，相对于第二种方式，这种传递效率更高 补充：传值调用与模拟按引用调用（参数传递） 按值调用：将程序将函数调用语句中的实参的一份副本传给函数的形参模拟按引用调用：指针作为函数的参数，虽然实际上也是传值给被调用函数，但是传给被调用函数的这个值不是变量的值，而是变量的地址，通过向被调用函数传递某个变量的地址值可以在被调函数中改变主调函数中这个变量的值，相当于模拟C++中的按引用调用因此称为模拟按引用调用 &emsp;&emsp;使用结构体变量作为函数参数的时候，是采取传值调用，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，效率较低。且无法修改实际的结构体变量中成员的值。 &emsp;&emsp;如果用指针作为实参，传递给函数的形参，这时候传递的是结构体变量的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的(这正是指针的精华所在)。 7.6 结构体的一些小技巧7.6.1 互换结构体在这里我们再提供几种互换两个结构体的方法： 结构体指针互换地址 直接互换值(同类型结构体) 比较笨的方法：用for循环互换123456789101112131415161718192021222324typedef struct Student&#123; char cName[20]; int number; char csex; &#125;Student;Student student1=&#123;"Wang",12345,'W'&#125;;Student student2=&#123;"Zhao",54321,'M'&#125;; Student *stu1=&amp;student1;Student *stu2=&amp;student2;//法1Student *stu3;stu3=stu1;stu1=stu2;stu2=stu3;//法2struct stu student3;student3=student1;student1=student2;student2=student3; 7.6.2 meset的妙用&emsp;&emsp;最后提下memset清空结构体： 123456struct Student&#123; char cName[20]; int number; char csex; &#125;stu1; 一般情况下，清空str的方法： 123 str.cName[0]='\0'; str.csex='0'; str.number=0; 但是我们用memset就非常方便： 1memset(&amp;str,0,sizeof(struct Student)); 如果是数组，就是： 12struct Student stu[10];memset(stu,0,sizeof(struct Student)*10); 八、拓展(待写)二叉树遍历算法二叉树的二叉链表类型定义如下： 1234typedef struct btnode&#123; datatype data; struct btnode *lchild,*rchild;&#125;； 九、友情链接多亏主要如下几位网友的资料结构体嵌套中的问题c语言结构体学习整理(结构体初始化，结构体指针)结构体中定义函数指针结构体（结构体嵌套、结构体指针、结构体参数传递）]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体的洞和 #pragma pack]]></title>
    <url>%2F2020%2F03%2F15%2F%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B4%9E%E5%92%8C-pragma-pack%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、结构体中的“洞”&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。看来鱼与熊掌还是不能兼得啊。 &emsp;&emsp;既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单的相加。因为他们中间存在空洞。 二、#pragma pack&emsp;&emsp;这是给编译器用的参数设置，有关结构体字节对齐方式设置， #pragma pack是指定数据在内存中的对齐方式。 1234567#pragma pack (n) //作用：C编译器将按照n个字节对齐。#pragma pack () //作用：取消自定义字节对齐方式。#pragma pack (push,1)//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐#pragma pack(pop)//作用：恢复对齐状态 #pragma pack(push,1)与#pragma pack(1)的区别 &emsp;&emsp;因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优。但是很多时候两者差别不大，如： 1234#pragma pack(push) //保存对齐状态#pragma pack(4) //设定为4字节对齐//相当于 #pragma pack (push,4) 具体的使用方法如下： 1234#pragma pack (1) //结构体内容#pragma pack ()//作用：调整结构体的边界对齐，让其以一个字节对齐；&lt;使结构体按1字节方式对齐&gt; 具体例子如下： 1234567#pragma pack(1)struct sample&#123; char a; double b;&#125;;#pragma pack() &emsp;&emsp;注：若不用#pragma pack(1)和#pragma pack()括起来，则sample按编译器默认方式对齐（成员中size最大的那个）。即按8字节（double）对齐，则sizeof(sample)==16.成员char a占了8个字节（其中7个是空字节）；若用#pragma pack(1)，则sample按1字节方式对齐sizeof(sample)＝＝9.（无空字节），比较节省空间啦。在有些场合还可使结构体更易于控制。 三、应用实例&emsp;&emsp;在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法来得到各种信息，但这样做不仅编程复杂，而且一旦协议有变化，程序修改起来也比较麻烦。 &emsp;&emsp;在了解了编译器对结构空间的分配原则之后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。这样做，不仅简化了编程，而且即使协议发生变化，我们也只需修改协议结构的定义即可，其它程序无需修改，省时省力。下面以TCP协议首部为例，说明如何定义协议结构。其协议结构定义如下： 123456789101112131415161718192021#pragma pack(1) // 按照1字节方式进行对齐struct TCPHEADER &#123; short SrcPort; // 16位源端口号 short DstPort; // 16位目的端口号 int SerialNo; // 32位序列号 int AckNo; // 32位确认号 unsigned char HaderLen : 4; // 4位首部长度 unsigned char Reserved1 : 4; // 保留6位中的4位 unsigned char Reserved2 : 2; // 保留6位中的2位 unsigned char URG : 1; unsigned char ACK : 1; unsigned char PSH : 1; unsigned char RST : 1; unsigned char SYN : 1; unsigned char FIN : 1; short WindowSize; // 16位窗口大小 short TcpChkSum; // 16位TCP检验和 short UrgentPointer; // 16位紧急指针&#125;; #pragma pack() &emsp;&emsp;这样的代码编译出来的是以1个字节的方式对齐的。这样能节约内存资源，但是会在效率上有所影响。 &emsp;&emsp;虽说在效率上有一定的影响，不过，如果编写的是基于协议，如网口、串口通讯的程序，最好严格按照一定的规则进行接收数据包。使用 #pragma pack(1)，让数据在内存中是连续的，实现结构体通过指针偏移(没有空洞)比较好处理。 &emsp;&emsp;用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。 &emsp;&emsp;也就是如果用编译器的(自动)对齐策略，采用指针偏移方式的方法可能会出现一些(不同编译器，对齐不同，错位)问题。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>结构体</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于函数指针的 强制转换 & void指针]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-void%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、大佬链接 和 结论&emsp;&emsp;下面链接是这篇博文的主力大佬，我只是润润色。函数指针的强制类型转换与void指针关于函数指针类型强制转换的一些摸索 先说结论： 函数指针的指针参数只是一个标记，总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。 换一种说法，函数指针中的形参最后使用的效果只由函数指针指向的实际函数的形参类型决定，中间处理过程只是作为一个没有类型的32位或者16位二进制数来处理。效果跟函数指针申明的形参没有多大关系。 我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参保持一致。 二、 常见的情况2.1 函数指针常见用法123456789101112131415161718#include "stdio.h"/* 真实函数fun_int */void fun_int(int *p_fun)&#123; printf("整数:%d\n", *p_fun);&#125;int main()&#123; int i = 200; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ void (*f_ptr)(int *p_fun); /* 函数指针 */ f_ptr = fun_int; /* 函数指针赋值 */ f_ptr(p_i); return 0;&#125;c 运行结果如下： 1整数:200 &emsp;&emsp;总之就是，定义一个包含返回值类型和参数的函数指针，然后把一个返回值类型，参数类型及个数都相同的函数名（即地址）赋值给这个函数指针，这个函数指针就可以当成普通函数用了。 2.2 函数指针强制类型转换&emsp;&emsp;此处只展示一种情况：函数指针和真实函数的返回值及参数个数都相同，只有参数类型不同。 12345678910111213141516171819202122#include "stdio.h"/* 真实函数fun_float */void fun_float(float *p_fun)&#123; printf("小数:%f\n", *p_fun);&#125;int main()&#123; int i = 20000; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ float f = 9.999f; /* 真实浮点变量 */ float* p_f = &amp;f; /* 浮点指针 */ void (*f_ptr)(int *p_fun); /* 函数指针 */ f_ptr = (void (*)(int *))fun_float; /* 函数指针强制类型转换 */ f_ptr(p_i); /* 传入int指针 */ f_ptr((int *)p_f); /* 传入float指针 */ return 0;&#125; 运行结果如下： 12小数:0.000000小数:9.999000 &emsp;&emsp;此时我们可以发现一件有趣的事情：尽管函数指针f_ptr的参数是int，但传入的int指针打印数据不正常（正常为20000），而类型不匹配的float指针却是对的（9.999）。 对此我总结了两点： 函数指针的指针参数只是一个标记（或者说只是一个保存指针的地址？），总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。 我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参个数保持一致。 2.3 以void指针作为参数的函数指针&emsp;&emsp;结合之前的结论，在函数指针中包含指针参数时，都可以用void指针进行替代（如果类型很明确就另当别论，直接写）。 123456789101112131415161718192021222324252627282930#include "stdio.h"/* 真实函数fun_int */void fun_int(int *p_fun)&#123; printf("整数:%d\n", *p_fun);&#125;/* 真实函数fun_float */void fun_float(float *p_fun)&#123; printf("小数:%f\n", *p_fun);&#125;int main()&#123; int i = 20000; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ float f = 9.999f; /* 真实浮点变量 */ float* p_f = &amp;f; /* 浮点指针 */ void (*f_ptr)(void *p_fun); /* 函数指针 */ f_ptr = (void (*)(void *))fun_int; /* 强制为void* */ f_ptr(p_i); f_ptr = (void(*)(void *))fun_float; /* 强制为void* */ f_ptr(p_f); return 0;&#125; 运行结果如下： 12整数:20000小数:9.999000 &emsp;&emsp;如此一来，只需要在函数指针赋值时进行强制类型转换就可以适应不同的真实函数。在调用时只要保证以void指针作为参数的函数指针结论中的第2点(形参个数保持一致)即可。 三、参数个数不同的函数指针&emsp;&emsp;这一块的知识简单了解一下就行。太内核了，从外面看就是玄学。 3.1 “运气”例子代码如下： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; typedef void (*F1)(int, int);typedef void (*F2)(int); void ff1(int a, int b)&#123; printf("ff1\n"); printf("%d,%d\n", a, b);&#125; void ff2(int a)&#123; printf("ff2\n"); printf("%d\n", a);&#125;int main()&#123; F1 f1 = (F1)ff2; f1(1,2); F2 f2 = (F2)ff1; f2(3); return 0;&#125; = =本人运行结果如下： 1234ff21ff13,2147483646 原本例子的运行结果如下： 1234ff21ff13,2 &emsp;&emsp;从运行结果中可以看到，当函数ff2被强制转换成一个F1类型的函数后，ff2的形参a的取值为F1类型函数的第一个形参的值，这里说明程序在执行的时候，如果该函数为一个只有n个形参的函数，如果你传递给他m个形参（n&lt;=m）,则该函数只会使用前n个形参。至于这里为什么可以允许这样的操作，后面将试探的分析一下。 &emsp;&emsp;接着，我们试图把一个ff1类型的函数，强制转换为一个F2类型的函数，并执行，执行结果还是在上面的图中，可以看到函数ff1的运行结果为3，2。 &emsp;&emsp;问题来了，我明明只传递给ff1这个函数1个参数，但为什么编译器没报错？虽然类型经过了强制转换，也许可以骗过编译器，但是在执行的时候，明明少了一个参数，程序执行的时候为什么也不报错？而且第二个参数的值还比较诡异，从打印的情况看，第二个参数为2，该值正是调用ff2的时候传递的第二个参数，该参数没被ff2处理，这里却被ff1处理，神马情况？ 3.2 测试”运气”&emsp;&emsp;首先，有一点，当每个函数被调用时，都被赋予了相对独立的栈空间，当该函数的生命周期结束后，该栈空间同时也被回收。 &emsp;&emsp;这样，当我们的main函数执行后，main函数有一个栈空间，假设为mem_A。那么根据上述实验结果，我这里有一个猜想，关于函数的参数是如何实现传递的。我的猜想是这样的，main函数在mem_A的栈空间中单独保留了一块类存给参数传递使用，假设该类存空间为mem_B。当一个函数运行时，程序把需要传递的参数按照顺序，放置在mem_B中，且每次都是从头开始放置。 &emsp;&emsp;回到刚刚的实验中，当ff2被执行后，mem_B中应该存放着0x00000001和0x00000002，这时再执行ff1，由于这里把ff1强制转换成了只含有一个形参的函数，所以当我们只传递给ff1一个参数3时，mem_B中应该存放着0x00000003和0x00000002，这样，ff1调用的结果可以符合以上输出结果，这里为了确定这样的结果不是巧合，又进行了数次实验，均与以上猜想相符。按照以上猜想，如果ff1先执行，ff2后执行，则ff1的第二个参数应该为一个随机数，为了验证该想法，又进行了如下实验。 其他代码都一样，就是把两个函数的执行顺序掉了一下顺序，输出结果下： 12345678910int main()&#123; F2 f2 = (F2)ff1; f2(3); F1 f1 = (F1)ff2; f1(1,2); return 0;&#125; 本人和原例运行类似，结果如下： 1234ff13,-417232744ff21 &emsp;&emsp;也就是说，现在的编译器则是另外开辟栈空间。由于是另外开辟的情况，无法验证第二位博主的： 参数的存储是以4字节为一个存储单元的，也就是说当一个char类型的变量作为参数传递，在mem_B中占的内存大写依旧为4字节。 3.3 (无卵用)总结&emsp;&emsp;由于不能复现之前博主的情况，也无法确定他的结论。但是也有发现： 12345678910int main()&#123; F1 f1 = (F1)ff2; f1(1,2); F2 f2 = (F2)ff1; f2(3); return 0;&#125; 本人运行结果如下： 1234ff21ff13,2147483646 &emsp;&emsp;无论如何改动f1中的第二个参数，最后打印的随机值都不会发生变化。但是如果更换成ff2先执行，ff1后执行，该值就会随着f1中的第二个参数变化而变化。 简单分析，按照程序执行顺序： 如果先执行：多形参的函数；会多开辟多的栈空间，但是由于被强转为单形参，另外一个形参值则为一个随机值。后面执行单形参函数，开辟的栈小，多出来的形参会影响到之前双形参的栈空间存放值。 如果先执行：单形参函数；实际的栈开辟小，打印出来的随机值则不受第二个形参输入的影响(不是明确关系，值波动很大)。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>强制转换</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数（函数指针）]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、函数指针的概念1.1 什么是函数指针&emsp;&emsp;如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。 函数指针 和 函数名 本质上是一样的，都是指向函数调用地址的指针； 只是 函数名 是常量指针，函数指针 是变量指针。 1.2 如何定义函数指针&emsp;&emsp;那么这个指针变量怎么定义呢？ 虽然同样是指向一个地址，但指向函数的指针变量和指向变量的指针变量的定义方式是不同的。例如： 1int(*p)(int, int); &emsp;&emsp;这个语句就定义了一个指向函数的指针变量p。首先它是一个指针变量，所以要有一个“*”，即（*p）；其次前面的 int 表示这个指针变量可以指向返回值类型为int型的函数；后面括号中的两个int表示这个指针变量可以指向有两个参数且都是int型的函数。所以合起来这个语句的意思就是：定义了一个指针变量p，该指针变量可以指向返回值类型为int型，且有两个整型参数的函数。p的类型为int(*)(int，int)。 所以函数指针的定义方式为： 函数返回值类型 (* 指针变量名) (函数参数列表); “函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数； “函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。 1.3 注意要点 函数指针定义时，(*指针变量名)”两端的括号不能省略 &emsp;&emsp;我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（*指针变量名）”。但是这里需要注意的是：“(*指针变量名)”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数(指针函数)。 如何判断 指针变量 是 指向 变量 还是 函数 ？ 首先看变量名前面有没有“*”，如果有“*”说明是指针变量； 其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量； 最后需要注意的是，指向函数的指针变量没有 ++ 和 – 运算。 二、举例&emsp;&emsp;函数指针怎么用？ 2.1 调用例子要点分为两个: 指针 赋值 为函数地址： 函数指针是需要把一个函数的地址赋值给它，有两种写法： 12fun = &amp;Function；fun = Function; 取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。 调用 函数指针： 调用函数指针的方式也有两种： 12x = (*fun)();x = fun(); &emsp;&emsp;调用函数的写法(*func)()、func()均可；而我们大多数情况下都会写成前者(看上去和普通的函数调用没啥区别)，应该是（C/C++标准制定者）为了方便大家对函数的调用。如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。 简单例子 123int Func(int x); /*声明一个函数*/int (*p) (int x); /*定义一个函数指针*/p = Func; /*将Func函数的首地址赋给指针变量p*/ 赋值时函数 Func 不带括号，也不带参数。 由于函数名Func代表函数的首地址，因此经过赋值以后，指针变量 p 就指向函数 Func() 代码的首地址了。 2.2 实际例子1234567891011121314151617181920212223242526# include &lt;stdio.h&gt;int Max(int, int); //函数声明int main(void)&#123; int(*p)(int, int); //定义一个函数指针 int a, b, c; p = Max; //把函数Max赋给指针变量p, 使p指向Max函数 printf("please enter a and b:"); scanf("%d%d", &amp;a, &amp;b); c = (*p)(a, b); //通过函数指针调用Max函数 printf("a = %d\nb = %d\nmax = %d\n", a, b, c); return 0;&#125;int Max(int x, int y) //定义Max函数&#123; int z; if (x &gt; y) &#123; z = x; &#125; else &#123; z = y; &#125; return z;&#125; 输出结果是： 1234please enter a and b:3 4a = 3b = 4max = 4 三、函数指针的优点&emsp;&emsp;有的通用函数中要涉用到另一个函数，但函数名称未定，是让用户编的，当然要做成函数指针，即API（application programming interface，应用编程接口）。函数指针的优点，其实就是函数指针的应用：回调函数 回调函数，本质上都是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。 举例1 &emsp;&emsp;别人给你的不是源代码，是一个已经编译好的模块，并且不会给你源代码，那是商业机密，留给你一个接口，你把你要执行的代码以回调函数的形式交给这个接口，由别人编写的模块在需要的时候调用。 举例2 &emsp;&emsp;进行通用定积分计算，被计算函数是待定的，是由调用者确定的函数，这也得是函数指针。 四、回调函数&emsp;&emsp;对指针的应用是C语言编程的精髓所在，而回调函数就是C语言里面对函数指针的高级应用。简而言之，回调函数是一个通过函数指针调用的函数。 函数指针和函数名本质上是一样的，都是指向函数调用地址的指针； 只是函数名是常量指针，函数指针是变量指针。 4.1 回调函数的定义&emsp;&emsp;把函数指针（函数的入口地址）传递给另一个函数(的形参)，当这个函数指针被用来调用它所指向的函数时，我们就说这个函数是回调函数。 4.2 回调函数的意义(简易) 其他情况：当一个函数要调用另外一个函数，直接在函数体调用对应的函数； 回调情况：当一个函数要调用另外一个函数，将另外函数的指针作为形参，当需要调用对应函数时，调用指针进而可调用对应函数。 &emsp;&emsp;很多朋友可能会想，为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。 &emsp;&emsp;要回答这个问题，我们先来了解一下回到函数的好处和作用：那就是解耦。对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。 &emsp;&emsp;当你在库函数传入其他函数指针，只要函数指针的函数类型相同，就能做到改动函数指针指向的函数功能，而且还不影响传入(函数)指针形参的库函数(不需要改动)。甚至你可以调用同类型的函数指针 传入 库函数。(例如多驱动，Uart4和Uart5两个串口驱动，只要传入函数指针变动传入指针就行)。 4.3 回调函数的意义(深入)&emsp;&emsp;函数指针的语法理解上并不难，难就难在对函数指针实现设计模式和设计方法上的运用。 原因在于，难的不是函数指针的概念和语法本身，而是在什么时候，什么地方该使用它。函数指针不仅是语法上的问题，更重要的是它是一个设计范畴。真正的高手当然不单应该懂得语法层面上的技巧，更应该懂得设计上的方法。不懂设计，能算高手吗？怀疑我在夸大其辞吗？那我们先看看函数指针与哪些设计方法有关： 与分层设计有关。分层设计早就不是什么新的概念，分层的好处是众所周知的，比较明显好处就是简化复杂度、隔离变化。采用分层设计，每层都只需关心自己的东西，这减小了系统的复杂度，层与层之间的交互仅限于一个很窄的接口，只要接口不变，某一层的变化不会影响其它层，这隔离了变化。 分层的一般原则是，上层可以直接调用下层的函数，下层则不能直接调用上层的函数。这句话说来简单，在现实中，下层常常要反过来调用上层的函数。比如你在拷贝文件时，在界面层调用一个拷贝文件函数。界面层是上层，拷贝文件函数是下层，上层调用下层，理所当然。但是如果你想在拷贝文件时还要更新进度条，问题就来了。一方面，只有拷贝文件函数才知道拷贝的进度，但它不能去更新界面的进度条。另外一方面，界面知道如何去更新进度条，但它又不知道拷贝的进度。怎么办？常见的做法，就是界面设置一个回调函数给拷贝文件函数，拷贝文件函数在适当的时候调用这个回调函数来通知界面更新状态。 与抽象有关。抽象是面向对象中最重要的概念之一，也是面向对象威力强大之处。面向对象只是一种思想，大家都知道，用C语言一样可以实现面向对象的编程。这可不是为了赶时髦，而是一种实用的方法。如果你对此表示怀疑，可以去看看GTK+、linux kernel等开源代码。 接口是最高级的抽象。在linux kernel里面，接口的概念无处不在，像虚拟文件系统(VFS)，它定义一个文件系统的接口，只要按照这种接口的规范，你可以自己开发一个文件系统挂上去。设备驱动程序更是如此，不同的设备驱动程序有自己一套不同的接口规范。在自己开发设备开发驱动程序时，只要遵循相应的接口规范就行了。接口在C语言中如何表示？很简单，就是一组函数指针。 与接口与实现分开有关。针对接口编程，而不是针对实现编程，此为《设计模式》的第一条设计准则。分开接口与实现的目标是要隔离变化。软件是变化的，如果不能把变化的东西隔离开来，导致牵一发而动全身，代价是巨大的。这是大家所不愿看到的。 C语言既然可以实现面向对象的编程，自然可以利用设计模式来分离接口与实现。像桥接模式、策略模式、状态模式、代理模式等等，在C语言中，无一不需要利用函数指针来实现。 与松耦合原则有关。面向过程与面向对象相比，之所以显得苍白无力，原因之一就是它不像面向对象一样，可以直观的把现实模型映射到计算机中。面向过程讲的是层层控制，而面向对象更强调的对象间的分工合作。现实世界中的对象处于层次关系的较少，处于对等关系的居多。也就是说，对象间的交互往往是双向的。这会加强对象间的耦合性。 耦合本身没有错，实际上耦合是必不可少的，没有耦合就没有协作，对象之间无法形成一个整体，什么事也做不了。关键在于耦合要恰当，在实现预定功能的前提下，耦合要尽可能的松散。这样，系统的一部分变化对其它部分的影响会很少。 函数指针是解耦对象关系的最佳利器。Signal(如boost的signal和glib中的signal)机制是一个典型的例子，一个对象自身的状态可能是在变化的（或者会触发一些事件），而其它对象关心它的变化。一旦该对象有变化发生，其它对象要执行相应的操作。 如果该对象直接去调用其它对象的函数，功能是完成了，但对象之间的耦合太紧了。如何把这种耦合降到最低呢，signal机制是很好的办法。它的原理大致如下：其它关注该对象变化的对象主动注册一个回调函数到该对象中。一旦该对象有变化发生，就调用这些回调函数通知其它对象。功能同样实现了，但它们之间的耦合度降低了 在C语言中，要解决以上这些问题，不采用函数指针，将是非常困难的。在编程中，如果你从没有想到用函数指针，很难想像你是一个C语言高手。 4.4 回调函数的意义(总结)&emsp;&emsp;我们对回调函数的使用无非是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。 &emsp;&emsp;在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。 &emsp;&emsp;那么什么是回调函数呢，那是不得以而为之的设计策略，想象一种系统实现：在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。 &emsp;&emsp;在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，相信大家已经从上面的叙述中体会到了，就是面向对象的程序设计思想，就是设计模式中要求的模块独立性，高内聚低耦合等特性。 &emsp;&emsp;封装变化的编程策略给编程人员第一位的指导思想就是面向接口编程，即设计模式中提到的面向虚拟编程而不是面向实现。这样的编程思想极大地革新了编程世界，可以说没有这一原则就没有面向对象的程序设计，这一原则给程序设计一种指导思想即如何更高的将现实模型映射成程序模型。这样的设计思想在极大地催生高度独立性模块的同时削弱了模块间的协作性，也就是耦合性，它使得模块间更多的从事着单向的调用工作，一个模块需要某种服务就去找另一个模块，这使得程序呈现出层次性，高层通过接口调用底层，底层提供服务。但是现实世界中严格遵循现层次特性的系统是很少见的，绝对的MVC是不存在的，因为更多的模块要求通并协作，可见没有耦合就没有协作没有好的调用关系，耦合真的不是错。 &emsp;&emsp;既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。 五、回调函数应用5.1 typedef void (*pFunc)();&emsp;&emsp;事实上,为了代码的移植考虑,一般使用typedef定义函数指针类型。 12345678//typedef int (*funcptr)();//定义一个返回值为int，不带参数的函数指针//就是说funcptr 是 int (*)()型的指针//funcptr table[10]; //定义一个数组，这个数组是funcptr类型的//就是说这个数组内的元素都是一个(函数)指针//这个指针指向一个返回值为int，不带参数的函数 有了函数指针类型，以后我们就可以象变量一样声明函数指针，如下例： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef void(*pFunc)();void myFunc()&#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl;&#125;int main()&#123; pFunc func; unc = &amp;myFunc; func(); return 0;&#125; 5.2 怎么使用带参数的回调函数？123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int Callback_1(int x) // Callback Function 1&#123; printf("Hello, this is Callback_1: x = %d ", x); return 0;&#125;int Callback_2(int x) // Callback Function 2&#123; printf("Hello, this is Callback_2: x = %d ", x); return 0;&#125;int Callback_3(int x) // Callback Function 3&#123; printf("Hello, this is Callback_3: x = %d ", x); return 0;&#125;int Handle(int y, int (*Callback)(int))&#123; printf("Entering Handle Function. "); Callback(y); printf("Leaving Handle Function. ");&#125;int main()&#123; int a = 2; int b = 4; int c = 6; printf("Entering Main Function. "); Handle(a, Callback_1); Handle(b, Callback_2); Handle(c, Callback_3); printf("Leaving Main Function. "); return 0;&#125; 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Entering Main Function.Entering Handle Function.Hello, this is Callback_1: x = 2Leaving Handle Function.Entering Handle Function.Hello, this is Callback_2: x = 4Leaving Handle Function.Entering Handle Function.Hello, this is Callback_3: x = 6Leaving Handle Function.Leaving Main Function.``` &amp;emsp;&amp;emsp;可以看到，并不是直接把&lt;code&gt;int Handle(int (\*Callback)())&lt;/code&gt; 改成 &lt;code&gt;int Handle(int (\*Callback)(int))&lt;/code&gt; 就可以的。而是通过另外增加一个参数来保存回调函数的参数值，像这里 &lt;code&gt;int Handle(int y, int (*Callback)(int))&lt;/code&gt; 的参数 y。同理，可以使用多个参数的回调函数。## 5.3 结构体中的函数指针&amp;emsp;&amp;emsp;C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，这也就方便了我们使用函数了。举个例子，如下：```C#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct student &#123; int id; char name[50]; void (*initial)(); void (*process)(int id, char *name); void (*destroy)(); &#125;stu; void initial() &#123; printf(&quot;initialization...\n&quot;); &#125; void process(int id, char *name) &#123; printf(&quot;process...\n%d\t%s\n&quot;,id, name); &#125; void destroy() &#123; printf(&quot;destroy...\n&quot;); &#125; int main() &#123; stu *stu1; //在VC和TC下没有malloc也可以正常运行，但是linux gcc下就会出错，为段错误，必须使用malloc stu1=(stu *)malloc(sizeof(stu)); //使用的时候必须要先初始化 stu1-&gt;id=1000; strcpy(stu1-&gt;name,&quot;C++&quot;); stu1-&gt;initial=initial; stu1-&gt;process=process; stu1-&gt;destroy=destroy; printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name); stu1-&gt;initial(); stu1-&gt;process(stu1-&gt;id, stu1-&gt;name); stu1-&gt;destroy(); free(stu1); return 0; &#125; 终端显示： 123451000 C++initialization...process...1000 C++destroy.. Ps：无论是什么类型(结构体也是)的指针，都要主要初始化(或赋内存)。 5.3 结构体拓展——协议类&emsp;&emsp;c语言中，如何在结构体中实现函数的功能？把结构体做成和类相似，让他的内部有属性，也有方法，这样的结构体一般称为协议类，提供参考： 1234567typedef struct&#123; int funcid; char *funcname; int (*funcint)(); /* 函数指针 int 类型*/ void (*funcvoid)(); /* 函数指针 void类型*/ &#125;XXX; &emsp;&emsp;每次都要注意：需要初始化。 该回调函数的用法为： 甲方进行结构体的定义（成员中包括回调函数的指针） 乙方定义结构体变量，并向甲方注册， 甲方收集N个乙方的注册形成结构体链表，在某个特定时刻遍历链表，进行回调。 当函数指针做为函数的参数，传递给一个被调用函数，被调用函数就可以通过这个指针调用外部的函数，这就形成了回调 一般的程序中回调函数作用不是非常明显，可以不使用这种形式 最主要的用途就是当函数不处在同一个文件当中，比如动态库，要调用其他程序中的函数就只有采用回调的形式 通过函数指针参数将外部函数地址传入来实现调用函数的代码作了修改，也不必改动库的代码(只是函数指针指向的函数修改变动，库的处理没有变动)，就可以正常实现调用便于程序的维护和升级]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数返回值(指针函数)]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、函数返回值的要点注意（原则）：可以返回局部变量本身，但永远不要返回一个局部变量的指针或引用(其实是隐式的指针)； 原因：局部变量只是临时的存储空间，因为函数执行完之后，将释放分配给局部变量的存储空间，此时，对局部变量的引用和地址就会返回不确定的内存(野指针)。 系统堆栈的知识点 &emsp;&emsp;函数调用过程中，一个函数在调用另外一个函数的时候，会先将调用前的现场信息保存在系统堆栈中，然后按照从又向左的顺序(c语言)将实参的结果入栈，而被调用的函数的形参，用的就是实参的空间，当被调用的函数运行结束后，局部变量的空间被“释放”的本质，其实是栈顶的指针，移动到了调用前函数的现场信息的地方，所以刚才被调用的函数的局部变量，实际上它的值还是存放在内存中，并且在当前栈顶指针的上面的连续空间中。 简单理解 &emsp;&emsp;函数执行完，局部变量会被释放，此时指向 已释放的局部变量 的指针 是很危险(不确定)的；如果不调用还好(但不调用，那要返回值干嘛?)； &emsp;&emsp;一旦其他函数调用该函数返回值指针，该指针指向的内存不确定就会造成不可知的错误。 二、举例 返回变量本身 123456789101112//这个返回变量本身内存可以，正确int add(int x, int y)&#123; int sum = x + y; return sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; add(a, b) &lt;&lt; endl;&#125; 返回局部变量指针，用法错误 1234567891011int* add(int x, int y)&#123; int sum = x + y; return &amp;sum; &#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 会出现以下警告： warning: function returns address of local variable [-Wreturn-local-addr] return &amp;sum; 警告：函数返回地址是局部变量地址—&gt;这是不安全的 三、解决方案和利弊3.1 解决方案该如何解决这种错误呢？有以下3种常用方案： 使用静态变量 使用全局变量 申请堆区变量 其实，使用这三种方法都是为了延长变量的声明周期，从而达到返回的地址是确定的而不是不确定的。 法1： 1234567891011int* add(int x, int y)&#123; static int sum; sum = x + y; return &amp;sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 法2： 12345678910111213int sum;int&amp; add(int x, int y)&#123; sum = x + y; return sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 法3： 1234567891011121314int* add(int x,int y)&#123; int* sum = new int; *sum = a + b; return sum;&#125;int main()&#123; int a = 3, b = 5; int *result; result = add(a, b); cout &lt;&lt; *result &lt;&lt; endl; delete result;&#125; &emsp;&emsp;但法3需要注意，由于用new申请的动态内存，调用者（这里是main）需要释放这个申请的指针free, delete 3.2 利弊 法3的 申请堆区变量 比较麻烦，一般不常用； 法2的 使用全局变量 比较鸡肋；如果是全局变量的(函数返回值)指针，为啥不直接调用该指针，函数就不需要返回(全局)指针，该返回值充其量像是 提示 ，或者是函数格式要求 法1的 使用局部变量 比较推荐 总结：指针类型的函数返回值 还是不推荐用。 &emsp;&emsp;采用return语句返回的指针，原本想法是让函数返回多个数值(数组、结构体)；但指针往往是作为函数形参来直接改变实参(数值)，从而让函数变相返回多个数值；因此，指针类型的函数返回值，功能少且鸡肋(容易出事)，不推荐使用]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>函数返回值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数形参]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、指针作为函数参数1.1 函数参数的传递方式C语言的函数参数的传递方式有以下两种： 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作 1.2 函数相关的知识 函数(return)返回值：实际一般是返回(处理过的)局部变量；且只能返回单个值； 指针作为函数参数，指针能使被调函数(变相)返回一个以上的结果。（直接对内存操作3改变多个实参） 函数内部修改外部变量的值，需要一级指针； 函数内部修改外部指针变量的值，需要二级指针； 所以要想直接对内存单元进行操控，用指针最直接，指针的功能很强大。 1.3 举例 经典例子1 ：交换CET1 和 CET2 的值（一级指针交换值） 1234567//Wrongvoid swap_val(int a,intb)&#123; int tmp = a; a = b; b = tmp;&#125; 错误原因：因为交换的是副本(形参)，真品(实参)没改变的。 经典例子2：是在学习STM32的库函数的使用。当初刚接触库函数，对于函数初始化接口。 1GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 分析：为什么要取初始化结构体变量的地址传递进库函数（&amp;GPIO_InitStructure），而不是直接将结构体变量本身（GPIO_InitStructure）传递进去？ 二、实际例子2.1 两数值交换1234567891011121314151617# include &lt;stdio.h&gt;void Swap(int *p, int *q); //函数声明int main(void)&#123; int i = 3, j = 5; Swap(&amp;i, &amp;j); printf("i = %d, j = %d\n", i, j); return 0;&#125;void Swap(int *p, int *q)&#123; int buf; buf = *p; *p = *q; *q = buf; return;&#125; 输出结果是：i = 5, j = 3 &emsp;&emsp;此时实参向形参传递的不是变量 i 和 j 的数据，而是变量 i 和 j 的地址。其实传递指针也是拷贝传递，只不过它拷贝的不是内存单元中的内容，而是内存单元的地址，这就是天壤之别了。拷贝地址就可以直接对地址所指向的内存单元进行操作，即此时被调函数就可以直接对变量 i 和 j 进行操作了。有人会说：“被调函数用完就释放了，不就把 i 和 j 都释放了吗？”不是的，当函数调用完之后，释放的是 p 和 q，不是 i 和 j。p 和 q 中存放的是 i 和 j 的地址。所以 p 和 q 被释放之后并不会影响 i 和 j 中的值。前面讲过，修改指针变量的值不会影响所指向变量中的数据。只不过它们之间的指向关系没有了而已。 此外需要注意的是，形参中变量名分别为 p 和 q，变量类型都是 int* 型。所以实参 i 和 j 的地址，即 &amp;i 和 &amp;j 是分别传递给 p 和 q，而不是传递给 *p 和 *q。 函数参数传指针和传数据的区别 &emsp;&emsp;综上所述，如果希望在另外一个函数中修改本函数中变量的值，那么在调用函数时只能传递该变量的地址。如果这个变量是普通变量，那么传递它的地址就可以直接操作该变量的内存空间。 &emsp;&emsp;那么，是不是要定义一个指针变量指向它然后传递这个指针变量呢？不用多此一举。比如有一个“int i；”，如果想传递i的地址那就直接传递 &amp;i 就行了，不用专门定义一个指针变量指向它，然后再传递这个指针变量。 如果要传递的变量本身就是一个指针变量怎么办？如果要操作该指针变量所指向的内存空间是不是要传递该指针变量的地址呢？ &emsp;&emsp;指针变量本身就是地址，本身就是指向那个内存空间的，所以直接把它传过去就行了。除非你要改变那个指针变量里面存放的地址，即你要改变指针变量的指向，那么你就必须要传递指针变量的地址。指针可以使得函数返回一个或者一个以上的值 2.2 数组中的n个元素的值分别减去20 需求分析:编写函数,要求将数组中的n个元素的值分别减去20 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#define N 10//函数前置声明void traverseArray(int *pArr,int length);void subArray(int a[],int length);void subArray1(int * pArr,int length );//数组元素的遍历void traverseArray(int *pArr,int length)&#123; int i; for(i = 0;i&lt;length;i++) &#123; printf("%3d",*(pArr+i)); &#125; printf("\n"); return;&#125;//将数组中所有元素都减去20void subArray(int a[],int length)&#123; int i ; for(i = 0;i&lt;length;i++) &#123; a[i] = a[i] - 20; &#125; return;&#125;//将数组中所有元素都减去20void subArray1(int * pArr,int length )&#123; int i ; for(i = 0;i&lt;length;i++) &#123; *(pArr + i) = *( pArr + i) - 20; &#125; return ;&#125;int main(void)&#123; int a[N]=&#123;51,52,53,54,55,56,57,58,59,60&#125;; printf("原来数组中的元素为:\n"); traverseArray(a,N); printf("数组中元素第一次减去20后为:\n"); subArray(a,N); traverseArray(a,N); printf("数组中元素第二次减去20后为:\n"); subArray1(a,N); traverseArray(a,N); return 0;&#125; 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： 不允许拷贝数组； 使用数组时通常会将其转换成指针。 &emsp;&emsp;因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因此数组会被转换成指针(数组退化现象)，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345//尽管形式不同，但这三个printf函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10])//这里的维度表示我们期望数组含有多少元素，实际不一定 当编译器处理对printf函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] &emsp;&emsp;如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 三、指针作为函数参数的好处&emsp;&emsp;此外，传指针和传数据相比还有一个好处就是节约内存。我们知道，传数据拷贝的是内存单元的数据，如果数据很多的话拷贝过来都要为它们分配内存。而传指针的话只需要传递 4 字节的地址就行了。而且传数据非常消耗效率，为形参分配内存需要时间，拷贝需要时间，最后结束了返回还是需要时间。前面说过，return时系统会先自动创建一个临时变量来存放返回的值。所以传数据时很消耗效率，而传指针就是为了提高效率。 &emsp;&emsp;事实上，在实际编程中我们都是传递指针！ 往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可： 数据很小，比如就一个 int 型变量。 不需要改变它的值，只是使用它的值。 此时不是不能用指针，当然也可以用指针，只是没有必要。 &emsp;&emsp;以后在使用函数的时候，只要函数的参数不满足上面这两个条件，那么就用指针。此外需要注意的是，数组名本身就是地址，所以如果传递数组的话直接传递数组名就行了。接收的形参可以定义成数组(形式方面上而已)也可以定义为同类型的指针。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>函数形参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针&数组&字符串]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、指针 &amp; 数组(细品)&emsp;&emsp;指针就是指针，指针变量在32位系统下，永远占4字节，其值为某一个内存的地址。指针可以指向任何地方(内存)，但是不是任何地方你都能通过这个指针变量访问到呢？(有地址，无[权限]空间) &emsp;&emsp;数组就是数组，其大小与元素的类型和个数有关；定义数组时，必须指定其元素的类型和个数；数组可以存任何类型的数据，但是不能存函数。 总结如下： 指针本质上也是一个变量 指针要占用一定的内存空间（任何类型的指针的内存大小是一样的） 指针用于保存内存地址的值 数组&amp;结构体 数组：所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙 结构体：在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。 二、数组2.1 数组的基础 数组在一片连续的内存中存储元素 元素的个数可以是显示的也可以是隐式的1int a[5]=&#123;1,2&#125;;//其中,其他的元素都为0来填充 2.2 数组地址与数组名 数组名代表数组首元素的地址 数组的地址需要取地址才可以得到 数组首元素的地址值 与 数组的地址值 相同(注意是值) 数组首元素的地址 &a[0] 与数组的地址 &a 是两个不同的概念 &emsp;&emsp;举例，湖南省的省政府在长沙，长沙的市政府也在长沙，两个政府都在长沙。 2.3 数组名的盲点&emsp;&emsp;数组名如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。 &emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。 &emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！ 数组名可以看作一个常量指针（指针所指向的内容不能改变） 既然是指向常量，那就不能作为表达式左值，因为左值能被修改 可以单独修改数组元素，但用数组名(实际上是符号常量)不能直接修改数组 2.4 指针 &amp; 数组 的定义与声明(经典错误)2.4.1 定义为指针，声明为数组1234567891011//test1 文件1char * p="Hello World!";//test2 文件2#include&lt;stdio.h&gt;extern char p[];void main()&#123; printf("%s\n",p);//printf("%s\n",*(unsigned int *)p);正确&#125; 2.4.2 定义为数组，声明为指针12345//test1 文件1char a[100];//test2 文件2extern char *a; 2.5 定义数组类型&emsp;&emsp;C语言中，可以通过typedef为数组类型重命名 1typedef type(name)[size]; 数组类型(重命名了一种一个数组类型）： 12typedef int(AINT5)[5];typedef float(AFLOAT10)[10]; 数组定义： 12AINT5 i = &#123;0,1,2,3,4&#125;;AFLOAT10 f; 三、 字符串 从概念上讲，C语言中没有字符串数据类型 在C语言中使用字符数组来模拟字符串 单引号' '括起来的一个字符代表整数 双引号" "括起来的字符(串)代表一个指针 字符串是以 '\0'结束的字符数组 字符串可以分配于栈空间，堆空间或者 字符常量区（不能被改变） 123char* s1 = "Hello World"； //在字符常量区,不可改变这个字符串中的字符char s2[100] = "Hello world"; //在栈上，可修改(不能通过数组名！) 3.1 (实)字符数组、(虚)字符串&emsp;&emsp;下面的代码合法吗？使用它有什么隐患？ 1234char a[3] = "abc";char *p = &amp;a;p[0]= 'I';答案与分析： &emsp;&emsp;在标准C中这是合法的，但是它的生存环境非常狭小；它定义一个大小为3的字符数组，初始化为“abc”；注意，它没有通常的字符串终止符'\0'，因此这个数组只是看起来像C语言中的字符串，实质上却不是。因此所有对字符串进行处理的函数，比如strcpy、printf等，都不能够被使用在这个假字符串上。 3.2 字符串的长度 字符串的长度就是字符串说包含字符的个数 C语言中的字符串的长度值得是第一个'\0'字符串出现的字符个数 C语言中通过'\0'结束来确定字符串的长度 以strlen()为例，strlen()为无符号类型 12345//比较两个字符串的长度的时候//正确用法if(strlen(a)&gt;=strlen(b))//错误用法if(strlen(a)-strlen(b)&gt;0) 3.3 不受限制的字符串函数&emsp;&emsp;不受限制的字符串函数是通过寻找字符串得结束符 '\0'来判断长度。 字符串复制函数： char* strcpy(char* dst,const char* src) 字符串连接： char* strcat(char* dst,const char* src) 字符串比较函数：int strcmp(const char* s1,const char* s2) 注意事项 不受限制的字符串函数都是以'\0'作为结束标记来进行的，因此输入参数必须包含'\0' strcat和strcpy必须保证目标字符数组的剩余空间足以保存整个源字符串 strcmp以0值表示两个字符串相同 第一个字符串大于第二个字符串的时候返回值大于0 第一个字符串小于第二个字符串的时候返回值小于0 strcmp不会修改参数值，但依然以'\0'作为结束符号 3.4 长度受限制的字符串函数&emsp;&emsp;长度受限的字符串函数，是接收一个长度参数用于限定操作的字符串，提高程序的安全性。 字符串复制:char* strncpy 字符串连接:char* strncat 字符串比较:char* strncmp 四、数组参数和指针参数(针对函数传入)&emsp;&emsp;数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： 不允许拷贝数组 使用数组时通常会将其转换成指针 因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。 因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。(数组参数退化为指针) 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345678//尽管形式不同，但这三个进行print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10])//这里的维度表示我们期望数组含有多少元素，实际不一定//第三种容易被误会，且容易造成数组越界://实际元素不确定，但是函数操作(传入数组较短)以10个操作，越界 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] 如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 五、二维数组5.1 二维数组参数和指针参数&emsp;&emsp;C语言的编译器会让（不论是一维数组还是二维数组）数组参数退化为指针。C语言中无法向一个函数传递任意的多维数组。 二维数组参数同样存在退化问题。 二维数组可以看作是一维数组 二维数组中的每一个元素是一维数组 二维数组参数中第一维的参数可以省略（退化过程） 注意事项 C语言中无法向一个函数传递任意的多维数组 为了提供正确的指针运算，必须提供除一维之外的所有维的长度(程序写法)限制 一维数组-必须提供结束的标志 二维数组-不能直接传递给函数 多维-无法使用 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;void access(int a[][3],int row)&#123; int col=sizeof(*a)/sizeof(int);//去推导出列的数量 int i=0,j=0; for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; printf("%d ",a[i][j]); &#125; printf("\n"); &#125;&#125;void main()&#123; int a[3][3]=&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;; access(a,3);&#125; 5.2 二维数组与数组指针 二维数组在内存中以一维的方式排布 二维数组中的第一维是一维数组 二维数组中的第二维才是具体的值 二维数组的数组名同样可以看作常量指针 二维数组同样代表数组首元素的地址 12345678#include&lt;stdio.h&gt;int main()&#123; int a[5][5]; int (*p) [4]; p=a; printf("%d\n",&amp;p[4][2]-&amp;a[4][2]);&#125; 答案为-4，因为（*p）一次跨越4个，而a一次跨越5个 123456789101112131415//用指针遍历二维数组#include&lt;stdio.h&gt;int main()&#123; int i,j; int a[3][3]=&#123;&#123;&#125;&#125;; for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) *(*(a+i)+j)=1; for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) printf("%d",*(*(a+i)+j)); return 0;&#125; 六、指向指针的指针为什么需要指向指针的指针？ 指针在本质上也是一个变量 对于指针来讲也有传值调用与传址调用 123456789101112131415161718192021222324252627282930313233343536//重置动态空间#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int rest(char** p,int size,int new_size)&#123; int ret=1; int len=0; int i=0; char* mid=NULL; char* pt=NULL; char* pp=*p; if((p!=NULL)&amp;&amp;(new_size&gt;0)) &#123; mid=(char*)malloc(3); pt=mid; len=(size&lt;new_size)?size:new_size; for(i=0;i&lt;len;i++) &#123; *pt++=*pp++; &#125; free(*p); *p=pt; &#125;else&#123; ret=0; &#125; return ret;&#125;void main()&#123; char *p=(char*)malloc(5); printf("%0X\n",p); if(rest(&amp;p,5,3)) &#123; printf("%0X\n",p); &#125;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在嵌入式中的各种指针用法和概念]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95%E5%92%8C%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = Ps：以下所有指针的概念的理解思路可以从字义层面上，从右到左进行理解。 指针数组 ： int *p1[10]; 数组指针 ： int (*p2)[10]; 对应概念 指针数组：一个存放多个指针的数组 数组指针：一个指向数组的指针(首地址) 对应用法 指针数组：一般是存放多个指针分别指向各个不同的字符串，不同的指针可组合起来一段话。 数组指针：一般是作为函数的数组形参，打印字符串可以只修改指向的字符串地址。 结构体指针 ：Student *p2; 结构体数组指针 ：Student (*p2)[10]; 结构体成员是指针： 对应概念 结构体指针：跟数组指针差不多 结构体数组指针：跟指针数组差不多，存放多个结构体指针 结构体成员是指针：跟普通数组差不多，但只是部分成员(元素)是指针 对应用法 结构体指针：普遍常用 结构体数组指针：普遍常用，可对应不同驱动的通道号(例如两路硬件选择) 结构体成员是指针：很常见，不过要注意初始化赋值 指针函数： int *p3(int，int); 函数指针： int (*p4)(int，int); char *(*pf)(char * p); 传递指针： int p5(int*，int*) 对应概念 指针函数：一个返回值是 指针变量 的函数 函数指针：一个指向函数的指针 传递指针：函数形参是指针 对应用法 指针函数：不常用，有风险。不能返回局部变量指针，全局指针变量还需要返回吗？ 函数指针：相当于留出自定义函数接口，常用于回调函数 或 程序适应(选择)不同(硬件)版本的驱动(函数) 传递指针：很常用，传入实参需要修改值时，就传入实参指针(数组退化被迫传入指针) Ps： 函数声明时，可以省略形参名，不能省略形参类型； 函数定义（写函数体）时，则都不能省略。 函数内部修改外部变量的值，需要一级指针；(函数形参) 函数内部修改外部指针变量的值，需要二级指针。 函数的实参和形参之间的传递是单向的，只能由实参向形参传递(拷贝传递)。被调函数调用完之后系统为其分配的内存单元都会被释放。我们在对常量，或者是指针进行操作的时候，实质上是对其对应的内存进行操作 函数指针数组： int (*p5[3])(int ); char *(*pf[3])(char *p); 函数指针数组指针： char *(*(*pf[3])(char *p); 对应概念 函数指针数组：一个数组中，所有元素都是指针，且一个指针对应指向一个函数 函数指针数组指针：一个指针，指向一个数组，这个数组中，所有元素都是指针，一个指针对应指向一个函数 对应用法 函数指针数组：一个数组存放多个不同版本的驱动、算法(函数) 上面那个已经很极限了；这个真太花里胡哨，用不来，用的来也估计是埋坑给后面的]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[符号&强制转换]]></title>
    <url>%2F2020%2F03%2F15%2F%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2020/09/05,最后一版~ 一、符号 &amp; 变量类型1.1 b1&lt;&lt;1 和 b1&lt;&lt;=1&emsp;&emsp;可能有人一眼就看出差异，这是因为有得对比；这里还是提醒一下，实际编写代码时往往会拐不过弯、忽略这点细节。 b1&lt;&lt;1，等价于其结果左移1位，但是b1值没有发生改变 b1&lt;&lt;=1，等价于b1 = b1&lt;&lt;1；b1&lt;&lt;1表示b左移1位(二进制)，b1值发生了变化 1.2 int 和 int32_t 、uint32_t&emsp;&emsp;首先先区分有符号和无符号。uint和int之间不仅有符号，还有补码。不是只差最高位的符号位。至于int32_t、uint32_t，是typedef重定义来的。代码如下： 123456typedef unsigned char uint8_t;typedef signed char int8_t;typedef unsigned short uint16_t;typedef signed short int16_t;typedef unsigned int uint32_t;typedef signed int int32_t; &emsp;&emsp;在嵌入式开发的话，为了提高兼容性和阅读理解，推荐统一使用该重定义。而且该重定义是有C的标准库的，提高代码的兼容性；常见的C的标准库举例如下： 123#include &lt;stdint.h&gt; //标准库文件采用&lt;&gt;，自己编写的文件引用时采用""#include &lt;stdbool.h&gt;#incldue &lt;stddef.h&gt; 常见的给宏定义赋常量，会使用类似如下方法: 1#define MINI_UNIT (1ul) &emsp;&emsp;1ul说明这个常量1是unsigned long，用于明确计算值的范围。 1.3 少用printf&emsp;&emsp;有可能打印出来的类型都弄错了= = &emsp;&emsp;为什么呢？很多学生写完代码，直接用 printf 打印出来，发现结果不对。不会看变量的值，内存的值。只知道 printf 出来结果不对，却不知道为什么不对，怎么解决。这种情况还算好的。 &emsp;&emsp;往往很多时候 printf 出来的结果是对的，然后呢，学生也理所当然的认为程序没有问题。 是这样吗？&emsp;&emsp;打印结果对，并不代表程序真正没有问题。所以，以后尽量不要用 printf 函数，要去看变量的值、内存的值。 二、类型转换的来源&emsp;&emsp;计算机硬件进行算术操作时，要求各操作数的类型具有相同的大小（存储位数）及存储方式。例如，由于各操作数大小不同，硬件不能将 char 型（ 1 字节）数据与 int 型（ 2 或 4 字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 float 型数据直接参与运算。 &emsp;&emsp;由于 C 语言编程的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。C 语言的灵活性与计算机硬件的机械性是一对矛盾，如处理不好，将会产生错误结果。 对于某些类型的转换编译器可隐式地自动进行，不需人工干预，称这种转换为自动类型转换； 而有些类型转换需要编程者显式指定，通常，把这种类型转换称为强制类型转换。 2.1 自动类型转换(隐式)&emsp;&emsp;不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。 常见类型级别从低到高依次为：char -&gt; short -&gt; int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; double 浮点型级别从低到高依次为：float -&gt; double 不同类型间的混合运算，较低类型将自动向较高类型转换(精度提高不影响结果)。 2.2 强制类型转换&emsp;&emsp;为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C 语言提供了可显式指定类型转换的语法支持，通常称之为强制类型转换。 强制类型转换常见的用法: (1)数据的 高类型一般不会强制转换成低类型，因为可能会丢失一部分数据； (2)一般是低类型强制转换成高类型，防止数据溢出； (3)提高函数指针的适用性 原因如下： (1)高类型转低类型，往往是函数传参，让函数处理更加明确范围； (2)低类型转高类型，防止数据溢出； (3)强制转换函数指针能够让回调方式更加多样性。 也许有人会问，那一开始都为高类型就不需要强制转换了吗？ &emsp;&emsp;很简单，能低类型处理能够更好体现对应代码块功能性。当外部需要调用该变量，再强制转换成想要(高)数据类型，防止计算过程中数据溢出。这种灵活性，还能实现节省内存。 三、类型转换例子3.1 常见类型转换(算术运算式) (int)(a + b) (int)a + b 前者是(a+b)共同强制转换成整形常数，后者是a强制成整形 加上b的值。举例如下： 1234float a = 5.1, b = 2.2;(int)(a + b) = 7(int)a + b = 7.2 //低类型自动转成高类型计算 同理 12int a = 2,b = 3;(float)(a+b)/2 = 2.5 3.2 float、double类型的近似问题&emsp;&emsp;float double这类的数据是近似值，有精度问题。也就是说打印出制来的 8.0000 未必是 8.00000。&emsp;&emsp;8.00000实际上可能是是7.99999999999872812850 ，所以如果进行强制转换会是转为int的7。 举例如下： 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int temp,i; double a=2.4568; unsigned char b[5]; for(i=0;i&lt;5;i++) &#123; temp=(int)a; b[i]=temp+'0'; a=(a-temp)*10; printf("%.20f %d\n",a,(int)a); &#125; b[5]='\0'; puts(b);&#125; 结果如下： 1234564.56799999999999872813 45.67999999999998728129 56.79999999999987281285 67.99999999999872812850 79.99999999998728128503 924567 &emsp;&emsp;一般来说 要把浮点转为int 要取得最近似的值，大都是采用(int)(a+0.5) 从而达到一种四舍五入的效果。 3.3 (隐式)强制转换 算术运算式中，低类型能够转换为高类型(比较熟悉) 赋值表达式中，表达式的值 (自动)转换为 左值(变量)的类型 函数调用时，实参(自动)转化为形式参数的类型 函数返回值，return 表达式 (自动)转化为返回值的类型 &emsp;&emsp;举一个简单直白的例子如下： 12345float a = 5.1, b = 2.2;int c = 0;c = (int)a + b; //等效于下面式子，结果虽然为7.2，但最后赋值经过强制转换，c = 7c = (int)((int)a + b); //与上述式子等效，c = 7 &emsp;&emsp;相当于赋值操作总有一个整体的强制转换(隐藏)。再举一个例子如下： 12345678910111213int a = 2,b = 3;float c = 0;c = (float)(a+b)/2; //c = 2.500000c = (float)((float)(a+b)/2); //如同上式c = (a+b)/(float)2; //在整个式子计算中，结果计算中较低类型自动转换较高类型c = (float)((a+b)/(float)2); //因此两式子结果均为 c = 2.5000000c = (a+b)/2; //毫无意外，c = 2.000000；等效下面式子c = (float)((a+b)/2); //经典错误，很多人容易把强制转换放错位置//最后一条式子是经典错误，尤其是式子比较复杂时，容易理解错误并放错位置//导致最终结果并不是想要的值 &emsp;&emsp;再举一个因(隐藏)强制转换导致的常见例子如下；右值超出左值类型范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。 123char c; //char 占8位，表示范围-127〜128c = 1025; //1025 对应二进制形式：100 0000 0001，超出了8位printf("％d",c) ; //以十进制输出c的值 &emsp;&emsp;该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量 c，故得到毫无意义的值。 四、double 转 uint32_t 等于？举例如下: 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main()&#123; double i = -3; uint32_t j = 0; int32_t k = 0; uint8_t z = 0; int8_t y = 0; j = (uint32_t)i; k = (int32_t)i; z = (uint8_t)i; y = (int8_t)i; printf("%f\n",i); printf("%d\n",j); printf("%u\n",j); printf("%d\n",k); printf("%d\n",z); printf("%u\n",z); printf("%d\n",y); return 0;&#125; 那么，以上例子的 j 值究竟是多少？答案是 4294967293。全部结果如下： 1234567-3.000000-34294967293-3253253-3 &emsp;&emsp;如果你以为上面的答案就是结束了？那你就大错特错了；上面的答案可能不够准确，在x86平台上是-3的补码，在ARM平台上是0。 这里要如何解释该现象呢？首先明确一些概念： 有符号类型和无符号类型混合运算时，所有的操作数都自动转换为无符号类型(在编译器中)；从这个意义上讲，无符号数的运算优先级要高于有符号数 由于负数在底层存储是补码形式，从而方便机器放入运算器进行计算(基础知识) 因此导致了，有符号数与无符号数不能直接一起混合运算 &emsp;&emsp;举个明显的例子： 123456789uint32_t a = 20;int32_t b = -130;if(a &gt; b) printf("%o\n", a);else printf("%d\n", b); //最终打印出来的是b的值，因为编译器把 b 转化为无符号数处理，因此 b &gt; a 我们在学校学到的知识是基于x86平台的，即： 整型负数的类型转换，是在其补码上做高位的去除和填补 浮点型负数的类型转换，是取其整数部分的补码做高位去除和填补。 当负数是整数时，无符号整数只是换了一种表达方式来解释它的补码，所以 -1 是 4294967295。 当负数是浮点数时，浮点数的存储是尾数+指数的方式 如果直接将浮点数的二进制数据(补码)转为无符号整数，这就依赖平台的实现了；具体的ARM会转成0，而x86会转成整数部分。 &emsp;&emsp;举一个stm32在keil平台的测试情况： 1234567891011121314double i = -12.456;uint32_t j = 0;int32_t k = 0;uint16_t p = 0;int16_t q = 0;uint8_t y = 0;int8_t z = 0;j = (uint32_t)i;k = (int32_t)i;p = (uint16_t)i;q = (int16_t)i;y = (uint8_t)i;z = (int8_t)i; 最后的结果如下： 1234567i = -12.456;j = 0x00000000;k = 0xfffffff4;p = 0x0000;q = 0xfff4;y = 0x00;z = 0xf4; &emsp;&emsp;这里总结一下强制转换 &amp; 类型的要点： 有符号数 &amp; 无符号数 不要混合运算；运算前明确转换成同种类型，不然可能因为有符号数自动转为无符号数导致获取数值异常问题 强制转换只能 截取或提高 精度(二进制机器码存储长度)，并不能改变数据的正负；例如 -1强制转换为正数，会变成一个很大的数(补码)；举例如下： (uint32_t)-3，0xfffffffd；即4294967293 (uint16_t)-3, 0xfffd；即65533 因此，无符号整形 &amp; 浮点型 不能直接强制转换；因为不但涉及到精度，还涉及到正负问题。且浮点型的补码和整数补码方式不一样，不同硬件平台可能出现不同结果 五、强制转换 实现 地址(指针)跳转1#define jump(TargetAddr) (*((void TargetAddr)))() &emsp;&emsp;第一个(( void( * )( )) ，意思为强制类型转换为一个无形参，无返回值的函数指针，(*(TargetAddr))为跳转地址，但是函数指针变量不能为常数所以要加((void( * )( )) 进行强制类型转换。最后一个()为执行的意思。 整个宏定义目的是为了跳转到一个绝对地址执行函数。用处如下： 在单片机中可以实现软件复位，比如跳转到0地址。 如果程序是由多个程序合并的（bootloader跳转），跳转到某一个确定的用户程序地址执行。 如果flash空间足够大的话，甚至还可以实现当多份不相同的代码合并为一份后，在软件上做逻辑跳转，好处是新程序不必为旧程序做大量的兼容工作，通常旧程序含有大量的前人的(坏)编程习惯。可以选择执行想要的版本软件程序。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>强制转换</tag>
        <tag>自动转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字&符号&预处理&函数]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%85%B3%E9%94%AE%E5%AD%97-%E7%AC%A6%E5%8F%B7-%E9%A2%84%E5%A4%84%E7%90%86-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器 一、关键字1.1 struct&emsp;&emsp;该关键字看另外博客：结构体 1.2 union&emsp;&emsp;该关键字看另外博客：大小端和联合体 1.3 switchswitch注意事项: case语句中的值只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里是怎么存的） default语句只能用于处理真正的默认情况 每个case语句分支必须有break，否则分支重叠 Ps：switch可用于冗长的程序逻辑进程，每一个case代表一个进程，只有其中进程执行完，才对switch(Temp)判断的值进行改动(例如：Temp++);然后进行下一个流程，方便梳理逻辑。 1.4 enum&emsp;&emsp;相比 #define 标识符常量必须由程序员手工赋值。enum 使程序更容易维护，因为枚举常量是由编译程序自动生成的。 Ps：可搭配switch作为case值方便扩展 1.5 static &amp; extern1.5.1 static1static uint32_t Shatang; 常见用法：屏蔽其他源文件对本源文件static修饰的变量 修饰局部变量：用来延长变量生命周期，防止再次调用函数时需要再初始化修饰的变量，保留原有数据(常见用法) 修饰全局变量：用static对全局变量进行修饰改变了其作用域的范围，防止其他源文件对本源文件的变量调用 static 全局变量：、 static全局变量只初始化一次，防止在其他文件单元中被引用； 只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。 static 局部变量： static局部变量只被初始化一次，下一次依据上一次结果值； 限制了它的使用范围 static 函数： static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为(static)内部函数，内部函数应该在当前源文件中说明和定义。 static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 Ps：指针是变量 总结：从上面用法描述来看，static不会在 .h文件修饰变量(.c文件都调用不了你，要你何用)，正常情况下都会在 .c文件修饰变量、函数定义(声明往往在.h文件），防止其他 .c文件调用； 1.5.2 extern1extern uint32_t Shatang; 常见用法：用在变量或者函数的声明前，用来说明“此变量/函数”是在别处定义的，要在此处引用。 问题描述：因为要使用CAN进行数据传输，因此在主程序”test.c”中采用#include “can.h”，调用”can.h”中的函数和变量。结果编译后出现许多 Error L6200E: symbol xxx multiply defined ... 原因：因为在 "can.h" 中定义（不仅声明还进行定义）了许多变量，"can.c"文件中采用 #include "can.h"，调用"can.h"中的变量定义；在主函数"test.c"中也采用 #include "can.h"，调用"can.h"中的变量定义，导致”can.h”中的变量被重复定义。 解决方法：首先，不应该在”can.h”中定义”can.c”中使用的变量（正常情况都是这样），而是在”can.c”中定义所需的变量。在”can.h”中把变量先进行 extern uint8_t Shatang; 声明，然后 在”can.c”文件再进行定义；此时，主程序”test.c”中将所调用”can.h”中的变量（声明） 将会去”can.c”查找其定义，因此不会存在变量重复定义，问题得到解决。 结论：extern往往用于 .h文件变量声明，然后在相应的 .c文件进行定义，这样防止 .h文件被多个 .c文件调用时产生重复定义的错误 特殊案例：往往图片、字库是按照 .h文件变量定义的，没有.c文件；当你的（lcd.c）文件功能需要调用 某些图片数组.h文件，不能在自身（lcd.h）文件调用 image.h文件，当其他 .c文件调用lcd.h 文件,就会产生上面同样的重复定义；因此对于(只有) .h文件进行变量定义，往往采用直接在（只能在单个） lcd.c 文件调用 1.5.3 static 和 extern 的关系&emsp;&emsp;static表示是本文件内的变量（在函数中的是静态变量），extern表示是其他文件定义的变量，显然两者是矛盾的；只有全局变量并且没有被static声明的变量才能声明为extern。 1.6 const &amp; 指针常见用法：const 修饰变量为只读变量(不是常量！！！)。 为了防止传递的函数参数不被修改，在调用函数的形参中用const关键字 const可以用来创建数组常量、指针常量、指向常量的指针等 如何辨别const是修饰什么？方法：无括号的情况下，可以先忽略类型名。 const int *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变int const *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变int *const p; //const修饰p，p不可变，p指向的对象可变const int *const p; //前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变 &emsp;&emsp;这里或许就有人要问：const int *const p;这种都不可变的有什么用？只不过是教语法时用到的花里胡哨。诚然，指针p和p指向的对象都不可变，但是p指向的对象还可以是个指针啊！因此 const int *const p;往往是用于二级指针。思路反过来，当别人代码这样写的时候：你就应该明白，这里是二级指针。 1234//特殊情况const (int*)p;* const int p;int* const p; &emsp;&emsp;以上的三种情况是等效的。对于const (int *)，因为int *是一个整体，相当于一个类型(如 char)，因此，这个const是限定指针不可变。 Ps：只读变量 和 常量 是有区别的，内存存放区域都不同。详情看内存分配一章。 1.7 voidvoid 常与 (函数)指针 搭配使用： C语言规定只有相同类型的指针才可以相互赋值 void*指针作为左值用于“接收”任意类型的指针 void指针作为右值赋值给其他指针时需要强制类型转换 1.8 volatilevolatile用于告诉编译器必须每次去内存中取变量值： volatile主要修饰可能被多个线程访问的变量 volatile也可以修饰可能被(硬件)未知因数更改的变量 Ps：volatile往往只用于最底层驱动(防止数值被修改，例如通信协议)；最好不要用于封装其他高级应用层的代码，用处不大，而且不利于其他人对你的程序进行移植拓展(极端情况下可能取值问题出错)。 举例如下： 1234int square(volatile int *ptr)&#123; return (*ptr)*(*ptr);&#125; 由于*ptr 的值可能被意想不到地该变，这段代码可能返不是你所期望的平方值！ 1.9 sizeof1sizeof(int) //计算(int类型)内存大小 常见用法：计算内存大小。在嵌入式c代码中，用于计算数组等大小；它往往会和 struct、#define、#pragma pack 连用，用来计算结构体的偏移量，方便调用结构体成员。 1234567891011121314151617181920212223/*块注释：打印参数列表*/typedef struct &#123; uint32_t ulPrintAuto; // 0 自动打印开关 uint32_t ulPrintFormat; // 1 打印格式 uint32_t ulPrintLang; // 2 打印语言 uint32_t ulPrintRow; // 3 打印走纸行数 uint32_t ulPrintAcc; // 4 打印总累计数据 uint32_t ulPrintRecipeSetting; // 5 打印配方设置表 uint32_t ulPrintRecipeAcc; // 6 打印配方累计表 &#125;_strPrintParam;/*块注释：获取打印参数结构体成员的偏移量*/#define GET_PRINTF_PARAM_OFFSET(member) (((uint32_t)(&amp;(((_strPrintParam *)0)-&gt;member))) / sizeof(uint32_t))/*块注释：获取打印参数数量*/#define PRINT_PARAM_NUM (sizeof(_strPrintParam)/sizeof(uint32_t)) PRINT_PARAM_NUM 可用于实现结构体成员的(for循环)赋值； GET_PRINTF_PARAM_OFFSET(member) 计算出来的结构体偏移量可方便 结构体扩展 1.10 typedef&emsp;&emsp;typedef用于给一个已经存在的数据类型重命名。 下边是一个能够说明typedef的语法例子： 1234567891011121314151617181920// simple typedeftypedef unsigned long ulong; // the following two objects have the same typeunsigned long l1;ulong l2; // more complicated typedeftypedef int int_t, *intp_t, (&amp;fp)(int, ulong), arr_t[10]; // the following two objects have the same typeint a1[10];arr_t a2; // common C idiom to avoid having to write "struct S"typedef struct &#123;int a; int b;&#125; S, *pS; // the following two objects have the same typepS ps1;S* ps2; typedef 定义结构体类型 12345678typedef struct&#123; int iNum; long lLength;&#125;MyStruct;MyStruct stu1;MyStruct *stu1;MyStruct class[50]; typedef 定义数组类型 12345678typedef int(AINT5)[5];typedef float(AFLOAT10)[10];typedef char(ACHAR9)[9];AINT5 a1;AFLOAT10* pf = &amp;fArray;ACHAR9 cArray;AINT5 i = &#123;0,1,2,3,4&#125;; typedef 定义(常见)指针类型 123typedef char* pstr;pstr p; typedef 定义函数指针类型 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef void(*pFunc)();void myFunc()&#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl;&#125;int main()&#123; pFunc func; unc = &amp;myFunc; func(); return 0;&#125; 进阶：typedef 定义函数指针类型后，可以再用 该函数指针类型 定义 数组/结构体成员，让 每个元素 或 结构体成员 为函数指针。 综合例程，如下： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt; typedef char arr[2][5]; // 数组typedef char *name[5]; // 指针数组 typedef char (*lan)[5]; // 数组指针 int main()&#123; arr age; name named; lan land; char i; char j; for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;5;j++)&#123; age[i][j]=i*j+1; &#125; &#125; for(i=0;i&lt;2;i++)&#123; named[i]=age[i]; &#125; land=&amp;age; for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;5;j++)&#123; printf("aged[%d][%d]=%d named[%d][%d]=%d land[%d][%d]=%d\n",i,j,age[i][j],i,j,named[i][j],i,j,land[i][j]); &#125; &#125;&#125; 1.11 enum &amp; const &amp; typedef &amp; #define #define：标识符常量必须由程序员手工赋值 enum：枚举常量是由编译程序自动生成的，使程序更容易维护 这两个都是可以用来定义常量 const：修饰 只读变量，不会变的变量。从内存分配区上来看，就已经不一样了。 typedef：跟#define极其相似，但实际有很大区别 举例区分typedef &amp; #define 例子1. 以下p1,p2,p3,p4有什么区别？ 123456//第一段typedef char* PCHAR;PCHAR p1,p2;//第二段#define PCHAR char*PCHAR p3,p4; 答案：p4是一个char类型 例子2. 以下是 指针为只读变量 还是 指针指向的内容不可变？ 12typedef char* pstr;const pstr p; 答案： const pstr p;&lt;==&gt; char* const p; &emsp;&emsp;错误的原因在于将 typedef 当做文本扩展了(#define 才是真正的文本扩展！)。声明 const pstring 时，const修饰的是pstring的类型，这是一个指针。因此，该声明语句应该是把cstr定义为指向string 类型对象的const指针。 123456typedef char* pstr;const pstr p;const (char*) p;* const char p;char* const p; &emsp;&emsp;以上的四种情况是等效的。 二、符号2.1 单引号、双引号 单引号引起来的都是字符常量 双引号引起来的都是字符串常量 举例：1 ，’1’ , “1” 第1个是整数常量，32位系统下占4字节；第2个是字符常量，占1字节；第3个是字符串常量，占2字节。 &emsp;&emsp;字符在内存里是以 ASCII码 存储的，所以字符常量还可以与整形常量或变量进行运算，如：'A' + 1 。 2.2 逻辑运算符使用分析案例分析: 1234567891011#include&lt;stdio.h&gt;void main()&#123; int i=0; int j=0; if(++i&gt;0 || ++j&gt;0) &#123; printf("%d\n",i); printf("%d\n",j); &#125;&#125; 输出的结果为1，0。 2.3 逻辑运算符 &amp; 按位运算符&emsp;&emsp;举例：以下例子函数的DATAx为宏定义stm32各个IO管脚，封装函数实现8pin并口数据输出；以下函数均能在C编译器编译通过 123456789101112131415161718192021222324//errorvoid DATA_Process(uchar com)&#123; DATA0=((com &amp;(1&lt;&lt;0))==1) ? 1 : 0 ; DATA1=((com &amp;(1&lt;&lt;1))==1) ? 1 : 0 ; DATA2=((com &amp;(1&lt;&lt;2))==1) ? 1 : 0 ; DATA3=((com &amp;(1&lt;&lt;3))==1) ? 1 : 0 ; DATA4=((com &amp;(1&lt;&lt;4))==1) ? 1 : 0 ; DATA5=((com &amp;(1&lt;&lt;5))==1) ? 1 : 0 ; DATA6=((com &amp;(1&lt;&lt;6))==1) ? 1 : 0 ; DATA7=((com &amp;(1&lt;&lt;7))==1) ? 1 : 0 ; &#125;//correctvoid DATA_Process(uint8_t com)&#123; DATA0=(com &amp;(0x01&lt;&lt;0)) ? 1 : 0 ; DATA1=(com &amp;(0x01&lt;&lt;1)) ? 1 : 0 ; DATA2=(com &amp;(0x01&lt;&lt;2)) ? 1 : 0 ; DATA3=(com &amp;(0x01&lt;&lt;3)) ? 1 : 0 ; DATA4=(com &amp;(0x01&lt;&lt;4)) ? 1 : 0 ; DATA5=(com &amp;(0x01&lt;&lt;5)) ? 1 : 0 ; DATA6=(com &amp;(0x01&lt;&lt;6)) ? 1 : 0 ; DATA7=(com &amp;(0x01&lt;&lt;7)) ? 1 : 0 ; ｝ 当调用该函数时，错误案例是无法实现相应的输出的 1DATA_Process(0xff); 提示：因为是 按位&amp; ，所以得出来的值 并非 1 或0 ；只有 &amp;&amp; 条件判断 才是得出来的值 1或0。 2.4 优先级 三、预处理&emsp;&emsp;预处理是在编译环节中最早开始执行的，并且后面的代码(因条件变化)都不会影响到任何预处理的一些操作(例如：#define) 3.1 宏定义12#define //定义一个预处理宏#undef //取消宏的定义 举例如下 1#define SREG (*(volatile unsigned char*)0x5F) &emsp;&emsp;嵌入式系统编程，要求程序员能够利用C语言访问固定的内存地址。 既然是个地址，那么按照C语言的语法规则，这个表示地址的量应该是指针类型。 所以，知道要访问的内存地址后，比如0x5F，第一步是要把它强制转换为指针类型(unsigned char*)0x5F，AVR的SREG是八位寄存器，所以0x5F强制转换为指向unsigned char类型。 volatile（可变的）这个关键字说明这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。这种“意想不到地改变”，不是由程序去改变，而是由硬件去改变——意想不到。 第二步，对指针变量解引用，就能操作指针所指向的地址的内容了*(volatile unsigned char*)0x5F 第三步，小心地把#define宏中的参数用括号括起来，这是一个很好的习惯，所以 #define SREG ((volatile unsigned char)0x5F) 类似的，如果使用一个32位处理器，要对一个32位的内存地址进行访问，可以这样定义： 1#define RAM_ADDR (*(volatile unsigned long *)0x0000555F) &emsp;&emsp;然后就可以用C语言对这个内存地址进行读写操作了. 读：tmp = RAM_ADDR；写：RAM_ADDR = 0x55； 3.2 条件编译12345678910#ifdef //判断某个宏是否被定义，若已定义，执行随后的语句#ifndef //与#ifdef相反，判断某个宏是否未被定义#if //编译预处理中的条件命令，相当于C语法中的if语句#elif //若#if,或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if#else //与#if对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else#endif //#if,#ifdef,#ifndef,这些条件命令的结束标志#error //用于生成一个编译错误的消息，并停止编译 条件编译的意义，实际工程中条件编译主要用于以下情况： 不同的产品线公用一份代码 区分编译产品的调试版和发布版 方便变动程序，例如不同的软件驱动方式 举例： 123#if Test_Version_Enable #error "The version is a test version,please try it to be unable"#endif 四、函数的设计技巧 参数名要能够体现参数意义 如果说传递的参数为指针，且仅仅作输入参数用，则应在类型前加const，以防止该指针在函数体内被恶意修改 不要省略返回值的类型，如果函数没有返回值，那么应当声明为void 在函数体的“入口处”，对参数的有效性进行检查，对指针的检查尤为重要 语句不可返回指向“栈内存”的“指针”，因为该内存会在函数结束后销毁 相同的输入应当产生相同的输出，尽量避免函数带有“记忆”功能少用static 避免函数有太多的参数，参数个数应当控制在4个以内 有时候函数不需要返回值，但是增加灵活性，可以附加返回值]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>符号</tag>
        <tag>预处理</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迟来的总结]]></title>
    <url>%2F2020%2F03%2F14%2F%E8%BF%9F%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近真的是，又懒又菜啊！整理这么久= =]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划整理]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%AE%A1%E5%88%92%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[作为备忘录，记录自己要做的事情 11点睡觉 健身，跑步 时常要审视自己:对熟人的态度，对陌生人的态度 linux ucosii 有道云笔记c语言整理 学习github代码管理 嵌入式C_博文改进：结构体成员指针初始化问题，看收藏，或者第一本笔记 modbus通讯_博文改进(1)Modbus从机(2)Modbus主机(3)Modbus通讯例子 中断_定时器_博文改进：(1)待增加线程任务(2)定时器延时的副作用，轮询，扫描按键作为举例 Keil软件配置_博文改进：增加github上传处理 TCP/IP博文 差驱动 英文 注释 perip 外围 param 参数 offset 偏移 backups 备份 宏定义尝试修改SPI meset panel IO口自定义管脚博文 ADC转换带滤波博文（未来）（IF（实际重量》最大量程+9*分度） ofl） leetcode modbus通讯暂时]]></content>
  </entry>
  <entry>
    <title><![CDATA[IO口配置]]></title>
    <url>%2F2020%2F01%2F14%2FIO%E5%8F%A3%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇为基本IO配置，其思路适用于任意款MCU 一、STM32四种管脚模式对比 普通推挽输出（ GPIO_Mode_Out_PP ） :使用场合：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。使用方法：直接使用输出电平：推挽输出的低电平是 0V，高电平是 3.3V。 普通开漏输出（ GPIO_Mode_Out_OD ）：使用场合：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。输出电平：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。特性： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。 复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。 复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。 Ps：所有的开漏输出都需要接上拉电阻 二、IO(按键)输入消抖&emsp;&emsp;IO(按键)输入的消抖，往往是嵌入式开发的排名前几门基础课。消抖方法分为2种：1)硬件消抖； 2)软件消抖；这里就不讲解硬件消抖方式，主要讲软件消抖； 软件消抖也分为2种: 死循环延迟消抖 定时器轮询消抖； 这里讲解采用定时器轮询消抖方式。 定时器轮询消抖有什么好处？ 那 定时器轮询消抖 需要什么？ 实现思路、功能分层？ Ps：轮询的好处：IO(按键)输入的响应速度，直接与(裸机)系统效率挂钩；一旦其他地方出现问题，程序bug存在可以影响到IO(按键)输入的响应速度；采用轮询机制，在MCU从裸机移植到系统上，也会是十分便利 定时器轮询消抖的好处：很明显，相对死循环延迟，定时器轮询 不会空白占用浪费CPU的资源 定时器消抖需要一个定时器；往往在MCU系统中，一般有公用基准1ms的定时器，用于各类操作，直接采用该定时器即可 实现思路、功能分层？以下均为实现功能的函数1)(基本的)IO口初始化配置2)无消抖 单输入(按键)扫描3)消抖处理：循环调用 无消抖单输入扫描；每次程序重新轮询一次，检查现电平状态相比之前是否翻转；翻转则重新备份时间(采取定时器当前时间)，利用备份时间和当前时间 计算出来的时间差，实现延时消抖； 三、IO口自定义功能&emsp;&emsp;IO口自定义是一个在基础功能外扩展的功能；当我们有一定量的IO(按键)输入和输出时，哪个输入(按键)往往都制定好什么功能，输出IO也根据程序条件判断做对应操作；举个例子，当我们想把A键的功能和B键的功能互挪，我们就需要重新更改固件程序；IO口自定义，可以实现无需更改固件程序，直接在线更改输入输出管教功能。 实现思路如下：&emsp;&emsp;将各种功能以枚举的方式罗列出来；利用数组的方式，将 IO口[功能] 和 功能[IO口] 两个数组，相互映射；先由 IO口 映射到 功能 去 ，程序只根据条件变动 功能 ，然后再 功能 映射回 IO口 ，实现底层的电平操作 以下为实现IO口自定义功能的细节： 1)额外设计掉电储存功能；因为当你设置好每个按键功能后，如果掉电不保存，则每次重新上电需要重新设置功能；2)程序上电初始化，先进行IO口初始化；然后再进行IO口自定义初始化：从掉电存储读取IO功能，更新到对应的IO口；每次更新功能，存储一次对应掉电数据，读取数据只在重新上电初始化执行一次；3)自定义功能复位；每个可自定义功能的IO口，原本就该有自带的默认功能，然后根据需求再改动，对应的，也要有复位默认功能的操作； 数据掉电保存方法 1)外扩额外的ROM(例：24C02)2)基于备份寄存器特点：备份寄存器是依赖者备份电源的，当外界的VDD掉电，只要系统的VBAT能正常存在，那么Bakeup Domaain Registers的内容可以被正常保存起来。3)基于内部闪存原理：FLASH 存储器又称为闪存，它也是可重复擦写的储器。它分为 NOR FLASH 和 NAND FLASH，NOR FLASH一般应用在代码存储的场合，如嵌入式控制器内部的程序存储空间；而 NAND FLASH 一般应用在大数据量存储的场合，如U 盘以及固态硬盘等，一般都是 NAND FLASH 类型的。 &emsp;&emsp;在stm32芯片中，Flash的读写单位都是以“页”为单位的，以STM32F103C8T6为例，它的每页大小为2K bytes;读写保护解除：使用这种方法前提是，当前Flash页的读和写是允许的。 特点：使用该方法，相对比较复杂。但是由于保存数据以页为单位，页的大小可以多达2048bytes，所以该方法可以实用于保存掉电不易失的大数据。考虑到flash读写保护的逻辑机制，该方法最好在不考虑数据的安全性问题前提下，才使用这种方法。 四、预置点4.1 常规预置点4.2 优化预置点五、IO辅助逻辑]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>IO口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32开发]]></title>
    <url>%2F2020%2F01%2F09%2FSTM32%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;持续断断续续更新ing；现已更新完毕~ 一、迁移工程&emsp;&emsp;keil建立工程，需要添加启动文件，需要修改魔术棒设置，需要添减文件和文件路径等等……,不难，倒是很麻烦；如果有现成的工程（往往都会有现成的工程），只需要稍微修改工程信息，借助这个基础工程会节省点偷懒点时间；故，说明下如何简单快速的修改工程；简单3个步骤很实用！！！ 在工程文件目录中，将old.uvoptx和old.uvprojx名字改成new.uvoptx和new.uvprojx。并其他 .uvoptx文件统统删除。如： 双击打开new.uvproj,点击，在弹出的界面上，双击“Progect target”下面的工程名，修改成new 点击魔术棒，将Name of Executeable中的名称改为new即可，这表示生成的hex文件是new.hex，F7编译一遍，再双击new工程名字，说明形成了新的new.map文件，建立成功了 注意：最好先kill重编译，若编译后还有带不需要的文件，删除后重新编译即可。 二、常见驱动异常2.1 驱动异常 &amp; 复用时钟&emsp;&emsp;AFIO时钟只是在STM32F1系列里被提及。 对于32F1系列，涉及到管脚的EXTI、 REMAP、默认复用管脚(JTAG管脚)、事件输出时就需要开启AFIO时钟。 Bug现象：刚写一个 功能(驱动)，出现异常；经过多次排查后，发现是IO管脚驱动初始化的问题。经测试，部分IO位无法正常响应置复位的操作。 问题来源： IO时钟使能错误； 外设时钟未使能； 该管脚为默认复用管脚； 举例：STM32默认启动时PB4、PB3、PA15三个引脚不是普通IO，而是JTAG的复用功能，分别为JNTRST、JTDI、JTDO。如果作为普通IO使用，要先开启复用时钟，再关闭JTAG复用功能，才能作为普通IO口使用。 12RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //使能复用时钟GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);//关闭jtag，使能SWD，可以用SWD模式调试 划重点：初始化中，必须使能 复用端口RCC_APB2Periph_AFIO的时钟 才能对应关闭JTAG功能(没开启复用时钟，只关闭JTAG复用的操作是无效的)。 &emsp;&emsp;对于STM32F1以外的其它STM32系列，不再提AFIO，多了个SYSCFG(系统控制器)外设，其功能跟F1的AFIO 有些类似但有差异：主要管理内存空间的映射、与EXTI中断源有关的IO配置以及其它配置等事务，不同32系列间还各有细小差异。如果不打开SYSCFG时钟，有关内存空间重映射、与EXTI配置的操作就会无效。 2.2 宏定义值错误&emsp;&emsp;库函数的实现，实际上就是把寄存器抽象成一个个变量，宏定义很多替换值对其进行赋值操作；由于可能不同寄存器在同一个32位bit内，因此赋值操作过程中会进行位与操作，防止改写掉其他寄存器配置。 &emsp;&emsp;因此，往往库函数的宏定义配置，其替换值往往都是32bit的；类型都一样，编译器是无法识别出你赋错值，例如你写错宏定义进去，编译器并不会报错。 举具体两个例子： 123//错误的写法RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //使能 GPIOB端口 时钟RCC_APB2PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); //使能 串口2 时钟 &emsp;&emsp;很明显，上面两行代码的时钟使能是错误的，但是编译是不会报错的；因为本质上就是一个赋值操作，赋错值并不会产生报错，除非类型不同、宏定义名称查询不到。不单单是IO的驱动，不管是什么驱动，大家在配置底层驱动的时候一定要细心，配置错误不会报错警，但是会卡住你项目进度。 123456789//错误的写法GPIO_PinAFConfig(GPIOC,GPIO_Pin_10,GPIO_AF_SPI3);GPIO_PinAFConfig(GPIOC,GPIO_Pin_11,GPIO_AF_SPI3);GPIO_PinAFConfig(GPIOC,GPIO_Pin_12,GPIO_AF_SPI3);//正确的写法GPIO_PinAFConfig(GPIOC,GPIO_PinSource10,GPIO_AF_SPI3);GPIO_PinAFConfig(GPIOC,GPIO_PinSource11,GPIO_AF_SPI3);GPIO_PinAFConfig(GPIOC,GPIO_PinSource12,GPIO_AF_SPI3); 三、STM32管脚四种输出模式对比 普通推挽输出（ GPIO_Mode_Out_PP ） : 使用场合：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。 使用方法：直接使用 输出电平：推挽输出的低电平是 0V，高电平是 3.3V。 普通开漏输出（ GPIO_Mode_Out_OD ）： 使用场合：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。 输出电平：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。 特性： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。 复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。 复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。 Ps：所有的开漏输出都需要接上拉电阻 四、中断优先级&emsp;&emsp;中断的概念具体就不赘述，这里以stm32F103RBT6芯片为例讲中断配置 4.1 抢占优先级和响应优先级&emsp;&emsp;STM32的中断向量具有两个属性，一个为抢占属性，另一个为响应属性，其属性编号越小，表明它的优先级别越高。&emsp;&emsp;抢占，是指打断其他中断的属性，即因为具有这个属性会出现嵌套中断（在执行中断服务函数A 的过程中被中断B打断，执行完中断服务函数B，再继续执行中断服务函数A），抢占属性由NVIC_IRQChannelPreemptionPriority 的参数配置。&emsp;&emsp;响应，应用在抢占属性相同的情况下，当两个中断向量的抢占优先级相同时，如果两个中断同时到达，则先处理响应优先级高的中断， 响应属性由NVIC_IRQChannelSubPriority 参数配置。&emsp;&emsp;如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行 4.2 NVIC 的优先级组&emsp;&emsp;STM32的NVIC 有十六个优先级。 （一）STM32分组为：组0-4 （二）分组配置在寄存器SCB-&gt;AIRCR中： （三）解析第二点 组0就是4位都用来设置成响应优先级，2^4=16位都是响应优先级 组1分为(2^1)两个抢占优先级，在这两个抢占优先级里面还分别有(2^3)八个响应优先级，(2^1)*(2^3) =16 组2分为(2^2)四个抢占优先级，在这四个抢占优先级里面还分别有(2^2)四个响应优先级，(2^2)*(2^2) =16 组3分为(2^3)八个抢占优先级，在这八个抢占优先级里面还分别有(2^1)两个响应优先级，(2^3)*(2^1) =16 组4分为(2^4)十六个都是抢占优先级(2^4) =16 （四）配置示例 12NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级//也就是说可以配置成四个抢占优先级，在这四个抢占优先级中还可以配置四个响应优先级 （五）优先级顺序举例 &emsp;&emsp;假定设置中断优先级组为2，然后设置如下： 中断3(RTC中断)的抢占优先级为2，响应优先级为1 中断6（外部中断0）的抢占优先级为3，响应优先级为0 中断7（外部中断1）的抢占优先级为2，响应优先级为0。 &emsp;&emsp;那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6 五、定时器&emsp;&emsp;STM32的高级定时器TIM1, TIM8以及通用定时器TIM9, TIM10, TIM11的时钟来源是APB2总线;通用的 TIM2、TIM3、TIM4和TIM5 定时器 挂载在低速的APB1总线上。 5.1 F103定时器时钟疑问疑问： 以F103为例，APB1 提供时钟：他的最大值是 36M。有很多人不理解，为什么 TIM2 的时钟不是 36M 而是 72M呢？ 解答：通用定时器（TIM2-7）的时钟不是直接来自APB1，而是通过APB1的预分频器以后才到达定时器模块 &emsp;&emsp;APB1 的时钟最大只能是 36M,在 RCC 时钟配置的函数，也就是程序最开始初始化系统时钟到 72M（AHB）的时候,里面有 1RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2; 除以了 2，也就是在我们配置 AHB 为 72M 的时候 APB1 是 72/2=36M 。根据当APB1的预分频系数为1 时，这个倍频器不起作用，定时器的时钟频率等于 APB1 的频率；当 APB1 的预分频系数为其它数值(即预分频系数为 2、4、8 或 16)时，这个倍频器起作用，定时器的时钟频率等于 APB1 的频率两倍。这里我们设置的是 2，那么到定时器就要乘以 2，那么就是 72M 了。 &emsp;&emsp;综上，通用定时器的时钟最大为72MHz，挂在APB1上除了通用定时器的其他外设时钟最大为36MHz。这样设计的目的就是让挂在APB1上的低速外设有合适的低速时钟，同时还可以让挂在APB1上的通用定时器能够在不影响低速外设的情况下仍然有高速的时钟。(注：系统时钟初始化后，默认AHB是72MHz，APB1是AHB的2分频36MHz，通用定时器时钟是APB1的两倍72MHz) 5.2 定时器计时算法&emsp;&emsp;定时器跟时间相关的量有：系统时钟、分频系数、重装载值。 系统时钟: 默认不配置的时候是72M，可以根据自己需求配置； 分频系数: psc,就是对系统时钟进行多少分频之后在使用，最好设置为72的倍数，方便运算； 重新装载值: arr,是计算这么多值，时间到了之后重新开始计算的值，每一次计数的时间为分频之后时钟的到时； 举例：假设系统时间72M，分频系数设置为7200-1，那现在定时器的时钟为10kHz，每计一个数花费1/(10000)秒，重装值设置为5000-1，那一次溢出的时间为500ms。 Time = ((period+1)*(prescaler+1))/sysclock time：溢出时间(MHz) sysclock：系统时钟(us) period：重装值 prescaler：分频系数 time = ((4999+1)*(7199+1))/72 = 5000 000us = 500ms Ps：定时器的重装值不能为0。 &emsp;&emsp;以上面为例：不改动分频系数的情况下，重装值设置为5000-1，那一次溢出的时间为500ms。如果让溢出的时间为1ms，那重装值要设置为10-1；但是无法设置溢出时间为0.1ms，重装值不能为1-1。该最小的定时溢出时间为2-1，即2ms触发一次定时器中断。 5.3 计时拓展&emsp;&emsp;定时器的计时可以采用 任务机制回调；实现思路如下： 创建结构体数组，用于存放 多定时器任务 数据；结构体内容如下： 123456789/*******************************************************************************块注释：结构体定义声明*******************************************************************************/typedef struct&#123; volatile uint32_t Time_task_name; //任务名称（组名称或上ID号码） volatile uint32_t Time_Out; //超时时间 volatile uint32_t Time_Count; //任务启动为止到当前的时间 FUNCTION* callback_F; //回调函数&#125;TIMER_TASK; //定义添加执行任务所需要的数据 创建任务需要：任务名称，设定时间，回调函数名； 定时器中断会循环检索任务的存在；如果任务存在则对应的Time_Count(任务计时)++；如果Time_Count和Time_Out(设定时间)相同，则重置Time_Count，并执行回调； 回调函数一般短小精悍，因为是在中断内检索处理；用于置某些标志位或者关闭自身定时器任务 实现具体细节如下(以函数为划分)： 创建某个定时器任务 复位某个定时器任务 清除某个定时器任务(一般在执行回调函数中使用) 清除全体定时器任务 获取当前定时器计数(其值为该函数返回值) 六、串口通讯&emsp;&emsp;这里讲串口常见概念和现象。 6.1 TXE 和 TC&emsp;&emsp;串口的发送TX标志位 USART_FLAG_TXE 和 USART_FLAG_TC的理解: TXE是指“手里要搬运的”空； TC 是指“地上要搬运的”空； USART_FLAG_TXE 来说，只是说明数据寄存器中的数据已经被发送移位寄存器取走了 USART_FLAG_TC来说，没必要每次当发送移位寄存器中的数据发送完成后都发生中断，而应该是整个串口数据帧全部发送完毕，包括最后一个字节也发送出去之后才应该开中断，这代表的就是一个数据帧发送完成事件了。 6.2 不停进入串口中断的Bug&emsp;&emsp;Bug现象：在使用stm32的时候，发现usart会莫名的卡在串口中断里，然而串口初始化只配置了RXNE中断，打断点发现不断进入中断却发现不是RXNE中断引起的 该Bug来源：经过查找资料发现是ORE的问题：开启RXNE中断同时， ORE 也会被开启； 但是如果直接用 USART_GetITStatus 无法读取到ORE标志位 置位的信息，这样也就无法消除中断申请(不知道什么时候置位)，一直进入串口中断；因为我们没有使能ORE标志位，所以才读不到 置位 信息；故 1USART_ITConfig(USART1, USART_IT_ORE, ENABLE); 然后在串口中断内做对应处理： 12345//注意！不能使用if(USART_GetITStatus(_UART_M, USART_IT_RXNE) != RESET)来判断if(USART_GetITStatus(_UART_M,USART_IT_ORE) != RESET)&#123; USART_ClearITPendingBit(_UART_M,USART_IT_ORE);&#125; STM32中文参考手册541页，内容如下： ORE：过载错误 (Overrun error) &emsp;&emsp;当RXNE仍然是’1’的时候，当前被接收在移位寄存器中的数据，需要传送至RDR寄存器时，硬件将该位置位。如果USART_CR1中的RXNEIE为’1’的话，则产生中断。由软件序列将其清零(先读USART_SR，然后读USART_CR)。 0：没有过载错误； 1：检测到过载错误。注意：该位被置位时， RDR寄存器中的值不会丢失，但是移位寄存器中的数据会被覆盖。如果设置了EIE位，在多缓冲器通信模式下，ORE标志置位会产生中断的 &emsp;&emsp;关于ORE的更细致处理方法主要还是参照下面几个博主的文章： STM32串口中断卡死主循环问题分析关于USART接收中断的BUG和注意事项关于STM32不断进入串口中断的问题]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hi,2020]]></title>
    <url>%2F2019%2F12%2F31%2FHi-2020%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今年要好好干，努力奋斗！不要拖稿；干就完了！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议(下)]]></title>
    <url>%2F2019%2F12%2F28%2FTCPIP-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发 一、基础知识&emsp;&emsp;这里将会连续引申出微观TCP/IP协议的一些概念。嵌入式的TCP通讯最重要的一个概念，就是IP地址。 1.1 IP地址1.1.1 概念&emsp;&emsp;IP地址，英文名为IP Address，是internet protocol address的缩写，译为互联网协议地址，又译为网际协议地址。它是IP协议（internet protocol ）提供的一种统一的地址格式，分配给使用IP协议的设备的数字标签。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。更通俗的来说，IP地址给网上的每个通信设备分配了一个编号，每台联网的主机都需要有这个编号来通信。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。 1.1.2 表示通常所说的IP地址，是指IPv4。IP地址是一个32位的二进制数，例如： 100000000111111110000000011111111 通常被分割为4个8位二进制数，例如上面这个IP地址，可以分割为如下形式： 100000000 11111111 00000000 11111111 再使用十进制数来表示每个8位二进制数，十进制数之间使用点号分隔，IP地址最终表示成如下形式： 1a.b.c.d 因为一个8位二进制数表示的范围00000000 ~ 11111111正好对应十进制数0 ~ 255，所以a、b、c和d都是0 ~ 255的十进制整数。例如上面IP地址，可以表示为0.255.0.255.（1）冒分十六进制表示法 1X:X:X:X:X:X:X:X &emsp;&emsp;其中每个X表示地址中的16b，以十六进制表示，例如： 1ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 &emsp;&emsp;这种表示法中，每个X的前导0是可以省略的，例如： 12001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A （2）0位压缩表示法&emsp;&emsp;在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如： 123FF01:0:0:0:0:0:0:1101 → FF01::11010:0:0:0:0:0:0:1 → ::10:0:0:0:0:0:0:0 → :: （3）内嵌IPv4地址表示法为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为： 1X:X:X:X:X:X:d.d.d.d 前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如: 1::192.168.0.1与::FFFF:192.168.0.1 就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。 1.1.3 IPv4地址分类网络号或网络地址（NetID）：用于识别主机所在的网络；主机号或主机地址（HostID）：用于识别该网络中的主机；&emsp;&emsp;为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。私有地址：所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址。 类别 用途 网络号和主机号 最高位 地址范围 私有地址和保留地址 子网掩码 A 保留给政府机构 第一段表示网络地址，剩下三段表示主机地址 0 0.0.0.0——127.255.255.255 ①10.X.X.X是私有地址 ②127.X.X.X是保留地址 255.0.0.0 B 分配给中等规模的公司 前两段表示网络地址，后两段表示主机地址 10 128.0.0.0——191.255.255.255 ①172.16.0.0—172.31.255.255是私有地址②169.254.X.X是保留地址；191.255.255.255是广播地址，不能分配。 255.255.0.0 C 分配给任何需要的人 前三段表示网络地址，剩下一段表示主机地址 110 192.0.0.0——223.255.255.255 192.168.X.X是私有地址 255.255.255.0 D 用于组播 不分网络地址和主机地址 1110 224.0.0.0——239.255.255.255 E 用于实验 不分网络地址和主机地址 11110 240.0.0.0——255.255.255.254 如图： &emsp;&emsp;这里就不再详细介绍IP地址中的一些特殊地址了；我们目前主要用的是C类别，也就是192.168.X.X的私有地址 1.2 子网掩码&emsp;&emsp;IP地址填完后，网段不同，是并不能够直接通讯的；(平常)路由器连接的是不同的网络，网桥连接的是不同网段，这里的网络和网段有什么区别呢？ 1.2.1 网段&emsp;&emsp;路由器连接的是不同的网络，这里的网络就是网段不同的网段和不同的网络是同一个概念；专业点就说网段，通俗一点就说网络，其实就是一个意思。 那什么是同一网段？同一网段指的是IP地址和子网掩码相与得到相同的网络地址；想在同一网段，必需做到网络标识相同；各类IP的网络标识算法都是不一样的，需要根据子网掩码的位数来判断。 那什么是掩码？ 想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？ 1.2.2 掩码&emsp;&emsp;掩码，是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。用途：将源码与掩码经过按位运算或逻辑运算得出新的操作数。其中要用到按位运算如OR运算和AND运算。用于如将ASCII码中大写字母改作小写字母。 举例：如A的ASCII码值为65= (01000001)2，a的ASCII码值为97=(01100001)2，要想把大写字母A转化为小写字母只需要将A的ASCII码与(00100000)2进行或运算就可以得到小写字母a。&emsp;&emsp;子网掩码，即就是用来算网络标识的掩码. 1.2.3 网络标识 算法只要把IP和子网掩码的每位数AND就可以了。 AND方法：0&amp;1=0 0&amp;0=0 1&amp;1=1 如：And 192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位 123IP 11000000.10101000.00000000.00000001子网掩码 11111111.11111111.11111111.00000000得出AND结果 11000000.10101000.00000000.00000000 转换为十进制192.168.0.0，这就是网络标识， 再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP AND 得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1；这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。 这里介绍最常用的两种子网掩码，它们分别是“255.255.255.0”和“255.255.0.0”。 1.3 网关地址&emsp;&emsp;如果网段不同，就实现不了通信，但现实生活中那么多设备肯定不在同个网段；那么不同网段确能够通信，就需要 网关 了.&emsp;&emsp;网关（gateway）是一个网络连接到另一个网络的“关口”，网关地址实质上是一个网络通向其他网络的IP地址，主要用于不同网络间数据传输。网关在网段内的可用ip中选一个，一般选择是第一个或最后一个。 举例:比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1 ~ 192. 168.1.254”，子网掩码是255.255.255.0；如果需要与其他网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其他的一个IP地址。网络B的IP地址范围是“192.168.2.1 ~ 192.168.2.254”，子网掩码255.255.255.0。如果需要与其他网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。 网关是如何实现通信？&emsp;&emsp;在没有路由器的情况下，不同的网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的的主机不再本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。所以说，设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。 网关设置方式有哪些？ 手动设置：手动设置适用于电脑数量比较少、TCP/IP参数基本不变的情况，比如只有几台到十几台电脑。因为这种方法需要在联入网络的每台电脑上设置“默认网关”，非常费劲，一旦因为迁移等原因导致必须修改默认网关的IP地址，就会给网管带来很大的麻烦，所以不推荐使用。 自动设置：利用DHCP服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。 1.4 MAC地址&emsp;&emsp;媒体访问控制（media access control，MAC）是物理地址、硬件地址，用来定义网络设备的位置。 ip是虚拟地址；mac是网卡地址全世界只有一种没重复的。MAC是网络中用来识别网卡设备的唯一网络地址；由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的 1.5 DNS&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的； 举例 ，例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。 这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置的话，是无法正常访问网页的。 1.6 Socket 和 端口号&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。 这里引入 端口号 的概念：一个计算机上可以有多个进程作为(多个)服务器 or 客户端 ，但是 ip 每个机器只有一个，所以通过不同的 port 数字加以区分。 Ps：端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。 &emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。 Socket ： 就是指代承载这种通讯的系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号) Ps：Socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。 二、基于W5500的TCP通讯&emsp;&emsp;等待更新中。。。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 协议 (上)]]></title>
    <url>%2F2019%2F12%2F27%2FTCPIP-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍宏观层面的TCP/IP协议 一、TCP/IP 协议的层次结构(宏观)&emsp;&emsp;TCP/IP参考模型分为四个层次：应用层、传输层、网络(互连)层和主机到网络层(数据链路层) 1.1 应用层&emsp;&emsp;应用层面向不同的网络应用引入了不同的应用层协议。 传输层采用TCP协议的有：HTTP：超文本传输协议（Hyper Text Transfer Protocol）HTTPS:超文本传输安全协议（Hyper Text Transfer Protocol Secure）FTP：文件传输协议（File Transfer Protocol）它定义了本地登录用户与远程服务器之间的交互过程。SFTP：文件加密传输协议（Secure File Transfer Protocol）TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. 传输层采用UDP协议的有：（一次性传输的数据需求很少）TFTP：简单文件传输协议（Trivial File Transfer Protocol）FTP的简化版本SNMP：简单网络管理协议（Simple Network Management Protocol）该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等.NTP：网络时间协议（Network Time Protocol） 传输层同时采用TCP和UDP协议的有：DNS(域名系统)：该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. Ps：HTTP是面向网页（文本信息）的，而FTP是面向文件的 1.2 传输层TCP：传输控制协议（transmission control protocol）UDP：用户数据报协议（user datagram protocol） TCP与UDP的区别： 基于连接与无连接; 对系统资源的要求（TCP较多，UDP少）; UDP程序结构较简单; 流模式与数据报模式; TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证. TCP 与 UDP 的主要区别：&emsp;&emsp;UDP具有TCP所望尘莫及的速度优势，但在于UDP不一定提供可靠的数据传输。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。 Ps：许多程序将使用单独的TCP连接和单独的UDP连接;重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。 1.3 网络层（网络互连层） &emsp;&emsp;网络互连层定义了分组格式和协议。 &emsp;&emsp;网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。 IP：Internet 协议（Internet Protocol）ICMP：Internet控制信息协议ARP：地址解析协议RARP：反向地址解析协议 1.4 网络访问层（主机到网络层） &emsp;&emsp;网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接。 二、部分具体介绍&emsp;&emsp;TCP/IP协议：是一组网络协议。在这些协议中，最重要、最著名的就是TCP和IP因此，大部分网络管理员称整个协议族为“TCP/IP”。包括：TCP，IP，UDP，ARP等，这些被称为子协议。 2.1 TCP与IP的区别&emsp;&emsp;由第一章的TCP/IP 协议的层次结构可知，TCP 和 IP 是在不同层的，因此两者本来就天差地别。TCP：位于传输层，是一种面向连接的、端对端的、可靠的、基于IP的传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。IP：位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交办法和路由选择。 总结： 整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层————TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。 TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。 2.2 Telnet的衍生（SSH等）&emsp;&emsp;TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能;听起来很陌生，但实际上我们是经常使用远程登录的功能，即使用Telnet的衍生;&emsp;&emsp;Telnet用来訪问远程计算机的TCP/IP协议以控制你的网络设备，是明码传输，缺乏安全性。因此诞生了远程登录的加密传输，如下： SSH：Secure Shell（包括SSH1和SSH2）Telnet/SSL： Secure Socket Layer。Telnet/SSL是带有SSL的Telnet。Rlogin：Rlogin和Telnet功能使用方法相似，可是简单非常多。Serial：串行指每次一个事件，它通常跟并行即一次发生多个事件相反，例如键盘和鼠标仅仅须要串行接口和线路TAPI：telephone Application Programming Interface （它能够使用户在电脑上通过电话或视频电话与电话还有一端的人进行交谈）电话应用编程接口RAW：大多数打印设备的默认协议 2.3 VPN和SS、SSR&emsp;&emsp;这里讲一下大家常见到的VPN和SSR的来头。 2.3.1 什么是VPN&emsp;&emsp;vpn在很多人心目中就是用来科学上网的工具，其实不是。vpn最主要的功能，并不是用来科学上网，只是它可以达到科学上网的目的。vpn–虚拟专用网络，它的功能是：在公用网络上建立专用网络，进行加密通讯。 2.3.2 什么是ss/ssrss：ss作者是clowwindy，大约两年前，他自己为了科学上网写了shadowsocks，简称ss或者叫影梭，后来他觉得这个东西非常好用，速度快，而且不会被封锁，他就把源码共享在了github上，然后就火了，但是后来作者被请去喝茶，删了代码，并且保证不再参与维护更新。现在这个好像是一个国外的大兄弟在维护。 ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，然后ss用户和ssr用户自然分成了两个派别，互相撕逼，直到前阵子，破娃被人肉出来，无奈之下删除了ssr的代码，并且解散了所有相关群组。 ss和ssr它的原理都是一样的，就是socks5代理。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了科学上网。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window的简易bat处理]]></title>
    <url>%2F2019%2F12%2F22%2FWindow%E7%9A%84%E7%AE%80%E6%98%93bat%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;脚本往往是用来批处理等一些简单的操作等等，因此脚本的编写往往比较简单；这里介绍Window环境下的脚本：Batch(批处理)，可以用于嵌入式批处理一些中间文件 或者 是用来做一些平常处理的快捷操作 一、脚本知识&emsp;&emsp;批处理(Batch)，也称为批处理脚本。批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。&emsp;&emsp;脚本(Script)：是一种批处理文件的延伸，是一种纯文本保存的程序。简介：脚本简单地说就是一条条的文字命令，这些文字命令是可以看到的（如可以用记事本打开查看、编辑），脚本程序在执行时，是由系统的一个解释器，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。因为脚本在执行时多了一道翻译的过程，所以它比二进制程序执行效率要稍低一些。 常见的脚本语言有：Scala、JavaScript，VBScript，ActionScript，MAX Script，ASP，JSP，PHP，SQL，Perl，Shell，python，Ruby，JavaFX，Lua，AutoIt等。 &emsp;&emsp;Makefile：类似shell脚本；Linux的编译程序通过make命令，编译大文件（需要批量处理文件），则需用到Makefile文件 1.1 题外话 &emsp;&emsp;一个C/C++文件要经过预处理（preprocesing）、编译（compilation）、汇编（assembly）、链接（linking） 等四步才能变成可执行文件（实际还是机器码）。在日常交流中通常使用“编译”统称这四个步骤。 .s文件、.S文件和.o文件的区别 .s：汇编语言源程序；操作: 汇编在后期阶段不会再进行预处理操作了，所以我们不能在其内写上预处理语句. .S：汇编语言源程序；操作: 预处理 + 汇编会进行预处理、汇编等操作，所以我们可以在这里面加入预处理的命令。编译器在编译汇编大 S 文件之前会进行预处理操作. .o文件：只编译不链接形成.o文件.里面包含了对各个函数的入口标记，描述，当程序要执行时还需要链接(link).链接就是把多个.o文件链成一个可执行文件。如 GCC 编译器就可以指定 -c选项进行输出。打开是乱码。 .dis文件：反汇编文件 &emsp;&emsp;.s文件一般是 .c文件经过汇编器处理后的输出。 如 GCC 编译器就可以指定 -S 选项进行输出，且是经过预处理器处理后的了。 例如：gcc -S test.c—–生成.s结尾的文件，打开为汇编代码例如：gcc -c test.c—–结果生成.o文件. 二、常见批处理指令&emsp;&emsp;这里只介绍一些小白入门的bat指令，不会太过深入，只是用来简化用电脑时的平常处理；Ps:cmd命令是不区分大小写的 2.1 rem 和 ::REM ，为注释命令，一般用来给程序加上注解，该命令后的内容不被执行，但能回显；:: ，为注释命令，但后面字符行在执行时不会回显 2.2 echo 和 @&emsp;&emsp;这里编写一个.bat文件作为举例： 12345@echo offecho 这是测试内容的第1行echo 这是测试内容的第2行echo endpause 如上面源码所示 修改文件内容，将其中的@ 符号去掉 继续修改文件内容，将第一条命令注释掉(::) 总结：@echo off表示执行了这条命令后关闭所有命令(包括本身这条命令)的回显。echo off 命令则表示关闭其他所有命令(不包括本身这条命令)的回显；@ 的作用就是关闭紧跟其后的一条命令的回显 2.3 pause&emsp;&emsp;如果你自己编写的.bat文件，双击打开，出现闪退；原因：执行速度很快，执行完之后，自行关闭；&emsp;&emsp;解决办法：在最后面一行加上 pause pause，停止系统命令的执行并显示下面的内容;最常见的就是：请按任意键继续. . . 不显示请按任意键继续. . .的方法：pause >nul显示其他提示语的方法：echo 其他提示语 & pause >nul 2.4 titletitle,用于设置cmd窗口的标题title 新标题 可以看到cmd窗口的标题栏变了 2.5 modemode，配置系统设备&emsp;&emsp;这里就不详细讲解，有兴趣的话，可以直接help mode查看；下面举一个控制窗口大小的例子： 12345@echo off@mode con lines=18 cols=55echo "Hello World !"pause 2.6 start&emsp;&emsp;批处理中调用外部程序的命令（该外部程序在新窗口中运行，批处理程序继续往下执行，不理会外部程序的运行状况），如果直接运行外部程序则必须等外部程序完成后才继续执行剩下的指令 例： 调用图形界面打开D盘start explorer d:&lt;/code> 启动一个新的cmd窗口并在其内执行命令start cmd /k echo Hello, World! 2.7 cd同一分区切换:cd [盘符][路径]不同分区切换:cd /d [盘符][路径] Ps： 可以用 echo %cd% 查看当前路径 2.8 dir&emsp;&emsp;dir:获取某个文件夹下所有的文件名及扩展;详细的命令用help查看，下面举常见例子 dir /a 显示当前目录中的文件和子目录，包括隐藏文件和系统文件 dir c: /a:d显示 C 盘当前目录中的目录 dir c: /a:-d显示 C 盘根目录中的文件 dir c:" /b/p/b只显示文件名，/p分页显示 c:\dir /s /q /a *.exedir *.exe /s查找当前目录（包括子目录）下所有的exe文件 c:\dir /q /a *.exe查找当前目录下以a开头的exe文件 2.9 del&emsp;&emsp;要知道区别，就要看DEL命令参数 del d:"test.txt删除指定文件，不能是隐藏、系统、只读文件 del /q/a/f d:"temp"*.*删除 d:”temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 del /q/a/f/s d:"temp"*.*删除 d:”temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 3.0 详细的CMD命令&emsp;&emsp;另外详细的CMD命令，可以看这位博主的Windows CMD命令大全 三、批处理中的系统变量%ALLUSERSPROFILE% 本地 返回“所有用户”配置文件的位置。%APPDATA% 本地 返回默认情况下应用程序存储数据的位置。%CD% 本地 返回当前目录字符串。%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。%CMDEXTVERSION% 系统 返回当前的“命令处理程序扩展”的版本号。%COMPUTERNAME% 系统 返回计算机的名称。%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关date 命令的详细信息，请参阅 Date。%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。%PATH% 系统 指定可执行文件的搜索路径。%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64 基于Itanium%PROCESSOR_IDENTFIER% 系统 返回处理器说明。%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。%PROCESSOR_REVISION% 系统 返回处理器的版本号。%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录(即系统根目录)的驱动器。%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。%TEMP% 和 %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要TEMP，而其他应用程序则需要 TMP。%TIME% 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关time 命令的详细信息，请参阅 Time。%USERDOMAIN% 本地 返回包含用户帐户的域的名称。%USERNAME% 本地 返回当前登录的用户的名称。%USERPROFILE% 本地 返回当前用户的配置文件的位置。%WINDIR% 系统 返回操作系统目录的位置。 举例，如下： 第一种方法显示日期星期及时间精确到毫秒 123@echo offecho %date%%time%pause 第二种方法显示日期及时间精确到秒 123@echo offecho %date:~0,4%年%date:~5,2%月%date:~8,2%日%time:~0,8%pause 四、常见的技巧和情况4.1 不显示代码执行期间的各种提示信息&emsp;&emsp;很多时候，为了使得屏幕上不出现无关的信息，我们需要屏蔽掉命令执行过程中产生的一些提示，有时候是屏蔽掉出错信息，有时候是为了屏蔽成功执行命令的信息，有时候两者都需要屏蔽，那么，我们可以把各种提示信息重定向到空设备中去，具体的代码是：① 如果要屏蔽成功执行命令的信息，请在语句的最后加上代码 &gt;nul。比如 copy a.txt d:\test&gt;nul② 如果要屏蔽出错信息，请在语句最后加上代码 2&gt;nul，需要注意的是，数字2前必须带空格。比如，md test 2&gt;nul，如果当前目录已经存在文件夹test，那么，执行这条语句将不会出现错误提示；③ 如果要同时屏蔽正确执行代码后产生的提示和出错时的信息，请在语句最后加上代码 &gt;nul 2&gt;nul。比如，copy a.txt d:\test&gt;nul 2&gt;nul 这条语句，无论命令是否成功执行，都不会在屏幕上出现任何提示；&emsp;&emsp;善用 nul 2&gt;nul 句式，可以很方便地实现很多目的，比如创建文件夹的时候，无需先用if语句来检测是否已经存在某个目录，直接 md test 2&gt;nul 即可，可以提高代码的执行效率。 4.2 del /a /f *.txt&emsp;&emsp;单独的del命令并不能删除带隐藏或只读属性的文件，于是，很多人自然而然地想到先用 attrib 命令来先给将要删除的文件去掉各种属性。其实，操作过程大可不必如此繁琐，只须给del加上 /a /f 的参数就可以了。 4.3 批处理.bat 文件中输出中文乱码原因：记事本新建的文件，编码不是 utf-8解决方法：用【记事本】打开&gt;【另存为】&gt;【修改编码为：utf-8】操作截图： 效果截图： 五、小白用法&emsp;&emsp;其实说多也无用，毕竟平常实际用到的功能并不多，往往都是在需要实现某个具体的功能才会查询相关的指令进行应用 5.1 删除开发环境生成的中间缓存123456789101112131415161718192021222324252627del *.bak /sdel *.ddk /sdel *.edk /sdel *.lst /sdel *.lnp /sdel *.mpf /sdel *.mpj /sdel *.obj /sdel *.omf /s::del *.opt /s ::不允许删除JLINK的设置del *.plg /sdel *.rpt /sdel *.tmp /sdel *.__i /sdel *.crf /sdel *.o /sdel *.d /sdel *.axf /sdel *.tra /sdel *.dep /s del JLinkLog.txt /sdel *.iex /sdel *.htm /sdel *.sct /sdel *.map /sexit 1234567891011copy Objects\ExecutableFile.hex ExecutableFile.hexdel /Q Listings\*.*del /Q Objects\*.*del /Q *.txtdel /Q *.inidel /Q *.bakdel /Q *.plgdel /Q *.depdel /Q *.Administratorrmdir /s/q DebugConfigexit 5.2 一键开启工作环境123456789101112131415161718192021@echo off title 学习咯reg add "hkcu\control panel\desktop" /v Wallpaper /d "F:\壁纸\Faker.jpg" /freg add "hkcu\control panel\desktop" /v WallpaperStyle /t REG_DWORD /d 2 /fRunDll32.exe USER32.DLL,UpdatePerUserSystemParametersecho.echo 今天是 %date:~0,4% 年 %date:~5,2% 月 %date:~8,2% 日 %time:~0,8%echo.echo.TIMEOUT /T 8start vstart.exeTIMEOUT /T 1start "" "C:\Program Files\Sublime Text 3\sublime_text.exe"TIMEOUT /T 1start "" "D:\Program Files (x86)\Tencent\WeChat\WeChat.exe"start cmd /k "cd /d d:/myblog"exit]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCD驱动]]></title>
    <url>%2F2019%2F12%2F14%2FLCD%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里以 （分辨率为:192*64)的 数据8线并口液晶屏 举例 一、基础知识1.1 分辨率&emsp;&emsp;分辨率指的是屏幕点阵可显示 行和列 点阵的数量；例如我这款192*64分辨率屏幕，它的行显示点数是 192 、列显示点数是 64;分辨率的大小 跟 屏幕的大小 是没有任何关系的；有些屏幕很大但是它显示(点阵)的最小像素是真的大(像我手头这个)，因此分辨率并不大，显示的东西也不多。ASCII码的最小字体是0508(点阵)，汉字的最小字体则是1616(点阵)举例：分辨率192*64&emsp;&emsp;单行可显示最多汉字为：192/16 = 12 个&emsp;&emsp;汉字最多显示行数: 64/16 = 4 行因此，该屏最多只能显示 4行(每行)12个的汉字 1.2 驱动代码思路&emsp;&emsp;以该屏为例；一个好的（不带EWWIN）嵌入式LCD驱动应该分为三大块：1）底层，LCD硬件驱动（一般由该屏的原本数据手册和源码例程提供）2）中间层，提供字库和字体写入驱动、框体、阴影、图片等3）应用层，提供封装界面轮询方式等，用于主程序调用 举例： Lcd_drv.c Lcd_dev.c lcd_user.c font.h (该字库文件只会被Lcd_dev.c所调用) 二、高级应用&emsp;&emsp;在显示的过程中，无非就是 1)残影 2)显示方式 残影是在Lcd显示中经常出现的问题；例如之前显示 “28”，后面再显示 “6”，但是实际效果会显示“26”，这个“2”就是残影 当你要显示一串数字，带有小数点、单位，甚至(正)负号；而实际上，在Lcd显示的均为字符串，它并不是一组数字，你无法让一个float类型变量(数值)直接显示在Lcd上；如果数字和符号分开显示，又容易形成头疼的残影 2.1 消影&emsp;&emsp;消影的要点，无非就是要根据屏的分辨率，以及规划好 数据显示区，并且把数据显示区分成每一个最小显示具体字符单位；对要显示的数据位数进行判断，然后从右到左，逐渐挪最高位显示位置；然后将剩下的空白单位格子，用空白显示填充 2.2 数字和字符串转换&emsp;&emsp;这个最重要的就是sprintf函数了；sprintf函数主要功能是把格式化的数据写入某个字符串中，但需要为正整数(不然符号位会被当成数值)。 数值转换字符串主要为两种：1)单个数字转换成字符串，用于界面需要具体调整单个数字(不常用到)2)一个带正负号、小数点、单位等的数值，转换成字符串 以下代码实现 数值进行转换成字符串：(不带符号和单位，可根据下面思路添加) 123456789101112131415161718192021222324252627282930static const char *cSprintf[]=&#123; "%d", "%d.%01d", "%d.%02d", "%d.%03d", "%d.%04d", "%d.%05d",&#125;;static uint32_t uiPowVal[] = &#123;1,10,100,1000,10000,100000&#125;;uint32_t _valSprintf(uint32_t uiVal,uint8_t ucShift,char *pucFrame)&#123; uint32_t uiLen = 0; switch(ucShift) &#123; case 1: case 2: case 3: case 4: case 5: uiLen = sprintf(pucFrame,cSprintf[ucShift],(uiVal/uiPowVal[ucShift]),(uiVal%uiPowVal[ucShift])); break; default: uiLen = sprintf(pucFrame,cSprintf[0],uiVal); break; &#125; return uiLen;&#125; 2.3 界面显示划分 采用回调函数，将每个界面都分割成两块实现：(界面初始化)InitGUI 和 (界面刷新)UpdateGUI；方便查看各个界面功能代码 采用 switch轮询方式显示页面，页码作为switch参数；再用enum枚举页码，可以使得页面扩展时 增加和删减页面变得更简单，而且可随意更改序号； 构造一个结构体能够用来记录 当前页码 和 缓存页码 ；缓存页码会在进入某个页面就一直保存对应的值，当前页码则是会根据操作可能发生变化；两个页码对比，就可以知道页面是否要重新进入初始化；]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>LCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南瓜]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%8D%97%E7%93%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;纪念一只小小的、瘦瘦的，但并不勇敢反而很胆小并且还很挑食的 南瓜 从一开始的老姐说“它可是折尾招财猫”，到后面实际在火锅店前抱走的流浪猫 从一开始的敢抓人不认人躲在高处吠，到后面温顺认人 吃东西一直很挑，被我们戏称猫精 当阉割手术完，狂吐舌头并撞笼子的时候，曾对它偷偷说：忍住了，以后就能多陪伴我们几年啦，让你再陪陪我们这些人未来的孩子 时不时地发烧无精神，到最后发现是猫传腹 开始疯狂地瘦下来，瘦到皮包骨头，但却肚子越来越来大 到后面连眼睛都睁不开，但还能进食 甚至有带它去安乐的想法 病情却在老姐坚持下慢慢好转，肚子开始慢慢变小 但是也变成了一只瘦骨嶙峋的、嗜睡的猫 每天仍旧痛苦着，我们却不知道怎么做才是对的 最后一天带着去安乐的时候，别人却以为是我们抱着一只很可爱的小猫 殊不知你已经陪伴了将近半年，只不过你真的太瘦了 当去宠物医院的时候，看到别人的猫，头大得跟个大毛球一样 等你走后，去同学家撸猫，3个月大的，个头跟你6个月一样大 才知道你是真的很瘦，开始后悔没让你多吃几口 &emsp;&emsp;希望你在另外一边，不要总是那么挑食，你个流浪猫那么挑，是要干嘛呢？不要那么怕生，长点志气啊。下次要是能够再过来，就不切了，将就点和我们一起活下去把 &emsp;&emsp;当我没事再想起你的时候，我会稍微再加把劲吧]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>南瓜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil版本号]]></title>
    <url>%2F2019%2F10%2F08%2FKeil%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇详细介绍keil版本管理 一、__DATE__和__TIME__简介&emsp;&emsp;经常都需要手动添加版本号或者生成时间会很繁琐。这个时候，C语言中的两个宏__DATE__和__TIME__可以帮到我们。__DATE__用于获取系统日期，而__TIME__用于获取系统时间，我们可以根据该两个宏获取到的信息将其保存于程序变量中，在程序运行过程中直接调用。 __DATE__的格式为 “Aug 27 2013” | “Sep 3 2019”__TIME__的格式为 “14:01:32” 二、版本管理源码&emsp;&emsp;根据上面获取的格式，也可以自己写出Version版本管理；这里的源码（内有注释）如下 2.1 数值输出2.1.1 Version.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include "Version.h"/********************************************************************************块注释 : 获取系统编译日期********************************************************************************/unsigned int GetBuildDate(void)&#123; const unsigned char *StrD=__DATE__; unsigned int u32DateBuf=0; u32DateBuf+=(StrD[10]-'0')*10000; u32DateBuf+=(StrD[9] -'0')*100000; if(StrD[4]!=' ')u32DateBuf+=(StrD[4]-'0')*10; u32DateBuf+=(StrD[5]-'0'); switch(StrD[0]) &#123; case 'J': switch(StrD[1]) &#123; case 'a':u32DateBuf+=100;break; //January case 'u': switch(StrD[2]) &#123; case 'n':u32DateBuf+=600;break; //June case 'l':u32DateBuf+=700;break; //July default:break; &#125; break; default:break; &#125; break; case 'F':u32DateBuf+=200;break; //February case 'M': switch(StrD[2]) &#123; case 'r':u32DateBuf+=300;break; //March case 'y':u32DateBuf+=500;break; //May default:break; &#125; break; case 'A': switch(StrD[1]) &#123; case 'p':u32DateBuf+=400;break; //April case 'u':u32DateBuf+=800;break; //August default:break; &#125; break; case 'S':u32DateBuf+=900;break; //September case 'O':u32DateBuf+=1000;break; //October case 'N':u32DateBuf+=1100;break; //November case 'D':u32DateBuf+=1200;break; //December default:break; &#125; return u32DateBuf;&#125;//这样得出来的数据为：190903/********************************************************************************块注释：获取系统编译时间********************************************************************************/unsigned int GetBuildTime(void)&#123; const unsigned char *StrD=__TIME__; unsigned int u32DateBuf=0; u32DateBuf = 0; u32DateBuf+=(StrD[0] - '0')*100000; u32DateBuf+=(StrD[1] - '0')*10000; u32DateBuf+=(StrD[3] - '0')*1000; u32DateBuf+=(StrD[4] - '0')*100; u32DateBuf+=(StrD[6] - '0')*10; u32DateBuf+=(StrD[7] - '0'); return u32DateBuf;&#125;//这样得出来的数据为：140132/***************************************The End Of This File***************************************/ 2.1.2 Version.h1234567891011121314151617181920#ifndef _VERSION_H#define _VERSION_H#include &lt;stdint.h&gt;#include &lt;string.h&gt;/*******************************************************************************块注释：版本信息*******************************************************************************/#define SFVERSION (10112UL) // 通讯显示版本号：01.01.12/*******************************************************************************块注释：对外接口*******************************************************************************/unsigned int GetBuildDate(void); // 获取系统编译日期unsigned int GetBuildTime(void); // 获取系统编译时间#endif/***************************************The End Of This File***************************************/ 2.2 字符串输出2.2.1 Version.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include "Version.h"/********************************************************************************块注释 : 获取系统编译日期********************************************************************************/void SetBuildDate(char *pBuildDate)&#123; const char *StrD = __DATE__; // if(0 == LanguageMode) &#123; pBuildDate[0] = StrD[7]; pBuildDate[1] = StrD[8]; pBuildDate[2] = StrD[9]; pBuildDate[3] = StrD[10]; pBuildDate[4] = '/'; switch(StrD[0]) &#123; case 'J': &#123; switch(StrD[1]) &#123; case 'a': pBuildDate[5] = '0'; pBuildDate[6] = '1'; break; case 'u': switch(StrD[2]) &#123; case 'n': pBuildDate[5] = '0'; pBuildDate[6] = '6'; break; case 'l': pBuildDate[5] = '0'; pBuildDate[6] = '7'; break; default:break; &#125; break; default:break; &#125; &#125; break; case 'F': pBuildDate[5] = '0'; pBuildDate[6] = '2'; break; case 'M': &#123; switch(StrD[2]) &#123; case 'r': pBuildDate[5] = '0'; pBuildDate[6] = '3'; break; case 'y': pBuildDate[5] = '0'; pBuildDate[6] = '5'; break; default:break; &#125; &#125; break; case 'A': &#123; switch(StrD[1]) &#123; case 'p': pBuildDate[5] = '0'; pBuildDate[6] = '4'; break; case 'u': pBuildDate[5] = '0'; pBuildDate[6] = '8'; break; default:break; &#125; &#125; break; case 'S':pBuildDate[5]='0';pBuildDate[6]='9';break; case 'O':pBuildDate[5]='1';pBuildDate[6]='0';break; case 'N':pBuildDate[5]='1';pBuildDate[6]='1';break; case 'D':pBuildDate[5]='1';pBuildDate[6]='2';break; default:break; &#125; pBuildDate[7] = '/'; if(StrD[4] == ' ')pBuildDate[8] = '0'; else pBuildDate[8] = StrD[4]; pBuildDate[9] = StrD[5]; pBuildDate[10] = '\0'; &#125; /*英文格式显示 else &#123; pBuildDate[6] = StrD[7]; pBuildDate[7] = StrD[8]; pBuildDate[8] = StrD[9]; pBuildDate[9] = StrD[10]; pBuildDate[10] = '\0'; switch(StrD[0]) &#123; case 'J': &#123; switch(StrD[1]) &#123; case 'a': pBuildDate[0] = '0'; pBuildDate[1] = '1'; break; case 'u': &#123; switch(StrD[2]) &#123; case 'n': pBuildDate[0] = '0'; pBuildDate[1] = '6'; break; case 'l': pBuildDate[0] = '0'; pBuildDate[1] = '7'; break; default:break; &#125; &#125; break; default:break; &#125; &#125; break; case 'F': &#123; pBuildDate[0] = '0'; pBuildDate[1] = '2'; &#125; break; case 'M': &#123; switch(StrD[2]) &#123; case 'r': pBuildDate[0] = '0'; pBuildDate[1] = '3'; break; case 'y': pBuildDate[0] = '0'; pBuildDate[1] = '5'; break; default:break; &#125; &#125; break; case 'A': &#123; switch(StrD[1]) &#123; case 'p': pBuildDate[0] = '0'; pBuildDate[1] = '4'; break; case 'u': pBuildDate[0] = '0'; pBuildDate[1] = '8'; break; default:break; &#125; &#125; break; case 'S':pBuildDate[0]='0';pBuildDate[1]='9';break; case 'O':pBuildDate[0]='1';pBuildDate[1]='0';break; case 'N':pBuildDate[0]='1';pBuildDate[1]='1';break; case 'D':pBuildDate[0]='1';pBuildDate[1]='2';break; default:break; &#125; pBuildDate[2] = '/'; if(StrD[4] == ' ')pBuildDate[3] = '0'; else pBuildDate[3] = StrD[4]; pBuildDate[4] = StrD[5]; pBuildDate[5] = '/'; &#125; */&#125;//这样得出来的数据为：2019/09/03 2.2.2 Version.h123456789101112131415161718#ifndef _VERSION_H#define _VERSION_H#include &lt;stdint.h&gt;#include &lt;string.h&gt;/*******************************************************************************块注释：版本信息*******************************************************************************/#define VERSION ("v1.01.02") // 通讯显示版本号：01.00.12/*******************************************************************************块注释：对外接口*******************************************************************************/void SetBuildDate(char *pBuildDate);// 获取系统编译日期 /***************************************The End Of This File***************************************/#endif 三、注意要点&emsp;&emsp;编译方面需要注意有个别差异：局部编译：不会再编译未改动位置；局部编译后，虽然 .bin文件生成的时间是 对应编译时间（准确）的，但因为该工程内获取版本时间代码未改动，因此导致局部编译未更新获取内部版本时间（和 .bin文件更新时间没关系）。该工程内部显示获取的版本时间仍为 你上一次 全局编译的时间。提交版本时候需要全局编译一次]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红警2标准版+尤里版 （彩蛋）攻略]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%BA%A2%E8%AD%A62%E6%A0%87%E5%87%86%E7%89%88-%E5%B0%A4%E9%87%8C%E7%89%88-%EF%BC%88%E5%BD%A9%E8%9B%8B%EF%BC%89%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这款怀旧游戏并不难打，不管什么难度，上手后都能很轻松就通关，主要还是分享一些剧情、彩蛋和攻略的 一、红色警戒2_标准版&emsp;&emsp;二战后爱因斯坦发明了时间机器，他为了避免（二战）战争惨剧发生，便利用了自己发明的时间机器回到战争爆发前，刺杀了希特勒.这一举动成功防止了德国走上纳粹道路，但却让苏联国力大幅膨胀。战争最终依然没能避免，苏联发动了世界大战，英美等国则组成盟军与之对抗(一款从细节里黑化苏联的游戏)。下面开始介绍作为苏联和盟军两条线的剧情任务攻略。 1.1 苏联 红色黎明：工程师快速修桥，（动员兵）伞兵进攻五角大楼即可（任务空降坦克支援，白给通关）；彩蛋：五角大楼附近有隐藏坦克小队 危机四伏：登陆作战，发展经济，快速憋出坦克中队 直接横扫过去 大苹果：直接憋出坦克中队直接中路碾压过去，记得占领后需要防空；彩蛋：可用尤里控制中立单位（大巴车可载人）看地图；整个地图盟军除主基地外有额外的一个兵营和车工厂；左上角有个防空维修厂 家乡前线：卖掉船厂出经济，少量动员兵守家拖时间，大量动员兵、磁暴、犀牛直接推进破坏盟军登陆作战（地图最右边），清理剩余海上船支部队 灯火之城：占领油厂，动员兵进房攻进去；彩蛋：一路向左直到靠近海岸，可获得三波隐藏小支援单位 划分：小兵进房子苟拖时间，动员兵混合磁暴守家，憋出潜艇（数量）中队直接攻入造船厂 超时空防御战：（苏联中任务难度No.2）部分（好）位置可以先用围墙卡住，然后哨戒炮在外（防狙击手：主要来源于基地正下方），拖出坦克支援时间；间谍放狗，蜘蛛全图，防空炮4门+；至少产出四队（1队：3-4只）天启，其中1队作为游走火力支援部队，光陵坦克主要是右侧进攻；彩蛋：使用恐怖机器人直接过去清理广播车可获得全地图（低难度情况），地图最右侧有油井和大片金矿 首都之辱：前期敌方两波伞兵偷袭；正常部队断桥离开基地，辐射兵开大守家清伞兵；强制推进并建筑占领前面矿厂，稳住后矿区直接建立就地兵工厂，堆出天启中队直切目标 狐狸与猎犬：狙击手清掉部分海豹，3级多功能步兵车（这局核心单位，该图只有两艘坦克，完全不虚）可开围墙，断电清图；彩蛋：难度决定任务提供的尤里人数；地图右下角有修车厂、并有经济箱；地图右上角有狙击手、直升机；该局有个迷之触发条件，当你杀多个海豹部队时，全体部队会开始走动集火处理尤里，容易游戏失败，最好先处理掉外围兵力 残兵败将：防守防空，进攻，核弹打击 红色革命（尤里叛乱）：（苏联中任务难度No.1）该局是苏联最难玩的一局，敌方有大量尤里、天启、V3远程火箭、无敌暗牧，固定双基洛夫推进；而且是三基地兵力合伙进攻，光是发展防守已经是头皮发麻；在两艘敌方基洛夫生成地，两者连线，该位置是一条只有一个入口点的悬崖峭壁，上面固定 2门防空炮1门磁暴线圈 沿着悬崖多组防守；因此，你无法使用（特别是左侧进攻）天启中队进行推进（敌方尤里会进行支援），数量不多的基洛夫推进又会被悬崖防线和流动支援打下；该图对于不清楚全图构造的玩家，难度是颇大的；那么如何通关呢？当然是反过来利用天然的悬崖峭壁防线。前期游戏开局会送两艘基洛夫空艇，前方有个小高地，两艘基洛夫刚刚好能够拿下前方高地（留下发电厂）；然后动员兵占领左上侧房子和基洛夫防守左侧；高地占领后，两边加强防守，+兵营，多哨戒炮磁暴线圈（无人）就地势击杀（大量尤里），少量防空炮防空（V3火箭），坦克部队附近支援（主要击杀天启坦克）；该高地是这场游戏防守的核心，高地和悬崖峭壁之间的羊肠小道，是进攻我们左侧的必经之路，高地右侧也是右侧进攻我方的基本路径，采用主无人化防守+坦克对射，就可以稳定下来；基本稳定后建立核弹，成立两小队防空履带车，每队各8只，防守左右各3只基洛夫，2-3发核弹或者从右侧逐步推进就能结束游戏了 北极风暴：（苏联中任务如果是常规推进，难度No.3）防守，占领海面（敌方海豹部队），准备防空（敌方火箭飞行兵和战机）；发展完成后，渡河进攻占领车厂，建立苏联兵营购买大量工程师，进行常规堵口防守；占领盟军基地车（期间会被一直被高地光陵塔攻击，工程师抢修），生成闪电风暴，打防守；过段时间核弹+闪电风暴直接摧毁超时空核心；彩蛋：登撸盟军主基地旁边的金矿，定时有超时空传送9单位多功能步兵车（用尤里控制后占住传送地形就不再生成）；推进路途有1个伞兵指挥部、3艘基洛夫空艇（开局残血，等你推进过去已经是满血了）；基洛夫空艇正下方有个金矿，定时超时空传送9单位光陵坦克； 结局：罗曼诺夫表面上与盟国交好，但是暗地里却重建了军队，并任用尤里为科学部长，为苏联研发心灵控制相关的黑科技。由于盟国采取了绥靖政策，苏联的军备越来越强，最后终于抓住机会向盟国发动全面袭击。盟国试图组织反抗，但是这些行动都被玩家扮演的苏联指挥官逐一挫败；尤里在战争中尝试造反并杀害了罗曼诺夫（黑苏联），可最终还是在玩家的运筹帷幄中败下阵来。在消灭了最后一批敢于反抗苏联的残余势力后，苏联统一了地球，玩家成为苏联最高领导人 1.2 盟军 孤独守卫：谭雅救人留在敌方伞兵处支援，大兵进攻苏联基地，LV3远距离除掉哨戒炮 危机黎明：多线推进；火箭飞行兵处理盟军基地的路障哨戒炮后，清理右侧苏联基地绕后（弱点位置）；同时谭雅占领盟军基地，产出大量坦克，围墙保住谭雅 为长官欢呼：守住敌方进攻双桥，有空拿（建筑物）钱，大量空军目标轰炸；彩蛋：基本每一个名建筑物，都有小部队提供支援 最后机会：清理巨炮，巡洋舰清理岸边，援军记得叫过来（小心被击沉），空军（数量）中队轰炸目标 or 坦克推进 暗夜：地图左侧间谍，右侧深处有小队士兵；左侧往上走可救奶牛；第一个苏联基地入侵，墙体右侧有油桶，进去后有工程师单位，占领第一个核弹后进行轰炸第二个（游戏结束）；第二个核弹位置有小队精英部队 自由：防守，定时清空左上侧方敌人骚扰采矿，建立空军（数量）中队，定点基地、兵营、车厂 轰炸两个，敌人会直接卖掉所有建筑单位，快速通关 深海：主火箭飞行兵防守，本岛上侧定时伞兵，岛右侧部分定时伞兵，家里定时伞兵工程师，左上随机水路艇援兵（V3，防空兵）；敌方核弹随机摧毁海军或车厂；最好围墙防住（敌方步兵、工程师单位），占领房子；地图中最上方占领163，建立空军中队，定点轰炸基地、兵营、车厂、核弹，快速通关 自由门户：直接摧毁心灵信标，谭雅坐船跑海岸（不要再出来）；守家，三级大兵建筑+光陵+防空守住，空军中队定点轰炸，清理残余；彩蛋：左下角有废弃的矿厂、车厂 太阳神殿：海豹分两批：图左上角163，坦克+海豹守住；大兵进房子阻止巡线，海边绕后苏联采矿位置，海豹队员完成任务 海市蜃楼：基地车回后方实验室建成，多产出幻影埋伏守三路，守住实验室；空军编队定点轰炸三基地，快速结束；彩蛋：右下角废弃矿厂；地图左侧中间处，有修理建筑和一片矿区；左上角有个工具箱，只能海豹部队去收集 核尘爆辐射：开局，卖掉小孤岛采矿基地；优先出海豹（巡洋舰）断掉所有桥，定时断掉上侧桥梁（固定上侧岛屿伞兵坦克，上侧右海岸定时工程师伞兵）；发展起来后去清理再开路；敌方核弹会针对船厂 or 车厂，可以考虑两发电厂卖掉，空军编队定期轰炸3核弹，目标达成 超时空风暴：（盟军中任务难度No.1）敌方核弹会针对我方车工厂（建筑远离点），坚守住前两波基洛夫空艇，大兵占领建筑，用于拖住铁幕单位；攒出两空指部空军走位躲防空，轰炸左右侧车厂兵营（不再生成），产出超时空军团断四核电站（具体位置在精英部队附近）和偷掉附近车厂兵营，再处理掉精英（包括建筑）部队，目标达成 结局：战争爆发后，盟军并没有迅速溃退，而是在玩家扮演的指挥官领导下逐步稳住阵脚，最终还发起了反击。在战争后期，盟军利用超时空传送技术运输军队突袭莫斯科，攻进克林姆林宫活捉了罗曼诺夫。然而尤里却逃脱了抓捕，并在暗地里酝酿着一个更大的阴谋 二、红色警戒2_尤里版&emsp;&emsp;延续红警2的盟军胜利路线剧情；尤里在逃脱盟国抓捕后，启动了大战期间悄悄搭建在全球各地的心灵控制器，企图控制全人类的心灵。不论是盟军还是苏联，此时反抗已经为时已晚，唯一的办法就是利用时间机器回到大战初期改写历史 2.1 苏联 时空转移：英雄任务，无畏战舰打巨炮；英雄超时空返回 似曾相识：（原版盟军的海市蜃楼任务，换为苏联进攻方）右下第三波攻击要优先（可获得盟军兵营），均匀分布战斗碉堡防止敌方超时空部队偷袭；火箭飞行兵+基洛夫去左上绕后攻击，火箭飞行兵吸收伤害，基洛夫攻击 洗脑行动：英雄任务，吸引左下角爆桥，恐怖机器人+履带车（装英雄）+坦克去左上角桥边登陆，快速击毁控制器，动员兵占领前面豪华建筑，坦克和英雄+步兵车完成任务 北非谍影：总统在右侧不可进人的建筑，左上角有敌方兵营车厂，会固定出现一个尤里只为控制总统，自爆卡车攻击各类地图建筑炸毁地图中间，最好占领该兵营，自爆卡车+铁幕进场，收割清场 脱离地心引力：该图地势相当不好，大量采矿车前来抢矿，守住后，使用建筑卡上（附近）高地，多使用磁爆项圈，卡上第二层高地时可获得尤里基地，运用（尤里科技）狙击手+磁能坦克+天启坦克通关 飞向月球：建立防空炮减少损失（生命防空单位被击杀、控制）(可在间隙中穿插辐射工兵进行辐射地板击杀磁能坦克)，地图中间：左侧基地为盖特炮外围控制塔中间一个，右侧为心灵塔外围盖特炮中间一个，主攻：（特种）激光飞行兵+天启坦克 首脑游戏：使用战斗堡垒保住基地后，增加防空履带车对抗飞行兵+（盟军）飞机+基洛夫；快速建立核弹，用核弹击打控制器即可，先攻击（占领）盟军，再攻击苏联，中间最后随意打 结局：苏军将抢夺时间机器回到过去，挫败尤里的阴谋，逆转了苏联战败的命运（又黑苏联），最终征服地球，开始向外太空发展 2.2 盟军 光阴似箭：时空穿梭，英雄任务 好莱坞梦一场：巨炮防守，堆光陵坦克，几只要塞（狙击）辅助；彩蛋：地图左上角有敌方科技的兵营、车厂 集中攻击：获取电源，敌方无主基地，风暴摧毁车厂兵营；右偏下有个无人车厂，狙击手进步兵车防止对狙和加机动性，开场核弹会攻击车厂（瞬间卖了回点血），准备买步兵车，买点狙击手，最上面开始提供的小波部队往下拉和下方部队汇合吃掉中间敌方单位，占领电厂后，敌方不定期会空投工程师返回去占领，留部分狙击手单位狙击工程师，狙击完离电厂远一点，核弹会攻击发电厂 古墓奇袭：英雄角色无法被控制，主力核心；海岸边左上角，金字塔位置固定有人运输偷袭，谭雅先行去右边断两桥占领油井，右上海岸光陵塔断水上运输兵（尤里基本没有空中单位）；发展经济，谭雅直接过去对面金字塔解救爱因斯坦，占领发电厂，买车厂，堆光陵坦克编队推进 or 飞机中队推进 纽澳复制战：小兵占领各建筑，尤其上边角落（第一波运输兵），潜水艇火箭飞行兵防住；彩蛋资源：地图左下角有一个医院+矿守住；地图右中有修车厂；一批火箭兵可保护右上角矿区 万圣节：（盟军中任务难度No.2，前期坚守）小兵占领附近建筑，占领左上角桥对面一栋建筑拖住作战时间，中间碉堡围墙（可重装大兵对抗飞碟，后期敌方精神车吃亏）加光陵塔，火箭飞行兵机动守护，右侧为关键，使用围墙围住，并用光陵塔和碉堡守护，桥对面不可太多占领建筑，盖特坦克可在建筑攻击范围外射击建筑。多功能步兵车或者爱国者守住飞碟；彩蛋：成功守护住后，地图左上角一片矿区+1油井；地图右侧中间有3油井；地图中间中间有一家医院和修车厂，可占领并堆光陵坦克编队 or 飞机编队攻击 脑死：（盟军中任务难度No.1，盟军战场太狠了）开场双基地，分为主战场岛（盟军）和孤岛守卫岛（苏联），两者无法相通；两岛使用少量苏联碉堡守住前期（防止心灵控制+基因突变的连招）；大部分生产建筑应放在苏联战场，盟军作为主战场只需要兵工厂；尤里飞碟只会定期进攻苏联左边，苏联至少5门防空炮放置在 基地正下方（只是一块高地），苏联基地开场左右各一个苏联堡垒（外加两门巨炮）；苏联战场局势稳定后，清理岛上残留部队，守住海岸线，苏联右侧海岸定时来兵，然后放心生产；其余（尤其盟军战场）均需要大量（无人单位）巨炮防守。苏联战场，孤岛地图左上角有修车厂，右上角有矿+建筑；可采用超时空敌人后方建立基地，巨炮和光陵坦克编队从后方开始推进 结局：最终能在南极活捉尤里，并将他终身囚禁在心灵隔离室 三、红色警戒3&emsp;&emsp;游戏故事还是紧接《红色警戒2：尤里的复仇》盟军线结局；在苏联战败前夕，苏联的 阿纳托利·查丹科上校和库可夫将军 利用时间机器回到过去1927年，刺杀爱因斯坦（这个剧情笑死我了），使爱因斯坦消失于时间长河中，历史又一次被大幅改写（平行宇宙原理）。失去爱因斯坦后，盟军相对于苏联的科技优势不复存在，因此在和苏联的正面对抗中节节败退；该行动还造成了一个新的国家崛起：旭日帝国（日本）。在新时间线中，旭日帝国崛起为一个超级大国并同时向盟军和苏联发起挑战 3.1 苏联&emsp;&emsp;苏联任务从抵御帝国入侵，夺回被帝国占领的领土，到进攻整个欧洲，除掉“叛徒”库可夫将军，反击帝国并杀死天皇芳郎，最终战胜帝国；并且与总理反目，打败总理，摧毁自由女神像，击败美国为止。最后指挥官当上了苏联的总理，领导苏联走上新时代（黑化苏联，反正前苏联总理没一个好结局） 3.2 盟军&emsp;&emsp;盟军起初在英国拼死抵抗进攻的苏军，并逐渐夺回欧洲，然后联合苏联对付帝国。其间杀死以极端方式（将一架卫星攻击器瞄准莫斯科）反共的总统阿克曼，在东京摧毁了帝国的军事总部，使帝国不再成为威胁，而后因为叛逃的泽林斯基博士而发现了苏军的阴谋，其后又与苏联重新对立并在列宁格勒决战，终于打败苏俄。最后原副总统担任新总统，规划了建立自由平等的新世界的宏伟蓝图（在盟军就别想当总统了） 3.3 旭日&emsp;&emsp;旭日帝国起初突袭苏联，利用将军刽子手摧毁敖德萨，再到抵御盟军（后来对抗苏盟联军），最后反击苏联，利用将军刽子手摧毁克里姆林宫和时间机器，击败叛逃盟军的泽林斯基博士，摧毁未来科技总部。最终指挥官被授予“超级将军”荣誉(天皇之子达朗所主持建造的超级机器人“将军刽子手” 科幻色彩十足，威力够猛） 3.4 总结&emsp;&emsp;红色警戒3对同时微操的要求更加高，特殊的技能也提供了更多的进攻措施，地图需要重复探索也提高了可玩性；英雄单位和超级武器的特效也是十分惊叹；也是值得推荐的一款游戏]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[They are bilions 攻略]]></title>
    <url>%2F2019%2F10%2F03%2FThey-are-bilions-%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇主要针对遭遇战模式（我玩的时候还没出剧情模式），但是也能对剧情通关提供科技点升级思路和建造思路。玩RTS游戏还是少看点攻略，自己摸索，即使过程硬核被毒打（崩溃），也是趣味满满 一、前言&emsp;&emsp;该游戏如果是（我）第一次玩就直接开玩遭遇战（不看攻略），且不进行花式存档，难度是变态难的，究极硬核。我连续玩了三天（游戏时间基本满实际两天），中途会了花式存档和看点基础单位的介绍，才撑到最后一波，然而最后一波真的是超乎我想象，结果又是推倒重来（三天才过第一关了解一下）。因此推荐玩这个游戏的时候，从剧情模式开始玩起；而且还是要学下如何存档，倘若是直接打就要补充点基本常识。这个游戏真正地（不存档，前期N+1次重开）教会了我什么叫做：“千里之堤,溃于蚁穴” 二、备份存档&emsp;&emsp;存档(菜鸡的必备技能)：备份存档 我的文档\My Games\They Are Billions 把这个”They Are Billions” 文件夹拷贝走;记住是第几天，最好是备注下第几天的档!需要读档的话 就先将游戏退出至主界面，ALt+table切换画面至桌面 把你备份的存档文件夹复制回mygames文件夹，并选择覆盖已有文件就行了。这样你点继续的话，就算是读取了之前的存档。这样操作是不需要完全退出游戏的!只退至主菜单，节省了时间 三、游戏介绍&emsp;&emsp;往往开局随机生成的地图，往往能够决定你前中后期的繁荣速度 3.1 布局思路&emsp;&emsp;开局，游戏开始附赠4游侠+1士兵；1士兵可用于站岗也可以清小群僵尸，4游侠快速在基地周围转一圈，整体估摸一下以后的布局。4游侠清理周边僵尸（走位反复横跳，不深入），扩大发展范围，稍后进行站岗 如何估摸以后的布局： 明确规划好（整块）居民区（尽可能2间为1层*2层形成收益最高的包围圈，两层间差一条街流动）+市场+银行的地块；最好每条路都留相通，防止（不智能）支援堵路（和美观）；争取形成一个以市场、银行为中心，包裹两层民居（每层2间民居，半径为4间民居）的繁荣区域。因此开始发展的时候也要靠往该区域发展 确保留有（树林）伐木场和（绿地）农场的未来地块；以及未来缺木材、草地时，要偏往地图哪个方向发展 在生产重地留有置放仓库的地块，以便提高产量 兵营、木头科技、石头科技、钢铁科技，都应该建立在前面规划剩下来的偏僻废地（无法发展民居、采集资源），也可以见缝插针建风力发电为未来繁荣发展节省地块（建立民居、农场等） &emsp;&emsp;当你玩多后基本就知道这盘游戏开局的好坏；有只需要防守两道口的天选之局，也有真就耳听四方守八方的开局，或者开局就有多面（方向）僵尸城镇压在你隔壁问候你的，这种开局，不要想老是重读档防突击苟活，读档只会减少你的游戏体验，还不如重开局，找到普通一点的生成地图，越少读档能玩得更开心、更有成就感 3.2 资源产出比&emsp;&emsp;有些地块产出资源比也不尽相同；要考虑土地和（土地转换出各种）资源的平衡，以及每个发展阶段的所需资源 伐木场，每个木材点产出12+就是好的 菜市场，每个石材点产出4+就是好的 钓鱼小屋产出大概是10-15的食物（尽可能沿海岸线建立钓鱼小屋；在锯木厂旁建立狩猎小屋（节省地块）） 农场，大概产出是30-50（最高64）性价比太低的点可以舍弃，留地块建设其他建筑（风力，兵营等） 3.3 资源需求&emsp;&emsp;资源堆着并非能发家致富，所有资源（除了钱）都是有容量限制的（建仓库可扩容），一旦超出容量，就是浪费人力物力电力。 木材科技升级，优先升级：农场、民居、市场、狙击手等（市场可以及时出售交易多余的资源） 开场优先 1-2个木材厂，主要需要用于建立防线（围墙和高塔）和游侠；前期过渡中期需要大量木材升级居民区帐营，准备好第3-4个开采木材地点 开场可缓段时间再建造采石场，需求量少，主要用于 高级建筑研究所、市场 石头科技升级，优先升级：民居，银行（400人）等 前期转中期后，需要准备大量（3个以上）采石场，用于居民区升级石屋；同时需要2个（左右）采铁场，保证兵营按时生产狙击手（多个兵营） 根据情况，可以出一个仓库 石材资源变成抢手资源（用于发电），多考虑延展布局采石材 银行可以优先考虑比石屋先憋出来，快速回收经济成本（此时应该是要有仓库的） 整个城镇建设尘埃落定后，考虑延长多带多路（沿路修建防御工事，并在旁边修建采集资源点） 3.3 敌人攻势&emsp;&emsp;明面上的进攻并不可怕，可怕的往往是偷家佬 3.3.1 自找死路&emsp;&emsp;开局清图（建造）太深、推僵尸城镇，会吸引出大量CEO（西装男）和女巫/胖子，此时基本上是毫无还手之力；要立马回缩防线（拆掉显眼建筑），实在来不及，就只能准备重开或者读档 3.3.2 只身立头功&emsp;&emsp;前中期要很注意小地图和听声音，入侵的僵尸哪怕一个，他的声音也是很大，一个不起眼的偷家僵尸只要进了生产区、居民区，基本就是要重来的 3.3.3 随机小波进攻&emsp;&emsp;地图会时不时有小波尸潮进攻，看不出来，但是数量是有点少的，稍微注意防一下还是很容易的 3.3.4 定时尸潮&emsp;&emsp;定时进攻的尸潮，往往是该时期最猛的一波攻击 1层木墙+1个(3个游侠)的木塔可以轻松顶住第1波进攻（1个游侠在外边疯狂引诱） 2层木墙+2个站了4个游侠的木塔可以顶住第2波进攻（1个游侠在外边疯狂引诱） 从第3波进攻开始， 就增加弩车AOE、木拒马和狙击手 前期防守时，可以让1个游侠在木墙外边走位，勾引尸潮拖住进攻时间 木拒马和铁丝网，是这个游戏的神器；木拒马，成本低，不仅减缓僵尸速度，多个还直接杀死僵尸，前中期对抗尸潮神器3.4 兵种推荐： 前期堆游侠防止尸潮和个别偷家 前中期，靠游侠，不出士兵；攒资源，直接憋出狙击手海（中期可多加兵营） 中期开始，可出死神搭配防守 中后期，小部分泰坦和狙击中队出去清图 四、最后一天：四面八方的尸潮&emsp;&emsp;没错，第一次玩疯狂坚守，读过档后，终于坚持到这里；结果这波尸潮数量那时候远远超出我的想象，又得是推倒重来，读档都救不了我（不想读太早的档）。下面讲一下一些方法（推荐的和不推荐的）： 推荐的方法： 把所有路全部防好，不要有侥幸心理，哪怕任何一条缝，尸潮都会进攻； 放弃部分难守的地块，收缩防守圈；3 狙击手（+死神），机枪塔，震荡波塔进行组合防守，震荡波塔（中后期）需要两层石城墙防守毒液僵尸远程攻击 ； 铁丝网准备就绪，铁丝网和木拒马都很有用，能多布置一点是一点； 塔上的狙击队选择厚血的优先攻击；震荡波塔+铁丝网（拖住充能时间）能清理大量杂碎僵尸； 根据之前发展的多带多路，考虑必经路线上边缘一点沿线火力支援，造1-2个炮塔（高塔）配合几层墙（+拒马），可以小部分尸潮（控制好距离，不要引诱太多直接被拆），有效减缓最后一波的尸潮进攻压力 不推荐的方法（要玩当然是光明正大地赢）： 用不上的资源建筑改卖的卖。例如：农场等； 拆除各类建筑补充对应资源； 五、心得&emsp;&emsp;游戏自己摸索才是真的好玩，游戏体验不单单是游戏提供的，也有部分是自己选择的；诚然有那些资源破解器或者高产版，过关会十分轻松，但是只会减少你的游戏体验；少读点档（毕竟技术还是菜），规划出自己心目中的城镇，并通关，这整个过程就是这款RTS游戏的魅力所在]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他们 死在了祖国胜利的前夜]]></title>
    <url>%2F2019%2F10%2F02%2F%E4%BB%96%E4%BB%AC-%E6%AD%BB%E5%9C%A8%E4%BA%86%E7%A5%96%E5%9B%BD%E8%83%9C%E5%88%A9%E7%9A%84%E5%89%8D%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[各位:&emsp;&emsp;我们以一个后人的视角回看历史时，原来已经不知不觉间忘记了，当时的志愿军们并不知道中国真的能取得最终的胜利，能再度成为一个完全独立自主的国家。在那样国土沦丧的背景下，最终胜利，现在红红火火的70周年国庆大阅兵，才更像是痴人说梦。 &emsp;&emsp;原来我们今天所习以为常的一切，并不是历史进程的必然结果。 &emsp;&emsp;当汉奸的人想不到会有今天。 &emsp;&emsp;而成为英雄，成为烈士的那些人，其实，他们大约也是想不到的。 &emsp;&emsp;到那一天我才突然明白，原来“不做亡国奴”不是必然结果，“抗争胜利”并不是必然结果，“建立独立自强的中国”也并不是必然结果…… &emsp;&emsp;原来那些人说着“我们一定会获得最终胜利”时，并不真正的知道，他们真的能成功。 &emsp;&emsp;原来他们前赴后继地牺牲的时候，也并不真正的确定，他们的牺牲是不是能换来他们想要的结果。 &emsp;&emsp;原来“坚定的信仰”，是这个意思。 &emsp;&emsp;原来我们一直知道他们伟大，却依然低估了他们的伟大。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小学生农药rank速上分攻略]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E5%86%9C%E8%8D%AFrank%E4%B8%8A%E5%88%86%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇主要是个人对农药游戏的理解，每个人的理解都不同，你可以从这份个人攻略提高自己的游戏理解，反过来也可以看出我的意识程度如何。截止20200115之前，不过这份攻略已经有些变动老旧了，大体没变，具体改动放到最后一节。 一、前言&emsp;&emsp;首先要讲一下对这个游戏的看法。与英雄联盟相比，不是同个难度层次的游戏，如果王者荣耀是2D难度，那么英雄联盟的难度是3D。观赏性天差地别，我看主播和赛事也只是看英雄联盟的。但是架不住香还是手游香：节奏（一局时间）短、配置需求低，随手一抄直接群体开黑等优势。英雄联盟久没玩就越不敢玩，农药靠点意识还是能随便打的。但是不管怎样，两者的rank和赛事就是两种不同游戏，这里只讲农药的rank速上分攻略 二、上分基本知识&emsp;&emsp;同样也是5V5,不过地图更小、支援更快；少一个召唤师技能,没有特殊天赋，笨比英雄秀不出多秀的操作。因此影响游戏胜负的判定因素也更少，更能看出这盘游戏的走势；打了这么久,我的理解就是假如一盘游戏中(不考虑某些特殊英雄)各个位置的影响胜负程度分为以下占比:&emsp;&emsp;胜负 = 40%中路 + 40%打野 +20%上下辅先说好，是一组中路决定，而不是单个中路决定的；10个人的游戏，实际上最后只有一种结果，10个人，分为5个对称组；也就是说这盘游戏决定输赢的核心位置只有两个:中路（*2） 和 打野（*2）（下面会有分析），其他三个人（*2）在这盘比赛的作用顶多只是擦屁股。 因此rank上分的话,尽可能多选中路或者打野即可快速上（掉）分。反而言之，当你rank常据这两个位置的时候，你一直卡在某个（钻石）水平，这就说明你水平很菜还坑队友。 2.1 游戏节奏（常规英雄）分析&emsp;&emsp;游戏节奏分为三部分：前期、中期、后期 前期：从全局的资源初始化来看：大家没有等级差距，中路兵线是最早可清的，其次是野怪的生成。因此影响前期的走向一共有三个位置：中路 &gt; 辅助 &gt; 打野。 中路一旦获得线权打出压制力，就能快速地入侵/防守野区。而且打野前期往往具有很大的缺点：1级刷红（蓝）开始，更换野区，2级刷蓝（红），4级准备gank抓人 or 拿龙团战，动态是可以探野区预知的；&emsp;&emsp;中路，一个优秀的中路可以通过前期反野（猪），得知对面打野（1级-&gt;4级）几分钟内动态走向，预见对面的打野（4级）可能gank哪一路，提醒队友被抓；同时根据（预估）对面打野动态，如果抓上/下路，压制对面中路兵线，火速gank另外（对面打野不在）一路 or 反掉 对面打野刚（快要）刷新的野区（1级刷野区域）。；如果是抓中，就假装不知道，一直在危险线徘徊，引诱对面打野蹲人，浪费时间。这样，队友被你的信号警告撤退，只要对面打野强杀或者折返，会失去一片野区的控制或者另外一路的爆炸；也可以根据英雄强度，配合自家打野辅助+（上/下 路）反蹲对面打野，打一波小团拿龙；相对来讲，反向支援不进行硬碰硬，收益会来得更稳定，比较推荐 反野 &gt; 抓单 &gt; 反蹲。&emsp;&emsp;打野，前期对打野也是异常重要，反而言之，是决定反野，还是守自家野区，又或者是互换野区，5级之前的时间都是十分珍贵，不要乱蹲人来浪费时间。&emsp;&emsp;辅助，辅助在这段时期也是尤为重要，这段期间，例如对方中单是 米莱狄/周瑜 这种前期压线能力很强但中后期较弱的英雄，需要在1-2级帮忙中路压制、威吓一下，减缓中单的兵线压力，换取中单支援能力；跟着打野反野/防守也会起到较大的作用。&emsp;&emsp;这段期间，上下路基本无作为，但是上、下路需要注意3级不要起杀心，不要想着秀操作，首先根据中单前期作为，第一判断对面打野路线；如果确认对方打野不在，才第二开始秀操作；尤其是上路（元哥）三级秀操作，能看到 结果很多对方残血打不死，打野插一刀的场景。 中期：这段时间，大家开始有一定的等级、装备差距压制，打野位的选择将会多了许多：‘清野、反野、控龙、抓人（三条）’；中路开始不能盲目gank，出去支援也要推断对方打野位置；因此影响中期的有两个： 打野 &gt; 中路。&emsp;&emsp;打野，中期往往是打野在掌控雷电，游戏时间的每一分每一秒都是资源：：‘清野、反野、控龙、抓人（三条）’；蹲人往往收益少于立马决策做其他事，无异于慢性死亡；该止损的止损，该入侵的入侵；配上会入侵的中路更佳。顺风的打野基本在这个时候基本接管比赛。中路，中期也是中路实力的分水岭，如何对线有压制力、甚至单杀，然后预判对方打野动向，做到防gank和gank别人，同时在gank过程中，平衡中路一塔血量和gank之间的平衡。顺风的中路基本在这个时候也基本接管比赛。&emsp;&emsp;辅助，这段时间的辅助往往不能乱带节奏，打野中路不跟的话，辅助没有伤害也只是在浪费时间；因此要根据三路和打野的动向，来决定下一波帮助哪里（擦屁股），至于如何判断，就要根据己方的等级装备和前期的操作，假如这波gank，命中总体3/4技能伤害加起来的不足杀人，就要考虑另换其他地方。&emsp;&emsp;上下路，虽然伤害起来了（崩了），但还不足够接管比赛（输掉比赛），打团的时候不忘保上/下塔，分推兵线给予对方压力又及时参团（就是个劳苦命）。 后期：在后期，已经差不多是各路神仙（笨比）英雄都能乱秀的时期了。这个时候不存在哪个位置影响力不大的情况了。但是还是有个比较关键的点：中路；廉价又高伤害的poke能力影响后期的比赛情况，而这种能力往往是中单英雄，当然也存在其他路英雄出色的poke能力。 &emsp;&emsp;一盘较高水平的比赛，往往拖不到后期；因此综上所述，中路和打野往往决定了一盘比赛的输赢，当你玩其他路的时候看着队友崩，自己无能为力就明白这种感受了，所以推荐中路、打野快速上分。 2.2 位置分析和英雄选择&emsp;&emsp;位置分为5个：上单，打野，中单，下单，辅助 2.2.1 上单&emsp;&emsp;如何作为一个t1-t0级别的上单呢？ 出色的抗压能力。能够单人对（射手）线中在四级前（三分钟内）抗压守塔，甚至让他不敢多摸一下塔 出色的支援能力。打团支援能够十分及时 出色的分推能力。持续的分推给予对方压力，以便打野趁机控龙 出色的一打多能力。能够拖时间，甚至反杀gank你的人 另类的干扰野区能力。能够带惩戒，一级抢河蟹，前中期过渡期间控制（反）对方野区，导致对方打野崩盘 以上有满足几个条件的，就可以当一个上分的上单了；当然不是选了好英雄就能上分，一些基础的分推塔、守塔、打团意识还是要有的。 举例：刘邦（斩杀），孙策（闪现/眩晕），狂铁（闪现），元哥（闪现）；后面会详细讲解英雄特性 2.2.1 打野&emsp;&emsp;打野其实主要分成3类：物刺、法刺、物战；他们其中各有各的优缺点和特点，并会有一定互克性。 物刺：荆轲、玄策、娜可露露、李白、花木兰、兰陵王、猴子 法刺：露娜、司马懿、芈月 物战：赵云、典韦、杨戬、耀 2.2.2 中路&emsp;&emsp;如何作为一个t1-t0级别的中单呢？ 前i期中路对线有足够的压制力 足够的游走能力。在有压制力的同时，能够前往gank且及时回中路一塔（位移/移速加成） 前中后期有（越）廉价的poke能力 较高的技能命中率（参照反例：安琪拉） 另类的干扰野区能力。可以在（不）带惩戒的情况下，敌方打野gank其他路，趁机入侵对面新生成的野区 以上有满足几个条件的，就可以当一个carry型中单了；当然不是选了好英雄就很强了。 举例：沈梦溪（闪现），小乔（闪现），干将莫邪（闪现），武则天（闪现），嫦娥（闪现） 2.2.3 下单&emsp;&emsp;这个位置一般是射手，脆且下路支援能力差，擦屁股位置；在这里就推荐几个 举例：狄仁杰（真正的战士），公孙离，孙尚香，马可波罗 2.2.4 辅助&emsp;&emsp;在整盘游戏中carry和擦屁股摇摆不停的位置，主要还是前期能力、开团能力、保队友能力为主 举例：东皇（闪现），牛魔，鬼谷子，张良（惩戒） 等等 2.3 个别英雄特定分析&emsp;&emsp;在这里逐个分析一些英雄的特性，用他还是对抗他都可以更好的发挥 2.3.1 上单（刘邦）&emsp;&emsp;上单刘邦目前是rank中排名t0第一（我封的）的上单；出色的一二技能 能够压制敌方射手推塔，并且能够反打消耗，多次消耗还能够配合斩杀将对面击杀，在四级开始就有扭转战局的能力（给打野中下路擦屁股）。例如：你家射手鲁班脸探红区，花木兰窜出来一套，此时你是可以改写人头变化的。他之所以能够这么强势不单单因为技能缘故，也与铭文出装有关系。装备推荐：抵抗之靴+冰拳之握+极寒冰心+不祥征兆+魔女斗篷+复活甲铭文：10%移速|10%攻速（蓝）+ 10% CD冷却（绿）+ 红（我是叠护甲和攻速） 强度原因分析： 正常情况下，前期直接裸出两个220布甲（可以防止敌方铭文百穿直接压回家），然后开始合成抵抗之靴；这段时间抗压能力已经是可以反打的那种了；那么如何进行反打呢？之所以两个布甲顺滑合成冰泉是为了（磨血）击杀敌方 用来补充伤害的（是的没错，就是这么强势），需要打2-3套 （1+2）技能+（1-2次）普攻，（此时对面被吓到）及时拉开距离防止被消耗；这样轮回不止，我们生，他们死。当然也不要过分想要线上击杀，换血消耗，让他龟缩塔下不能支援，而我去支援也是一种胜利法。 前中期间，按照装备合成路线，此时是 抵抗之靴+冰拳之握+极寒冰心（+ …）；抵抗靴防止对面中单 法术双穿，大大减少中单对你的伤害；冰泉+冰心，这护甲在该期阶段（对方没有破甲）跟个爹一样，除了特殊（娜可露露的一技能比例伤害）之外，其他打野是抓不动你的；而且现在40%的CD冷却，可以频繁消耗、分推带线、参团 根据对方情况，先合成 不祥or魔女 均可；有人可能就会问，要出霸者线上分推回血吗？当你出这个的时候，说明你对游戏和该英雄的理解不行。玩刘邦，不仅分推，还需要多观察小地图，预判打团的时间；例如我在残血推线，预判是再过15秒开团，火速清线，（确保安全）原地回城，此时团是要基本打起来的，利用提前回城剩余时间和 大招传送时间（大招传送时间将近回2/3血）进行参团；这样的刘邦就能靠自己的意识，自带一件高配版霸者重装了。 对局细节分析： 该英雄会被武则天counter，要让对面先选或者ban掉 深推兵线，能够gank你（你就是中期 高护甲带减速的爹）的打野基本只有一个：荆轲；荆轲那 廉价（真不要钱）的减速，让你回不了塔，但是有一点，她没有控制，可以立马加盾传送走人；其余打野轻松走路回家；走的过程中，二技能要看好时机放，最好不要被打断 一定要多看地图，用大招划队友头像观看（记得划掉）战局分析也可以 &emsp;&emsp;讲完刘邦，看孙策；就有一种异曲同工之妙，不过支援是另外一种方式，一样有扭转战局（擦屁股）的能力。&emsp;&emsp;讲一下剩下的上单英雄。上单往往前期要叠 1-2件护甲背心抗压（效果俱佳，防对方百穿开局的蜜汁伤害）正例： 吕布，抗压能力好，分推一般，容易附魔上头，大招释放要求较高，没有射手局会比较吃香； 狂铁，控好能量轻松1V2，不能上头，铭文出装有要求（铭文：回血|移速（蓝） 百穿（绿、红） || 出装：抵抗之靴+黑切+极寒冰心+名刀+不死鸟+复活甲），前期也要考虑出下两件护甲背心； 元哥，1级 第一个兵控好不要被反控兵线丢掉（我一般二技能等第一个兵快没了才第一次放），3级起杀心小心被打野（4级）抓；其他就花里胡哨自己秀吧 亚瑟，黑切冰拳出了，打拉扯走位，该是你（脆皮）爹还是你爹 李信，带闪现光信看操作；带惩戒黑科技暗信，一级抢河蟹，偷野推线偷塔（经济压制）反例： 程咬金，版本更换的失败者，被无数射手counter，举例：狄仁杰（爸爸）、虞姬（新版专克）、鲁班（这都能被克）；又无法携带惩戒脱胎换骨，前期打野必会被 自身被动 耗危险；分推能力有限，当对面来个辅助庄周守线，就好比上等马（上单）对下等马（辅助） 庄周，等同于放弃这条路 梦奇，对质量变换要求很高，需要多练，但是上限不高 花木兰，会玩的射手往往不会给很多机会，脸探红区就更少了；能够在红区击杀射手的，换个其他上单也能够实现压制对面 2.3.2 打野&emsp;&emsp;这里只讲一些英雄特性裴擒虎：1级必定反野，小心红区草丛跳出来抢野；不反野，这个英雄没有翻身的余地百里玄策：2级gank，尤其是中路，一定要小心，玄策学到1-2技能带个辅助会快速gank获取优势，经典案例：中路草丛链中单拉回去三人配合击杀一血司马懿：同理2级gank，2级是他的强势期露娜：开场刷蓝李白：往往红开，李白二技能释放位置、时机决定了一个李白的操作水平，同时你如何应对李白的二技能也反映了你的水准；李白是很需要百穿铭文的，同时2技能伤害是有破甲效果，然后增加大招伤害效果；那么你被抓，要冷静站在圈内互怼，即少受到李白的二技能伤害、也不会受到加强（破甲）伤害的李白大招，伤害对你来讲不够致命，此时李白要么走，要么被击杀；由上面所述，当对面打野是李白，可能考虑前期出220布甲小背心，在不被李白二技能刮到（坚持在圈内）的情况下，大大减少李白gank你造成的伤害；好的李白当然是控好位移1技能距离，2技能开启刚刚好能刮到你，然后大招伤害最大化。韩信：往往蓝开芈月：很注重红buff，要求敌方打野灵活性较低，方便正面刚入侵野区杨戬：有一定counter打野战士（赵云、典韦）和脆皮刺客（荆轲），虽是笨比，但反打其他笨比能力强兰陵王：这个英雄前期英雄，伤害还有点低，容易被秀，还是不要选了吧；当辅助还行 游戏的前中期对打野尤为重要，时间就是优势，节奏就是要点，不要盲目反野，要根据对方打野动向来判断哪片野区有野，切记不要无所事事逛街、蹲人；在做现在的事情时，要计划好到后面几步是要怎么做，不要迟疑直接去做；gank过程死亡，or 遇到对面厉害的 断节奏大佬（惩戒上单，清野中单），重新把握节奏，判断游戏的走向，不要被牵着鼻子走（例如；红区被反，就直接上线抓人，然而不是为了抓人，而是为了蹭线赖在那里，且赖的时间久，赶不回蓝区的刷新，对面入侵蓝区，节奏就爆炸了） 2.3.3 中路&emsp;&emsp;压线能力、poke能力、走位（位移、移速）能力为中路最重要的能力压线能力是 英雄+操作得出来。有的人能米莱狄压诸葛亮，反手诸葛亮压制米莱狄，操作是要多练的；poke能力则是与生具备的；走位也是 英雄+操作需要多练。举例： 我 小乔 ， 敌方 诸葛亮一级的时候，如果我选择快速支援或者（早）入侵，则需要赶紧出门堵在前面一技能推线，但是这样会出现什么情况？你没有一技能，诸葛亮可以光明正大叠三层被动，你必需要干扰他叠出5层被动来对你压线；如果我不入侵而是要压制诸葛亮，就捏着一技能，导致他怕被我消耗，逼迫他一技能只能打出1-2被动后，（CD的缘故）开始清线消耗他，这样的诸葛亮基本就是会被压线，毫无反抗能力（其中要穿插普攻消耗诸葛亮），这个时候你可以（晚）入侵或支援 举例： 我 诸葛亮 ， 敌方 小乔一级的时候，可以稍微贴近己方靠后兵线，引诱对方一技能推线并躲开，然后光明正大靠前叠出三层被动，cd下一波就能够压制对面兵线了（其中要穿插普攻消耗）；要找机会叠三层被动，走位躲技能压制对方（其中要穿插普攻消耗），被动一出就可以入侵、支援了 英雄推荐： 沈梦溪，作为一个1-2级不讲理的英雄，控好炸弹数量和穿插普攻，能够同时实现清线和消耗，堪比中路的东皇；入侵野区刷野的速率也很快，支援控2技能cd还很快，counter部分中路英雄，是中路t0英雄。缺点：大招cd极慢，对大招释放要求高；因次也有英雄counter他：带吸血刀开大的黄忠，能够长距离吸血防止沈梦溪开大打团收割，其他射手c位需要更谨慎走位吸血才行。沈梦溪支援往往是 大 招+1技能+2技能+普攻+1技能+普攻+2技能 ，或者是 大招+2技能+1技能+普攻+2技能。要明确自己击杀对方的血量斩杀线，再决定gank手法；例如我大招消耗一波，2-3秒立即2技能跟上1技能带普攻直接击杀对面，要对自己的伤害做出详细的估算 小乔：前期一个比较弱势的英雄，根据自己操作提高压线能力入侵野区。这个英雄的特性就是技能移速加成，打拉扯则是小乔的操作关键点；无论是满血还是快死的人，最好都要打拉扯，不要掉以轻心。我的出装： 法穿鞋+吸血书+回响+帽子+法穿+金身 ，铭文： 10%移速|10%攻速（蓝）+ 法穿（绿、红））；前期的法穿鞋可以起到双穿提高伤害和回蓝，吸血书虽然降低伤害，但是能够提供良好的血量，能够更好得走位、拉扯（个人认为前期弱势单纯提高一点伤害意义不大，有血量的拉扯能有更多走位选择）。小乔中后期就是 廉价（真不要钱）的poke能力|拉扯能力的经典代表。 干将莫邪：1-4级均为强势中单，需要多练插得准，1技能在1-3级野区拉扯的时候，可以配合闪现反推，然后配合队友击杀；1级可以躲草偶遇对平A，带点暴击铭文（清线）舒服一点；机动性较差，不能乱入侵野区；有时候可以在中路塔边缘引诱对方打野、辅助，反推1技能进塔收拾。 嫦娥：1级除 对线沈梦溪外 敢快速清线的人，要对野区的掌控力高，尽可能对面蓝开反猪，红开等2-3波后去红区反角落小鸟；当然也有可能快速2级反野遇见对面打野+辅助+中单支援，两下就瘸，不要吝啬闪现（这时候闪现不是很重要），靠特殊回城技能快速回线，基本就是在反野的路上和警告队友被gank；也可以引诱对面，然后草里一技能出来快速反；时不时看机会（几率较大）再gank其他路；不要 乱放大招（加速死亡），能不能大招收拾的尽可能少用大招，准备接下来的团战；铭文需要带吸血，不能出吸血书；要对野怪刷新有很深刻的认知才能驾驭这个英雄，这个英雄不是用来打崩对面中路，而是用来打崩对面打野的。 武则天：人民币英雄，只有免费的时候玩过，大招配合强化1技能的击飞，或者打团大招，还就真的香 其他英雄简介： 诸葛亮：前中期英雄，poke能力差一点，操作走位要求高，闪现是用来杀人 不是用来逃跑的；前期会被 王昭君counter（前中期强势这就是喂了屎嘛），你会发现，王昭君的盾刷新速度+回血包比你消耗的要快，而你被反过来消耗血。反过来也可以预判对方诸葛亮的（经典案例：中路草丛 闪现 到中路野区间小道）操作，及时扭一下位置，能够防止诸葛亮：闪现+1技能+2技能+（穿插普攻）3技能，当你扭开导致诸葛亮的 1技能空掉或者少被动，往往都是能反应过来，而且击杀不了你，你还可以反杀他。 上官婉儿：垃圾英雄，不推荐使用。前期一般的压线能力，4级前的零支援能力，鸡肋的大招效果。看似很强，其实伤害少得可怜；4级，双方接近满血的情况下，上官婉儿想要击杀对面，就必须要在大招行进路程中打出被动碰到对面，统计一下 伤害来源 = 生成的被动（1/2 技能 + 3技能 ）+ 3技能 + 强化普攻 （+ 二技能） 也就是说，我方中路闪现（或走位）及时躲开被动，这个上官婉儿就击杀不了人，甚至心浮气躁搭上闪现也发现击杀不了你。她的一二技能较慢，如果她大招放完你没死，残血的你这时候就更要冷静、把控好距离；在她二技能范围内，左右走位，躲开她的缓慢一技能，二技能就更好躲了，然后距离内 拼技能、平a反杀（边打边走也行）上官婉儿；切莫拉开距离的时候，走a停留在“刚刚好”（上官婉儿有意为之）拉扯到她的二技能点上，要及时走位躲开二技能点。单对单的时候，上官婉儿不怕（菜鸡）金身的，对线别妄想金身就克制上官婉儿。主要还是这个英雄容错率低，招式杀心明显，大优势容易贴身送回去，这也是她的最大痛点。上官婉儿连招基本就是 2技能+3技能+ （强化普攻）1技能+3技能（强化普攻、2技能），那么如何看出她有杀心，关键就在她的 1技能，假如她清线不用1技能，说明她动了杀心，如果用了1技能，就能够放心清线，3-4秒（查技能cd）是安全的。沈梦溪是上官婉儿的couter，他可以连闪现都不用来躲上官婉儿大招、强化的一技能打断大招 和 二技能反过来追击反打；只要她开大，沈梦溪立马开二技能跑，后面准备反打；但是也有种特殊情况，沈梦溪开二技能被上官二技能减速，这种会被追到且8成会死，这就是你的拉扯问题，你菜不怪英雄。如果你操作有点菜，也可以出个小斗篷加强防消耗能力，因为上官是cd鞋，她铭文需要穿透，装备还需要出一个小穿透来达到对脆皮的伤害最大化；出个小斗篷，降低上官对线消耗能力，被刷大后残留更多的血量能走更多位来反杀上官。 高渐离：需要出半肉（前期出个220布甲背心降低对方百穿伤害有奇效），且在未出吸血书前较为弱势，这段时期要谨慎gank；对线他的时候，两个c位要分开站好，往往是闪现大招人群开团；我玩的时候是团战发动机,因此对线他，很顾忌自己的站位，例如：小乔，我都会脱离团队，等（预判）他闪现进场（位置），放一个二技能打出控制，再poke一下，这个高渐离就算是完了。 其他的笨比：安琪拉、王昭君、妲己、扁鹊、米莱狄（前期给他压力，推不了中塔，她就算完了），我就不多介绍了 中路一塔对中路前中尤为重要，可以放弃gank来守塔，中塔是核心点；中路塔只要是在前期掉了，那么这盘游戏的前中期局势就跟（被推塔方）中单没有关系了，基本沦落成辅助（擦屁股）的位置，所以一定要注重兵线对中塔的影响。 2.3.4 辅助&emsp;&emsp;辅助就百花齐放了，牛魔辅助第一是因为他的容错率高，现在也开始双惩戒局，可以考虑下类似 惩戒辅助张良（二技能快速清野；惩戒（肉打野刀：层数少）快速帮打野清野防守 or 入侵野区；强化辅助石 开启移速弥补闪现位移抓人；两个硬控保队友的辅助特性）这些操作 2.3.5 下路&emsp;&emsp;讲一些射手英雄特性 马可波罗：前期单线不需要辅助（关键点），因为推塔能力差，是秀是死看自己操作 虞姬：鸡肋英雄，最好不要用，区分虞姬的操作，只需要看她的一技能释放时机和准确度，因为她的一技能前摇巨大，容易在这个时间点被反杀、被gank击杀（我就是这种）；遇到那种一技能被人突到脸上秒了的，就不要管她生死，帮忙其他路吧 狄仁杰：你爹还是你爹，要注意一下他的发育情况，遏制一下他的发育；不要被他一路压完二塔 三、心态总结&emsp;&emsp;心态很重要，心态往往会影响你的操作。你可能觉得你心态很好，但是如果发现自己的操作开始变形，其实就是你的心态发生了改变（累了），要及时退出rank。不要起杀心和贪心，这点也很关键；当你起了杀心，你的操作将会十分明显（变成一条线，甚至变形），预读起来十分轻松；当你起了贪心，也会让你的操作变形。 举例：对线 达摩（闪现）、高渐离（闪现）、诸葛亮（闪现）、上官婉儿； 一个起杀心（心态不好）的 达摩 玩家，你只要稍微靠一下墙引诱一下离开，就可能出现 达摩一闪大空 然后被人反杀； 一个起杀心（心态不好）的高渐离玩家，你靠一下队友又撤出来，他就会闪现进场，因为你撤出来，他会发现对方有个c位在旁边控制和poke他，高渐离就基本没多少作为 诸葛亮，会玩这个英雄的闪现往往是用来杀人的，闪现+(贴脸)一技能+二技能+三技能；但是反过来，你引诱一下，然后及时往左或右扭开，就能够 让他闪现（贴脸）一技能空掉 上官婉儿，不预估伤害量，和对方其他人位置，直接刷大，甚至闪现跟进，互换甚至敌方残血跑掉 &emsp;&emsp;只要是起了杀心、贪心，心态不行，都会影响到操作变形。该拿的拿，不贪多，人头迟早会有的；输了一盘rank，如果自己是中路 or 打野，要反思一下自己，哪里还能进行更细节的操作，这盘哪个点自己做得不好，以便后面越打越提高自己的意识操作；如果自己是其他位置，哪里带了队友一波节奏，不该送哪个人头，不过是擦屁股的位置，心态放宽点。 练习游戏内的拉扯，可以考虑练习：橘右京（rank别用）、小乔、马克波罗 这几个英雄；练习意识的话，可以考虑练习：刘邦（上路）、中路、打野；中路其实和打野的意识是互通的，往往你打野好，中路也会打得比较好。另祝各位上分愉快！！ 四、版本更新&emsp;&emsp;版本永远是大爹啊！！！ 4.1 截止20200115之前&emsp;&emsp;由于之前的分析可能比较好吧，分析到的基本都砍了(泪) 胜负 = 35%中路 + 45%打野 +20%上下辅 视野的实际视距缩小，大概缩小了1/3，防gank将更需要意识，反应要求更高；暗地削的，可能是这个煞笔游戏想让人注重看人物模型吧 中路法装的削弱，回响(加成0.5 -&gt; 0.3)和面具(法强140 -&gt; 100) 兵线的后期强化，兵线将会越来越难清，伤害越高，速度越快 中路增加河道怪 前期龙的选择变成了两个 部分英雄的削弱：耀、荆轲、扁鹊、嫦娥等 改了点召唤师技能 &emsp;&emsp;中路是最近版本综合削得最惨的 视野的实际视距缩小，导致游走和防gank有了更高的难度；让混子法师(一直呆中路)反而收益 回响和面具的削弱，导致中单滚雪球的能力更差 兵线的后期强化；这个要分两个点来分析：1) 对于一些中后期的法师，基本是要害；因为如果队友前期劣势(而且菜)，由于自己是中后期发力，前期只能提供有限的帮助；这样的话，很容易出现前期劣势；只要前期劣势的，其实中路法师是比较难吃到兵线的，而且兵线加强了，中后期更难清线，(脑瘫)队友就开始抢线了；这样的局势，你中路再会玩，也要拖到比之前版本更加后期才能打举例：小乔2) 有些法师由于技能的特殊性，即使是前期很猛的英雄，由于限制导致，中后期兵线清理将会十分艰难举例：沈梦溪 其他中单法师的削弱1)嫦娥：前期真的太猛了，被比赛因素直接砍伤害；中后期缺少poke能力，现在是下水道了2)扁鹊：砍了大招范围；谁用谁知道，直接下水道了 应运而生的新强势中单1)诸葛亮：随着之前的其他T0、T1(沈梦溪、嫦娥、小乔)削弱，外加中路野的加成，现在是T0中单了2)干将莫邪：变化不多，虽然是被砍了，但是是大家都被砍，反而由于 视野被砍+大招被动，反向加成(大家都削了嘛)，外加中路野的加成，；不过由于本身玩法机制，他一直是T0中单3)高渐离：前期稍微地弱势，中后期发力，但是清兵 和 反打(半肉)能力强，外加中路野的加成，再外加 小乔 削了，所以上位为 T1中单(召唤师技能可替换成狂暴)4)嬴政：人名币英雄不解释，回响和面具(被砍)不出，要出的巫妖(没有被砍)，反向加强5)武则天：人名币英雄，玩法机制仍旧强势，大家都懂 &emsp;&emsp;上路的版本变动不大 仍旧以 刘邦、孙策 为首的 T0、T1上单 边路惩戒(肉打野刀)入侵型上单的崛起1)李信：暗影模式，惩戒；T0上单，被count的只有：狂铁2)孙策：一三技能连贯逃跑，惩戒；T1上单，容易集火就跑不掉，需要出黑切+宗师（+冰心），提高刷野速率3)夏侯惇：大招霸体走，惩戒；T1上单，惩戒用于减速敌人，二技能真伤反野4)耀：各种方式走，惩戒；T1上单，原本还能更强，但是由于对大招伤害削弱，故为T1上单 &emsp;&emsp;打野的版本不大，主要是对个别英雄的削弱和加强 荆轲：技能的削弱，战士打野的崛起，导致她和兰陵王的尴尬位置不远 杨戬：史诗级加强，一技能的范围和机制都改动，战士打野的大部分克星 百里玄策：钩到任何物品的30%免伤，我真的佩服，防gank一流 打野的前期，将更需要辅助度过难关(尤其入侵) &emsp;&emsp;辅助几乎是没有变动，不过这里推荐两个隐藏英雄 惩戒张良：带惩戒出二技能的辅助张良，基本上是反野克星，而且还能入侵，中期需要出奔狼纹章用于 走位 和 团队gank；1)缺点：长手法师无法触发打野刀额外伤害效果，故前期出辅助石(300)即可；对意识的要求更高，不能乱走位探视野，本身前中期很脆2)优点：张良自带真伤，法术加成低，注重出法穿，出两件法强(面具+帽子/回响)等就能刚好秒脆皮，而且携带惩戒，能留住敌人在二技能范围内更久，伤害更多；辅助张良是辅助东皇的究极克星，从前中后期都能完爆对面辅助东皇，实属count关系3)出装方式: 肉打野刀+奔狼纹章+法穿鞋+冰心+面具+回响/帽子4)铭文：法穿88+法术吸血16% 金身钟馗：钟馗这英雄自带仇恨值，体积又大，中期带金身能够大量吸收伤害和躲开控制技能，打团时候，能把对面牵制将近3秒1)缺点：钩子太差就别玩了;大招机制可被逃跑，不能单走，且没有对线能力；被动的问题，很少推塔，只要推塔，别人冲过来打你触发被动，你就要挨防御塔的打了；2)优点：法术加成不高，出1-2件法装，能刚好秒掉一个C位；金身中期能吸引大批火力反打；出小极影(价格又低)混被动；3)出装方式： (1)小极影+CD鞋+防弹背心(220布甲)+金身；(2)小极影+CD鞋+金身+冰心+霸者+振奋；(3)大极影+法穿鞋+金身+冰心+霸者+振奋4)铭文：88法穿+法术吸血8%+移速5%+攻速5%(可把吸血替换成移速)]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建自己的hexo博客]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文不讲详细搭建，小白只是记录一下自己主题是如何（有手就行）配置 一、搭建基于Github和hexo的个人博客&emsp;&emsp;如何搭建最基础的hexo博客，可以参照这位博主，他写的很详细：GitHub+hexo搭建个人博客 二、博客基础配置&emsp;&emsp;配置主要修改的是站点配置文件和主题配置文件（均为_config.yml文件），后面“站点”、“主题”内容均指对应配置文件；安装文件若没有特殊说明均在站点（博客）根目录下安装。 2.1 基本配置&emsp;&emsp;打开myblog根目录下的_config.yml文件（站点配置文件），找到Site模块修改如下基本信息（注意：冒号后面带有空格） 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 2.2 Next主题安装&emsp;&emsp;进入到生成的博客路径，安装一个next主题 12cd mybloggit clone https://github.com/iissnan/hexo-theme-next themes/next &emsp;&emsp;修改站点_config.yml中的theme 1theme: next 做完记得清除Hexo的缓存：hexo clean&emsp;&emsp;安装完next主题，进入 根目录/themes/next 同样也会有一个_config.yml（主题配置文件）。 2.3主题样式&emsp;&emsp;在 主题 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist scheme: Pisces#scheme: Gemini 一共有四种主题风格可以选，对应的侧栏设置也不同。在 主题 找到sidebar 12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 2.5 菜单，标签，分类，关于&emsp;&emsp;在 主题 找到Menu Setting 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 以archives: /archives/ || archive为例：||之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去 Font Awesome 中查看或修改，Next主题所有的图标都来自Font Awesome 。 &emsp;&emsp;这个时候，菜单中的标签、分类、关于是进不去的，需要自己另外新建页面。创建标签 1hexo new page tags 在站点路径的source会生成对应页面文件,只时候才能进去菜单的标签页面；其他页面同理；页面标题可修改title，关闭页面评论可修改comments。 123456---title: some tagsdate: 2019-09-22 15:19:49type: &quot;tags&quot;comments: false --- 增加一些自己特有页面，还要修改其对应的翻译文本，翻译文本放置在 Next主题 目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 2.6 头像设置+旋转&emsp;&emsp;在 主题 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg放入themes/next/source/images中就好了。实现头像旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 2.7 添加搜索功能1.安装 hexo-generator-searchdb 插件 1npm install hexo-generator-searchdb --save 2.修改 站点 ,找到Extensions 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3.修改 主题 ，找到Local search，将enable使能 true。 三、博客高级配置3.1 浏览量 访客量 阅读数&emsp;&emsp;在 主题 写入代码如下： 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 有 site_uv_footer: 人看过我的博客啦 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 次阅读 修改统计规则及busuanzi失效修复&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：代码如下： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 3.2 字数统计 阅读时长 总字数&emsp;&emsp;在站点根目录安装 1npm i --save hexo-wordcount 然后再进入 主题 修改如下： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true #字数统计 min2read: false #预览时间 totalcount: false #总字数，显示在页面底部 separated_meta: false #无作用 3.3 文章发表 更新时间&emsp;&emsp;打开 主题 ,搜索关键字updated_at 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: true #文章发表 更新时间 categories: true 3.4 友链、社交网站&emsp;&emsp;友链可以在 主题 Blog rolls参照注释 1234567# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: inlinelinks: 火影.青春.梦想: https://www.bilibili.com/video/av42311652 FATE.士郎: https://www.bilibili.com/video/av45828728 &emsp;&emsp;社交网站同理在 主题 social参照注释，不过需要配置social_icons 1234567#是否启用社交链接图标social_icons: enable: true#匹配图片名称，在 Font Awesome 查询 GitHub: github Twitter: twitter 微博: weibo 3.5 博客运行时间&emsp;&emsp;打开next\layout_partials路径中的footer.swig,加入下面代码段（我加在了最后面）： 1&lt;span id=&quot;timeDate&quot; title=&quot;网站运行时间&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot; title=&quot;网站运行时间&quot;&gt;载入时分秒...&lt;/span&gt; 在next\layout_layout.swig中插入下面代码块： 1234567891011121314151617&lt;!--此处为建站时间 --&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;09/13/2019 12:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML =&quot;(ㆆᴗㆆ)本站建立了&quot;+dnum+&quot;&amp;thinsp;天&quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot;&amp;thinsp;时&quot; + mnum + &quot;&amp;thinsp;分&quot; + snum + &quot;&amp;thinsp;秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 3.6 评论功能&emsp;&emsp;打开来必力官网： https://livere.com按套路注册,点击上方的安装，选择免费的city版本。并点击现在安装，复制其中的uid字段。打开 主题 ，定位到livere_uid，粘贴上刚刚复制的UID。 四、美化配置4.1 隐藏网页底部 Hexo 强力驱动&emsp;&emsp;打开 主题 ,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 4.2 浏览器恶搞标题&emsp;&emsp;在目录 \Hexo\themes\next\source\js\src 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/trhx2.png&quot;); document.title = &apos;(*/ω＼*)我藏好了&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/trhx2.png&quot;); document.title = OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 然后在 \Hexo\themes\next\layout\layout.ejs 文件中添加如下代码(我放在最后)： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/FunnyTitle.js&quot;&gt;&lt;/script&gt; 4.3 鼠标点击特效（颜文字）&emsp;&emsp;也是 在目录 \Hexo\themes\next\source\js\src 下新建一个 emoji.js 文件，在里面填写如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 onload = function() &#123; var click_cnt = 0; var $html = document.getElementsByTagName(&quot;html&quot;)[0]; var $body = document.getElementsByTagName(&quot;body&quot;)[0]; $html.onclick = function(e) &#123; var $elem = document.createElement(&quot;b&quot;); $elem.style.color = &quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;;/*点击效果颜色*/ $elem.style.zIndex = 9999; $elem.style.position = &quot;absolute&quot;; $elem.style.select = &quot;none&quot;; var x = e.pageX; var y = e.pageY; $elem.style.left = (x - 10) + &quot;px&quot;; $elem.style.top = (y - 20) + &quot;px&quot;; clearInterval(anim); switch (++click_cnt) &#123; case 1: $elem.innerText = &quot;&lt;(￣3￣)&gt; 表！&quot;; break; case 2: $elem.innerText = &quot;ʅ（´◔౪◔）ʃ&quot;; break; case 3: $elem.innerText = &quot;(๑•́ ₃ •̀๑)&quot;; break; case 4: $elem.innerText = &quot;(๑•̀_•́๑)&quot;; break; case 5: $elem.innerText = &quot;（￣へ￣）&quot;; break; case 6: $elem.innerText = &quot;(╯°口°)╯(┴—┴&quot;; break; case 7: $elem.innerText = &quot;Ψ(￣∀￣)Ψ&quot;; break; case 8: $elem.innerText = &quot;╮(｡&gt;口&lt;｡)╭&quot;; break; case 9: $elem.innerText = &quot;( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃&quot;; break; case 10: $elem.innerText = &quot;(ノへ￣、)&quot;; break; case 11: $elem.innerText = &quot;o(￣ε￣*)&quot;; break; case 12: $elem.innerText = &quot;(ꐦ°᷄д°᷅)&quot;; break; case 13: $elem.innerText = &quot;٩(●´৺`●)وbiu&quot;; break; case 14: $elem.innerText = &quot;(ꐦ°᷄д°᷅)&quot;; break; // case 15: /*此处可以按照上面的格式添加表情*/// break; default: $elem.innerText = &quot;(*/ω＼*)&quot;; click_cnt=0; break; &#125; $elem.style.fontSize = &quot;bold&quot;; var increase = 0; var anim; setTimeout(function() &#123; anim = setInterval(function() &#123; if (++increase == 150) &#123; clearInterval(anim); $body.removeChild($elem); &#125; $elem.style.top = y - 20 - increase + &quot;px&quot;; $elem.style.opacity = (150 - increase) / 120; &#125;, 8); &#125;, 70); $body.appendChild($elem); &#125;; &#125;; 然后 也是 在 \Hexo\themes\next\layout\layout.ejs 文件中添加如下代码(我放在最后)： 12&lt;!-- 页面点击颜文字表情 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/emoji.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;颜文字选取网站：http://www.yanwenzi.com/chihuo/，可以根据自己的喜好增加表情✧٩(ˊωˋ*)و✧ 4.4 更换背景&emsp;&emsp;在 themes/next/source/css/_custom/custom.styl 中添加如下代码： 1234567891011121314151617181920// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125; &#125;&#125; 上面图片链接是我的配置，也可以自己切换成本地图片链接（替换https）：/images/bg.jpg 4.5 背景动态粒子&emsp;&emsp;该功能已经嵌入到新版本 next主题 配置，所以只要使能就行；canvas_nest是一种（很常见）随机线条在鼠标位置凝聚；我的配置选的是canvas_nest: true。 12345678# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 4.6 加入live2D看板娘1npm install --save hexo-helper-live2d 还需要选择下载自己喜欢的模型，如我的看板娘为live2d-widget-model-koharu ，则 1npm install live2d-widget-model-koharu 其他live2D模型预览查看：https://github.com/xiazeyu/live2d-widget-models 在站点添加以下内容 12345678910111213# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true scriptFrom: local model: use: live2d-widget-model-koharu #模型选择 display: position: right #模型位置 width: 180 #模型宽度 height: 360 #模型高度 mobile: show: false #是否在手机端显示 五、优化配置5.1 解决页面过小问题&emsp;&emsp;文章宽度过小，而两边宽度过大；修改themes\next\source\css_schemes\Pisces_layout.styl &emsp;&emsp;以下是Mayfly大佬的_layout.styl配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131.header &#123; position: relative; margin: 0 auto; //width: $main-desktop; width: 80%; +tablet() &#123; width: auto; &#125; +mobile() &#123; width: auto; &#125;&#125;.header-inner &#123; position: absolute; top: 0; overflow: hidden; padding: 0; width: 240px; background: rgba(255,255,255,0.8); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() &#123; .container &amp; &#123; width: 240px; &#125; &#125; +tablet() &#123; position: relative; width: auto; border-radius: initial; &#125; +mobile() &#123; position: relative; width: auto; border-radius: initial; &#125;&#125;.main &#123; clearfix(); +tablet() &#123; padding-bottom: 100px; &#125; +mobile() &#123; padding-bottom: 100px; &#125;&#125;.container .main-inner &#123; //width: $main-desktop; width: 80%; +tablet() &#123; width: auto; &#125; +mobile() &#123; width: auto; &#125;&#125;.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; //width: $content-desktop; width: calc(100% - 260px); background: white; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; &#125;&#125;.sidebar &#123; position: static; float: left; margin-top: 300px; width: $sidebar-desktop; background: $body-bg-color; box-shadow: none; +tablet() &#123; display: none; &#125; +mobile() &#123; display: none; &#125;&#125;.sidebar-toggle &#123; display: none; &#125;.footer-inner &#123; //width: $main-desktop; padding-left: 260px; +tablet() &#123; width: auto; padding-left: 0 !important; padding-right: 0 !important; &#125; +mobile() &#123; width: auto; padding-left: 0 !important; padding-right: 0 !important; &#125;&#125;.sidebar-position-right &#123; .header-inner &#123; right: 0; &#125; .content-wrap &#123; float: left; &#125; .sidebar &#123; float: right; &#125; .footer-inner &#123; padding-left: 0; padding-right: 260px; &#125;&#125; 5.2 设置透明背景1.内容板块透明&emsp;&emsp;博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为： rgba(255,255,255,0.7);link1232.菜单栏背景&amp;emsp;&amp;emsp;博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .header-inner 标签下 background: white修改为：```background: rgba(255,255,255,0.7); //0.7是透明度 3.站点概况背景&emsp;&emsp;博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为： rgba(255,255,255,0.7);link12&amp;emsp;&amp;emsp;然后修改博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：```background: rgba(255,255,255,0.7); //0.7是透明度 4.按钮背景&emsp;&emsp;博客根目录 themes\next\source\css_common\components\post\post-button.styl 同上修改对应位置为 background: transparen 5.3 博客压缩加速访问在站点的根目录下执行以下命令： 12npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在根目录新建 gulpfile.js ，并填入以下内容 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 注意， 修改上面的各个目录为你的真实目录， **代表0或多个子目录(需要注意一下自己的路径是否正确)&emsp;&emsp;在每次执行完 hexo g 之后，在执行 gulp 命令，就会压缩一次静态文件，例如： 1hexo clean&amp;&amp;hexo g&amp;&amp;gulp&amp;&amp;hexo d 六、写博客6.1 去掉文章目录标题的自动编号&emsp;&emsp;打开 主题 ，找到Table Of Contents,将number失能 6.2 主页文章添加阴影效果&emsp;&emsp;打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678/*主页文章添加阴影效果*/ .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 6.3 主页显示 阅读全文&emsp;&emsp;在文章中使用 < !--more--> 手动进行截断 6.4 文章结尾–加入感谢阅读&emsp;&emsp;在\themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body字样之后,post-footer字样之前添加如下代码（post-footer之前两个DIV）： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开 主题配置文件,在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 6.5 文章加密访问&emsp;&emsp;打开themes/next/layout/_partials/head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 123456---title: 如何搭建自己的hexo博客date: 2019-09-27 23:17:10tags: [hexo,next,博客]password: password--- 6.6 文章中插入代码&emsp;&emsp;在 站点 中，找到hightlight: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 再到 主题 ，找到highlight_theme: normal;注释显示有五种显示主题可用，我的配置为night blue。如何插入则如下图所示： 6.7 代码复制按钮 下载插件clipboard.js； 将下载的clipboard.js文件下的dist文件夹中的文件拖到.\themes\next\source\js\src 文件夹下 也是在.\themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = &apos;&apos;; copyHtml += &apos;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&apos;; copyHtml += &apos; &lt;i class=&quot;fa fa-globe&quot;&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;&apos;; copyHtml += &apos;&lt;/button&gt;&apos;; $(&quot;.highlight .code pre&quot;).before(copyHtml); new ClipboardJS(&apos;.btn-copy&apos;, &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 在.\themes\next\source\css_custom\custom.styl文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在.\themes\next\layout_layout.swig文件中（我加在最后）： 123&lt;!-- 代码块复制功能 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard-use.js&quot;&gt;&lt;/script&gt; 6.8 博客插入本地图片 把 主页 的post_asset_folder这个选项设置为true2 .在根目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片放进去后，在博文中插入图片如下：1&#123;% asset_img image.jpg This is an image %&#125; 七、总结&emsp;&emsp;以上就是我的hexo配置了，其实我也是个小白，上面都是从一个个大佬采集过来的，但是数量太多且杂，就不一一放对应链接了；网上也有很多搭建hexo的教程，其他的配置可以自己去找。到现在我自己还有些搞不明白的，例如在新建page插入图片这种基操都不会（![]这种makedown语法显示图片貌似已经不能用了），一些别人花里胡哨的特效也搞不出来，如果有大佬能指导一下就好了；如果你是小白，当然还是小白一起共勉啦✧٩(ˊωˋ*)و✧]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil软件配置]]></title>
    <url>%2F2019%2F09%2F17%2FKeil%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、Keil5 背景主题安装&emsp;&emsp;keil5背景主题在网上有很多，直接从网上下载，安装方法如下： 找到安装Keil路径(X:\Keil_v5\UV4); 在UV4目录下的global.prop文件; 将网上下载的.prop文件覆盖原有文件，建议覆盖前备份原文件。 当然也可以细点配制出自己想要的风格（我比较懒），详细的配色方法可以参照这位博主：Keil软件配置 二、Configuration配置&emsp;&emsp;在工具栏中找到小扳手图标或者在菜单栏中打开 Edit-Configuration，大多数功能都在这改。 2.1 缩进和编码设置&emsp;&emsp;如下图设置将编码格式设置为国标，Tab固定缩进为4格 ASCII编码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 GBK编码：方式是中文占两个字节，英文占1个字节。 &emsp;&emsp;从上面可知，假如是做嵌入式前端界面时，不要采用我们编程通用的 UTF-8格式，因为它的中文储存字节相对更大。前端界面要储存较多的汉字字库等，因此界面不会采用UTF-8编码格式。 2.2 代码自动补全&emsp;&emsp;进入Text Completion，勾选如下图并填入你需要在输入第几个字符后开启补全提示。 2.3 快捷键的设置&emsp;&emsp;查询某句代码时候，往往会使用ctrl+F跳到Find选项进行查询，如下图所示 Look in:有两个选项：&emsp;&emsp;1)Current Document 只查询当前文档&emsp;&emsp;2)Current Project 查询整个工程Find选项，查询到的时候，是要一直点击next查看下一个的；而Find in Files则是可以在下面列出一个所有能查询到的列表，实际上更常用的是这个（每次都要动下鼠标改成Find in Files）。 因此，在Configuration找到Shortcut Keys选项 1)将Edit：Find快捷键去掉，将Edit：Find in Files快捷键补上ctrl+F；2)顺便加一下注释的快捷键 Edit：Advanced ：Comment Selection和Edit：Advanced ：Uncomment Selection为ctrl+shift+ c|v（个人喜好）；3)顺便将Edit：Advanceed:Go toDefinition of current Word设置为ctrl+d，这样后面进入具体参数位置就ctrl+d或F12都可以用。 2.4 快速浏览 .c文件的函数位置&emsp;&emsp;先在view选项把基本没用的books和Templates功能给隐藏掉。如下图所示 然后进入在Configuration找到Scan funtion names in project files 给关掉 关掉它有什么好处呢？我们可以在Project旁边的｛｝Functions只会显示你在右边的框打开的.c文件，然后 你就可以.c文件打开查看函数，假如没有关掉它的话，它会把项目所有的 .c和.h文件都放出来，到时候别说找函数了，你可能连 .c文件都找不到。 三、Options for Target配置&emsp;&emsp;这里讲下Options for Target配置里面需要注意的内容 3.1 Target选项&emsp;&emsp;Target界面主要分为两块 3.1.1 FPU浮点处理器&emsp;&emsp;基于Cortex-m4（例如：STM32F407）最大的特色就是加入了一个FPU浮点处理器，能支持DSP运算。更高版本的甚至能够支持double类型处理（例如：STMH7）。 &emsp;&emsp;如果只是写裸机程序的话，就无需在意；&emsp;&emsp;假如是写实时操作系统（例如UCOSIII）需要注意的是：UCOS III官方的移植版本竟然不支持FPU浮点运算；如果在MDK的设置选项中,使能FPU， 运行的时候会出现奇怪的错误，有时候直接跑飞（例如：程序如果进行打印浮点型数据就会进入硬件错误；甚至有时候程序量大的时候，一编译，你根本不知道bug在哪？而且还会报错）。逐步调试会发现：只要运行打印浮点数就会程序跳转到硬件fault；1）可能是字节对齐问题，修改字节对齐即可解决问题；2）或者你移植的RTOS本来就不支持，需要修改底层配置函数；解决方法：ucosii中调用Printf打印浮点型数据就进入硬件错误，STM32F4&emsp;&emsp;个人建议：移植UcosIII的时候，程序运行暂时先不启用FPU，等到程序跑得稳定、需要优化的时候，再启用FPU，明确不是原有程序版本带有的bug。 3.1.2 IROM&emsp;&emsp;如果不涉及bootloader在线升级的情况下，采用一般的例程的配置IROM即可；倘若涉及到，可详细看这篇博文：STM32开发 3.2 Output Browse Information选项是可以查看函数具体内容和位置；但是这里有点经验，就是当你编译类似stm32H7系列那种大容量RAM的芯片的时候，往往它自带的库也是很大，里面有很多函数要编译；当你编译工程的时候，那速度你会怀疑人生，这个时候你可以关闭这个选项，可以大大减少你需要的编译时间，但是缺点是不能跳转函数，可以用ctrl+F替代找到你要的函数位置。 Create HEX File选项，是生成hex文件&emsp;&emsp;烧录程序方式分为两种：1） .bin文件进行烧录2） .hex文件进行烧录我们常用的串口、J-link（SW模式，直接在项目工程）烧录程序进芯片，均是采用hex文件；.bin文件只会在脱机烧录和在线升级的时候才会用到。 更多相关.bin文件和.hex文件知识，可详细看这篇博文的bootloader章节：STM32开发 3.3 User &emsp;&emsp;这里是运行keil脚本的地方，是要在编译前调用执行脚本，还是编译后调用执行脚本。如 *3.2 Output *所示，Output选项中只有生成.hex文件，没有生成.bin文件的选项；一般情况下，就有人在 编译后选项 里调用keil自带的脚本fromelf.exe，用于生成.bin文件。&emsp;&emsp;由于每个人的电脑的Keil安装路径不同，因此别人安装的脚本位置也就不同；有时候你编译别人的代码，会出现非代码的Error：显示你找不到对应路径的fromelf.exe；这个就是找(错)不到脚本位置而报错，这个时候可以将上图红色地方选项，勾选给取消掉就可以用了，当需要对应的bin文件再进行更改具体路径即可。 3.4 C/C++ 3.4.1 芯片库选择Stm32芯片型号移植的时候，最重要的就是这个位置；在这里举例一下F10x系列 &emsp;&emsp;至于要使用哪个宏，则需要根据具体的芯片来进行选择。如果是STM32F105xx和STM32F107xx，是Connectivity Line Devices，则宏定义选择的是STM32F10X_CL；如果是别的型号，则根据FLASH的容量来进行选择。可能文字写的有点不太清楚，还是以表格来说明： &emsp;&emsp;宏定义更换的时候，也好同时把启动文件给换掉，例如：startup_stm32f10x_hd.s修改为startup_stm32f10x_md.sPs：其实到这里基本移植完了，不过有时候会出现程序跑的非常慢，有些工程在汇编底层启动文件调用Systeminit();再跳转到main()，有些则无配置时钟树，这个时候在系统初始化时调用 SystemInit();，后面就正常了 3.4.2 优化等级&emsp;&emsp;在上图所示，中间有一个Optimization选项，是对程序优化的等级；一般我们调试的时候，采用最低的Level 0，因为如果我们进行仿真调试，优化等级太高，程序无法跳转运行到设置的断点；当程序调试稳定后，再根据需求提高其代码优化等级即可。 四、技巧用法&emsp;&emsp;这里讲一些自己在用的实用小技巧 4.1 仿真精确测量代码运行时间&emsp;&emsp;为什么需要精确测量代码运行时间？其实往往之所以需要其精确的运行时间，主要分为两种情况： 上电初始化，某些芯片模块本身的器件性质，导致MCU不能上电立马 初始化(通信进行软件配置)该芯片；根据初始化函数放的位置，MCU初始化的指令执行够快，上电快速与其芯片立马通讯后，导致会出现不可预知且随机的bug；并且这种bug是隐性的，如果你其他的功能所需的初始化时间够长，这个bug就会(偶然)消失掉。因此需要测出时间，并在该芯片初始化通讯前增加延时(死循环) 需要知道整个程序循环一遍需要多长时间。往往串口通讯、开关扫描、AD采样等的数据处理往往是通过 轮询 的方式实现的。例如，AD采样频率是 960次/秒 ，如果你的程序的循环次数 达不到至少(冗余) 1000次/秒 ，那么就算是使用 ADC采样（外部）中断 及时获取到数据，但是由于程序循环速度太慢，AD采样数据无法及时进行处理换算，实际上 AD采样频率 &lt; 程序循环次数 &lt; 960次/秒 。因此 程序循环所需时间大小，也决定了轮询处理响应速度的慢快。 Ps：获取数据的方式有两种：轮询 和 中断 。一般情况下，最好是使用中断方式，能够及时获取到数据；采用轮询方式来获取数据，当没有数据来临时，也会进入轮询。当你的程序量比较少的时候，你的程序循环速度会很快，这样的话，轮询将会占用较多的CPU(内存)资源，而中断如果不触发，则不会进入，单位时间内程序循环将会相对来讲会优化一些。 &emsp;&emsp;实际上有很多种方法可以实现测量运行时间 4.1.1 采用Keil仿真的 Trace 功能&emsp;&emsp;首先要先配置好仿真的时钟：在Target进入Debug，然后设置成J-link（或者ST-link，大同小异），进入setting，再选择Trace选项 SW模式：先勾选Enable，调成对应时钟（例：72MHz），再使能Autodetect max SWO ClkJTAG模式（不常用）：设置时钟，然后不勾选Enable（JTAG不支持Trace，会报错，容易出现SW切换JTAG时忘记关掉Trace） 仿真的时候找下有个时间窗口 上面两个是复位“t1”和“t2”的，下面3个是选择在状态栏上显示哪个时间。 “t0”表示程序开始运行到现在的时间，是不能复位的。另外两个可以随便复位，就可以用来测具体某一个函数或某一行程序的运行时间。 &emsp;&emsp;具体操作为：在要测试的代码前加一个断点，当程序运行到目标行时会停下，然后复位“t1”或“t2”，并在下一行代码前加断点，然后继续运行程序，程序会停在下一行代码前，这个时候“t1”的值就是目标行程序的运行时间。 Ps：Keil仿真 全速运行时 观察窗口变量没刷新；解决方法：在仿真时点击工具栏里的view选择下面的periodict window update，勾选完后数据开始动态更新。 Ps：Cortex-M0不支持Trace功能，因为是ARM V6结构，比较旧，所以无论你用J-link，还是ST-Link，都不能用到Trace。Keil会提示TRACE HW not present 4.1.2 采用定时器计时&emsp;&emsp;配置好一个定时器，具体计算配置操作可以看STM32开发思路：获取 进入程序段的当前时间，退出程序段后再获取当前时间，两个时间之差就是其运行时间(* 定时器计时基数)。 4.2 程序跑飞跳转&emsp;&emsp;有时候你会在工程看到这段汇编的函数. 123456789__asm void wait()&#123; BX lr&#125;void HardFault_Handler(void)&#123; /* Go to infinite loop when Hard Fault exception occurs */ wait();&#125; &emsp;&emsp;HardFault_Handler栈溢出检查机制，适用于所有CM3芯片，造成主栈(MSP)溢出的原因有很多，如过多的定义局部变量，递归调用，中断嵌套等都有可能会导致主栈溢出，stm32不具备MPU，没有对内存进行保护的硬件机制，而软件检测栈溢出又有其局限性。 STM32出现HardFault_Handler故障的原因主要有两个方面： 内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。 堆栈溢出。增加堆栈的大小。大多数是因为中断嵌套寄存器均是32位，且STM32是小端模式(参考Cortex-M3权威) 1)出现问题时排查的方法：DEBUG，下断点单步看程序停在哪2)另一种方法：默认的HardFault_Handler处理方法为：内部是一个 汇编 或者 C语言 形式的死循环；将它改成如上面代码的 BX LR直接返回的形式。然后在这条语句打个断点，一旦在断点中停下来，说明出错了，然后再返回，就可以找到程序跑飞出错的位置的语句在哪。 4.3 自动生成版本号（编译时间和编译日期）&emsp;&emsp;经常都需要手动添加版本号或者生成时间会很繁琐。这个时候，C语言中的两个宏__DATE__和__TIME__可以帮到我们。__DATE__用于获取系统日期，而__TIME__用于获取系统时间，我们可以根据该两个宏获取到的信息将其保存于程序变量中，在程序运行过程中直接调用。 我们在程序中可以按以下所示使用： 1234const unsigned char cRevisionDate[12] = __DATE__;const unsigned char cRevisionTime[16] = __TIME__;printf("Rev Info: %s %s\r\n", cRevisionDate, cRevisionTime); 运行结果如下所示： 1Rev Info: Sep 8 2018 17 51 26 更复杂的使用方法可以看这篇：Keil版本号生成 4.4 仿真动态显示&emsp;&emsp;点击仿真后，如果Watch窗口数据不能动态显示，可在仿真状态下点击tool栏的view，观察periodict window update是否勾选，确保勾选即可。此时数据动态更新。Ps：退出仿真状态下，工具栏的view没有periodict window update选项。 4.5 如何上传github&emsp;&emsp;首先新建一个批处理，用于清除掉keil工程的编译文件： 12345678910111213141516171819202122232425262728293031323334353637::删除Keil编译产生的一些垃圾文件::删除Code Warrior编译产生的一些垃圾文件del *.bak /sdel *.ddk /sdel *.edk /sdel *.lst /sdel *.lnp /sdel *.mpf /sdel *.mpj /sdel *.obj /sdel *.omf /s::del *.opt /s ::不允许删除JTAG的设置del *.plg /sdel *.rpt /sdel *.tmp /sdel *.__i /sdel *.crf /sdel *.o /sdel *.d /sdel *.axf /sdel *.tra /sdel *.dep /s del JLinkLog.txt /sdel *.iex /sdel *.htm /sdel *.sct /sdel *.map /sdel *._2i /sdel *.L2P /sdel *.FED /sdel *.elf /sdel *.args /sdel *.mk /sdel *.local /sexit &emsp;&emsp;具体的批处理操作解读，可以看另外一篇文章Window的简易bat处理 4.6 搭配推荐&emsp;&emsp;推荐一些自己在用的实用搭配 4.6.1 Astyle&emsp;&emsp;Astyle是keil的一个插件，关于Astyle看另外一篇博客：Keil格式化工具_Astyle 4.6.2 Snipatse&emsp;&emsp;Snipatse是一个超级方便的截图软件 4.6.3 Compare&emsp;&emsp;Compare是一个比较代码的软件，特别好用。你可以比较现在版本和之前版本的区别；或者是你的版本和别人的版本，能很快找到差别]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)Keil代码格式化工具_Astyle]]></title>
    <url>%2F2019%2F09%2F15%2FKeil%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7-Astyle%2F</url>
    <content type="text"><![CDATA[一、前言&emsp;&emsp;在用Keil5编写程序的时候，很多情况要参考别人写的程序来完成开发，在这过程中，看到了很多代码编写风格不一、代码编写不规范的情况。有时候看的头都大了，在一次偶然的情况下，认识了 Astyle 这一代码格式工具，就根据帖子上的教程配置在了 Keil 上，后面在使用的过程中，发现这款插件的高效性，所以特意拿出来分享 二、Astyle2.1 Astyle 官网&emsp;&emsp;Astyle 官网链接：http://astyle.sourceforge.net/ 2.2 Astyle 介绍&emsp;&emsp;我直接搬官网两句话来介绍，官网的介绍已经十分详细了，文档等信息都可以在官网上获取到。&emsp;&emsp;Artistic Style is a source code indenter, formatter, and beautifier for the C, C++, C++/CLI, Objective-C, C# and Java programming languages.&emsp;&emsp;Artistic Style是 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的代码缩进器、格式化器和美化器。&emsp;&emsp;Artistic Style是适用 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的免费、快速和小型自动格式化软件。 2.3 Astyle 下载&emsp;&emsp;进入官网,在官网下方点击 Download 进入下载页面. &emsp;&emsp;下载页面直接下载最新版本即可. &emsp;&emsp;等待弹出下载后保存到你的电脑. 2.4 Astyle 保存&emsp;&emsp;Astyle 下载完后，根据自己的需求和方便，解压并保存好就可以了。这里我是直接丢在了 keil5 的根目录下。 三、Keil5 增加 Astyle 插件3.1 Keil5 使用 Astyle 效果&emsp;&emsp;使用前: &emsp;&emsp;使用后: 3.2 Keil5 配置 Astyle&emsp;&emsp;打开 Keil5 ,然后在菜单栏中找到 Tools-Customize Tools Menu… &emsp;&emsp;打开后,增加两个内容,分别命名为: Astyle All FilesAstyle Current File &emsp;&emsp;命名可以自己需求，不一定和我一样。&emsp;&emsp;然后位置都选择你解压 Astyle 文件中 bin 文件夹下的 Astyle.exe&emsp;&emsp;在 Arguments 参数中对应填入:Astyle All Files -n "$E.c" "$E.h"Astyle Current File -n !E &emsp;&emsp;如图: &emsp;&emsp;设置好后我们点 OK 应用。 3.3 Keil5 使用 Astyle 格式代码&emsp;&emsp;配置好后，我们可以在Tools-Customize Tools Menu...中看到我们新增加的两个自定义工具。 &emsp;&emsp;格式化整个工程的 .c 与 .h 文件就选择 Astyle All Files。&emsp;&emsp;格式化当前文件则选择 Astyle Current File.&emsp;&emsp;格式化可以在 keil 的输出窗口看到格式情况。 3.4 关于配置参数上的解释我们在 keil5 中填入了两行参数值： Astyle All Files-n "$E.c" "$E.h" Astyle Current File-n !E-n，格式化文件时，新的缩进的文件将保留原始文件，创建原始文件的副本，并在原始文件名后附加 .orig ，可以通过 -n 来取消设置备份副本。 "$E.c" "$E.h",$E是 Keil 的指令，表示工程内的全部文件，加上 .c 与 .h ，表示工程内 .c 文件与 .h 文件，Astyle 也会只格式化工程里的全部的 .c 与 .h 文件。 !E,!E 是 Keil 的指令，表示当前文件, Astyle 在操作时就只格式化当前的文件。 四、Astyle 的其他配置4.1 括号格式化风格 &emsp;&emsp;具体的可以参照 Astyle文档,不过多叙述。 4.1.1 allman 风格--style=allman / --style=bsd / --style=break / -A1 Allman style uses broken braces. 12345678910int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.2 java 风格--style=java / --style=attach / -A2 Java style uses attached braces. 1234567int Foo(bool isBar) &#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.3 kr 风格--style=kr / --style=k&r / --style=k/r / -A3 Kernighan &amp; Ritchie style uses linux braces. Opening braces are broken from namespaces, classes, and function definitions. The braces are attached to everything else, including arrays, structs, enums, and statements within a function. Using the k&amp;r option may cause problems because of the &amp;. This can be resolved by enclosing the k&amp;r in quotes (e.g. –style=”k&amp;r”) or by using one of the alternates –style=kr or –style=k/r. 12345678int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.4 其他&emsp;&emsp;还有很多的风格,可以在对应的文档看，总共有15种风格任君挑选，如 python、google、linux 风格等。&emsp;&emsp;因为我用 Keil 开发是 C 语言，所有我选了 A1 的风格，所以相应的在 Keil 上我就配置了: -n -A1 "$E.c" "$E.h" &emsp;&emsp;不生成副本，用 A1 风格，来格式化整个工程的 .c 与 .h 文件。 4.2 格式化缩进长度4.2.1 空格缩进&emsp;&emsp;这里我就不在截图了，具体的可以看文档，默认我们不配置缩进选项的话，默认是4个空格，如果你想要更改缩进的空格长度，你可以通过:--indent=spaces / --indent=spaces=# / -s# &emsp;&emsp;-s4，就是缩进 4 个空格，那么相应的，要改缩进 x 个空格就更改 -sx 就可以了. 4.2.2 制表符缩进&emsp;&emsp;同上，--indent=tab / --indent=tab=# / -t / -t# &emsp;&emsp;-t4，就是缩进 4 个制表符，那么相应的，要改缩进 x 个制表符就更改-tx就可以了。 4.2.3 其他&emsp;&emsp;还有另外两种缩进方式，我觉得很少使用，就不列举了，有兴趣了解同样的访问官方文档即可。 4.3 其他&emsp;&emsp;还有许多格式化的形式，我也不多加叙述，例如缩进’switch’块、’case’块、注释、’class’和’struct’块、预处理程序缩进等许许多多的格式化方式，官方文档列举的说明十分详细，针对自己需要的、想要的格式化需求，针对性的在文档中寻找并利用，制作一个自己的高效率工具。 五、个人心得(非转)&emsp;&emsp;注意格式化之前需要保存，否则不会进行格式化；Astyle Current File是格式化当前文件，Astyle All File不是格式化整一个工程，而是格式化当前文件所在的文件夹中所有.c和.h文件；倘如你写的驱动或者实现功能.c文件是封装成独立文件夹时，需要多次单独处理。&emsp;&emsp;给两个处理模板： Astyle Current File：-n !E –style=ansi -s4 -K -W -p -H -xC80 -S -m0 -M40 -c Astyle All File：-n ”$E.c” “$E.h” –style=ansi -s4 -K -W -p -H -xC80 -S -m0 -c 本文转自来源：贴吧偶遇，分享博客制作心得的路人，Keil5代码格式化工具]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F12%2FHello-World%2F</url>
    <content type="text"><![CDATA[放弃不难，但坚持一定很酷]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
